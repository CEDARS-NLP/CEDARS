{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Background CEDARS (Clinical Event Detection and Recording System) is a computational paradigm for collection and aggregation of time-to-event data in retrospective clinical studies. Developed out of a practical need for a more efficient way to conduct medical research, it aims to systematize and accelerate the review of electronic health record (EHR) corpora to detect and characterize clinical events. Using CEDARS, human abstractors can work more efficently through the use of dedicated graphical user interface (GUI). the system also incorporates a customized data storage scheme and a natural language processing (NLP) pipeline. In its current iteration, CEDARS is available as an open-source Python package under GPL-3 license . The latest package and previous versions can be cloned from GitHub . Full documentation is available here . CEDARS can be used with or without its companion NLP package PINES . Please see the Terms of Use before using CEDARS. CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. General Requirements Python 3.9 or later Docker Basic Concepts Sentences with keywords or concepts of interest are presented to the end user one at a time and in chronological order. The user assesses each sentence, determining whether or not a clinical event is being reported. The whole note or report drawn from the EHR is available for review in the GUI. If no event is declared in the sentence, CEDARS presents the next sentence for the same patient (#1). If an event date is entered, CEDARS moves to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. In order for CEDARS to be sufficiently sensitive and not miss and unacceptable number of clinical events, the keyword/concept search query must be well thought and exhaustive. The performance of CEDARS will vary by medical area, since the extent of medical lexicon will vary substantially between event types. Features Automatic Detection of Key Events Easy interface to upload and query medical data. Project Statistics Secure Login Operational Schema CEDARS is modular and all information for any given annotation project is stored in one MongoDB database. User credentials, original clinical notes, NLP annotations and patient-specific information are stored in dedicated collections. Once clinical notes have been uploaded, they are passed through the NLP pipeline. Currently only UDPipe is supported and integrated with CEDARS. If desired, the annotation pipeline can include negation and medical concept tagging by NegEx and UMLS respectively. Multiple users can load the web GUI and annotate records at the same time. Once accessed, a given patient record is locked for the user. Future Development We are currently documenting the performance of CEDARS with a focus on oncology clinical research. At the present time, we wish to solidify the CEDARS user interface and ensure a smooth experience in multi-user settings. In the longer term, plug-in modules featuring enhanced query generation and adaptive learning will be integrated into the R workflow. Support for other NLP engines and extensive parallel processing are also desirable. Please communicate with package author Simon Mantha, MD, MPH ( smantha@cedars.io ) if you want to discuss new features or using this software for your clinical research application.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#background","text":"CEDARS (Clinical Event Detection and Recording System) is a computational paradigm for collection and aggregation of time-to-event data in retrospective clinical studies. Developed out of a practical need for a more efficient way to conduct medical research, it aims to systematize and accelerate the review of electronic health record (EHR) corpora to detect and characterize clinical events. Using CEDARS, human abstractors can work more efficently through the use of dedicated graphical user interface (GUI). the system also incorporates a customized data storage scheme and a natural language processing (NLP) pipeline. In its current iteration, CEDARS is available as an open-source Python package under GPL-3 license . The latest package and previous versions can be cloned from GitHub . Full documentation is available here . CEDARS can be used with or without its companion NLP package PINES . Please see the Terms of Use before using CEDARS. CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations.","title":"Background"},{"location":"#general-requirements","text":"Python 3.9 or later Docker","title":"General Requirements"},{"location":"#basic-concepts","text":"Sentences with keywords or concepts of interest are presented to the end user one at a time and in chronological order. The user assesses each sentence, determining whether or not a clinical event is being reported. The whole note or report drawn from the EHR is available for review in the GUI. If no event is declared in the sentence, CEDARS presents the next sentence for the same patient (#1). If an event date is entered, CEDARS moves to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. In order for CEDARS to be sufficiently sensitive and not miss and unacceptable number of clinical events, the keyword/concept search query must be well thought and exhaustive. The performance of CEDARS will vary by medical area, since the extent of medical lexicon will vary substantially between event types.","title":"Basic Concepts"},{"location":"#features","text":"Automatic Detection of Key Events Easy interface to upload and query medical data. Project Statistics Secure Login","title":"Features"},{"location":"#operational-schema","text":"CEDARS is modular and all information for any given annotation project is stored in one MongoDB database. User credentials, original clinical notes, NLP annotations and patient-specific information are stored in dedicated collections. Once clinical notes have been uploaded, they are passed through the NLP pipeline. Currently only UDPipe is supported and integrated with CEDARS. If desired, the annotation pipeline can include negation and medical concept tagging by NegEx and UMLS respectively. Multiple users can load the web GUI and annotate records at the same time. Once accessed, a given patient record is locked for the user.","title":"Operational Schema"},{"location":"#future-development","text":"We are currently documenting the performance of CEDARS with a focus on oncology clinical research. At the present time, we wish to solidify the CEDARS user interface and ensure a smooth experience in multi-user settings. In the longer term, plug-in modules featuring enhanced query generation and adaptive learning will be integrated into the R workflow. Support for other NLP engines and extensive parallel processing are also desirable. Please communicate with package author Simon Mantha, MD, MPH ( smantha@cedars.io ) if you want to discuss new features or using this software for your clinical research application.","title":"Future Development"},{"location":"ABOUT/","text":"About CEDARS was created out of a need to more efficiently annotate patient datasets for clinical events. The initial application was for the assessment of a venous thromboembolism endpoint in a cohort of patients with cancer, however early on we decided to develop this software platform as a general purpose tool aimed at a broad array of clinical endpoints. The original implementation was in R programming language but more recently the code base was ported to Python. CEDARS is under development at Memorial Sloan Kettering Cancer Center (MSKCC) . The package authors include: Simon Mantha, MD, MPH : project lead, clinical hematologist by training Rohan Singh, MS : principal data scientist Kayan Irani : collaborator","title":"About"},{"location":"ABOUT/#about","text":"CEDARS was created out of a need to more efficiently annotate patient datasets for clinical events. The initial application was for the assessment of a venous thromboembolism endpoint in a cohort of patients with cancer, however early on we decided to develop this software platform as a general purpose tool aimed at a broad array of clinical endpoints. The original implementation was in R programming language but more recently the code base was ported to Python. CEDARS is under development at Memorial Sloan Kettering Cancer Center (MSKCC) . The package authors include: Simon Mantha, MD, MPH : project lead, clinical hematologist by training Rohan Singh, MS : principal data scientist Kayan Irani : collaborator","title":"About"},{"location":"CEDARS_admin_manual/","text":"CEDARS Administrator Manual CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. All CEDARS installations should be reviewed with institutional information security authorities. Software Installation Minimum CPU requirements: 32GB Memory and 8 cores [t2.2xlarge on AWS] In order to run, you will need two .env files The first .env file will be placed under the ROOT DIR The second the .env file under the CEDARS/cedars directory. .sample.env files are available - please modify them with your settings and rename it to .env bash CEDARS/ \u2502 \u251c\u2500\u2500 .env \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 cedars/ \u2502 \u251c\u2500\u2500 .env \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 ... CEDARS/.env : This file contains environment variables used by Docker Compose. CEDARS/cedars/.env : This file contains environment variables specific to cedars application. docker-compose.yml : The Docker Compose configuration file. cedars/Dockerfile : The Dockerfile for building cedars app. Detailed Requirements Local Installation Requirement WARNING Local installation is not recommended unless you want to modify the underlying codebase. It is recommended to use the Docker deployment method. For example: SECRET_KEY = \\xcfR\\xd9D\\xaa\\x06\\x84S\\x19\\xc0\\xdcA\\t\\xf7it HOST=0.0.0.0 DB_HOST=localhost # change to DB_HOST=db if running docker container DB_NAME=cedars DB_PORT=27017 MINIO_HOST=localhost MINIO_PORT=9000 MINIO_ACCESS_KEY=ROOTUSER MINIO_SECRET_KEY=CHANGEME123 ENV=dev PINES_API_URL=<> # if using PINES RQ_DASHBOARD_URL=/rq # URL for dashboard to interact with redis queues CEDARS is a flask web application and depends on the following software: Python 3.9 - 3.11 You can install Python from the official website . If you have multiple python versions installed, you can manage the environments using pyenv Windows Setup Specification On windows machines for development setups (not using docker) only python 3.9 is supported. If using windows, then installing python via WSL is recommended. Poetry To install poetry, run pipx install poetry or follow the instructions . Mongo 7.0 or later For using Mongo, you have multiple options: You might use your own enterprise Mongo instance You can use a cloud-based service like MongoDB Atlas You can run a local instance of Mongo using Docker You can run a local instance of Mongo using the official installation Minio Similar to Mongo, you have multiple options to install MINIO You might use your own enterprise MINIO instance You can use a cloud-based service like MINIO You can run a local instance of MINIO using Docker You can run a local instance of MINIO using the official installation Redis Mac Fork Issue On MacOS, if you see a issue with fork processes you will need to export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES for running the rq workers To manage long running processes such as upload, download, spacy labelling, PINES jobs etc. You can install redis locally on your computer Run redis docker image Docker Requirement TIP This is the easiest way to run CEDARS and encapsulates all dependencies above. TIP If using docker on windows, it is recommended to install docker via WSL . Install Docker and Docker Compose . TIP Please install docker compose v2 as the spec using deploy which is not compatible with v1. System Architecture The CEDARS application runs on a web server and generates an online graphical user interface (GUI) using Flask. All data are stored in a MongoDB instance hosted separately. However, most CEDARS instances are dockerized in order to streamline the project setup process and ensure adequate compatibility of dependencies. Once the instance is running, electronic health record (EHR) documents are imported and processed through the CEDARS natural language processing (NLP) pipeline. Additional document annotation with a PINES model is optional. A CEDARS annotation project can be set up entirely from the GUI, using the administrator panel. The existing annotations can be downloaded at any point from this interface. Annotators can connect to the CEDARS app by accessing a web URL provided by the administrator. CEDARS performs the operations to pull selected documents from the database, process them and present them to the annotators. Data entered by users is processed by CEDARS and saved to the database. Multiple users can work on one CEDARS project at the same time. The application will automatically select individual patient records for each user. Record locking is implemented to prevent collisions and inconsistencies. Installing CEDARS To install CEDARS, please start by cloning the repository and installing the required dependencies. You can then run the app locally or using Docker. Clone the Repo: git clone git@github.com:CEDARS-NLP/CEDARS.git Change directory: cd CEDARS Initialize submodules: git submodule init Download submodules: git submodule update git submodule update time out If you are accessing git over http - take following steps - update .gitmodules in the root dir with url = https://github.com/CEDARS-NLP/PINES.git - Run: git submodule sync - Run: git submodule update Standalone CEDARS Python Package Installation Make sure all the local requirements above are met. Then, you can install the package using Poetry: $ cd cedars $ poetry install # do not cd into cedars/app $ poetry run python -m app.wsgi Setting Up VS Code Debugger for Flask Application (OPTIONAL) If you are a developer and wish to use a code debugger while working with CEDARS, then you can follow the steps below to setup a VS Code debugger. 1. Create a python virtual environment (preferably using [pyenv](https://github.com/pyenv/pyenv?tab=readme-ov-file#installation)). 2. Create a profile in launch.json (VS Code) as defined in [this](https://code.visualstudio.com/docs/python/tutorial-flask#_run-the-app-in-the-debugger) article. 3. Set FLASK_APP variable to \u201capp/wsgi.py\u201d in the new launch.json you created. 4. Follow these [instructions](https://code.visualstudio.com/docs/python/environments) to load the python virtual environment you created in step 1. into VS Code. 5. Select you new debugger profile in the debugger tab and run it. Docker Deployment The most straightforward way to complete a CEDARS project is via docker containers. This approach allows fast and reliable installation on prems or in the cloud with on-demand access to compute resources, including graphics processing unit (GPU). Inclusion of required dependencies in the containers mitigate the problems associated with version incompatibilities inherent to ad hoc builds. Docker images can be easily installed in air-gapped environment, which is sometimes an institutional requirement. A CEDARS docker deployment will include: CEDARS Flask web server MongoDB database service MINIO object storage service PINES NLP annotation service (optional) Each component runs as a service encapsulated in a docker container. Those three elements a coordinated within a deployment.The PINES service requires a GPU for model training. This is optional for inference (i.e. annotating documents). After cloning as described above, create required .env files as mentioned here After creating .env files, run the following commands: $ cd CEDARS # if you do are not using GPU and want all the services to be hosted on docker $ docker compose --profile cpu --profile selfhosted up --build -d # if you are using a GPU $ docker compose --profile gpu --profile selfhosted up --build -d # if you want to use a native service such as AWS Document DB $ docker compose --profile gpu up --build -d # gpu $ docker compose --profile cpu up --build -d # cpu Once all services are started - the app will be available here http://<hostaddress>:80 AWS/Server Deployment Install docker: Ubuntu Make sure you have docker compose v2 if you are running docker as sudo - please follow this stackoverflow link to run as a non-sudo Install compose v2 using this link For example to use AWS DocumentDB with tls you can create .env (under CEDARS/cedars) file like this DB_HOST=<your-cluster-ip>.docdb.amazonaws.com DB_NAME=cedars DB_PORT=27017 DB_USER=<docdbuser> DB_PWD=<docDBpassword> DB_PARAMS=\"tls=true&tlsCAFile=global-bundle.pem&replicaSet=rs0&readPreference=secondaryPreferred&retryWrites=false\" Project Execution Overview Determining clinical event dates with CEDARS is a simple, sequential process: After generation of a CEDARS instance, EHR documents are uploaded, a keyword search query is generated and automatic NLP annotations are launched, following which manual data entry can begin. If known event dates exist, those can be imported before annotator work starts. Once all patient records have been annotated manually for clinical events, the dataset can be downloaded and used immediately in time-to-event analyses. Alternatively, estimated event dates can be obtained without the human review step if a PINES model of satisfactory accuracy was used to classify documents. The package authors suggest that a random sample of patients be selected for manual review via independent means. If performance metrics are unsatisfactory, the search query can be modified and CEDARS annotations updated through the same process. Setting Up a CEDARS Project and Users The first step after running CEDARS is to set up a new project. This is done by the administrator through the GUI. The following steps are required: 1. At first login, the administrator will be prompted to register a new user. This user will be the administrator of the project. 2. The administrator will then fill in Project Details such as Project Name. 3. The administrator can also create new users who will only work on the Annotation Interface. 4. Administrator will provide the credentials to the annotators. Electronic Health Record Corpus Upload Keyword Search Query Design The CEDARS search query incorporates the following wildcards: \"?\": for one character, for example \"r?d\" would match \"red\" or \"rod\" but not \"reed\" \"*\": for zero to any number of characters, for example \"r*\" would match \"red\", \"rod\", \"reed\", \"rd\", etc. CEDARS also applies the following Boolean operators: \"AND\": both conditions present \"OR\": either present present \"!\": negation, for example \"!red\" would only match sentences without the word \"red\" Lastly, the \"(\" and \")\" operators can be used to further develop logic within a query. Search Query Implementation Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. Spacy Requirements: ! - negation Each dictionary in a list matches one token only A list matches all the dictionaries inside it (and condition) A list of list contains OR conditions [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text Implementation: Split the query by OR Split each expression by AND Split each expression by NOT Split each expression by wildcard Convert each expression to a spacy pattern Combine the patterns Return the combined pattern Source code in cedars/app/nlpprocessor.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def query_to_patterns ( query : str ) -> list : \"\"\" Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. ##### Spacy Requirements: - ! - negation - Each dictionary in a list matches one token only - A list matches all the dictionaries inside it (and condition) - A list of list contains OR conditions - [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match - [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT - [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text ##### Implementation: 1. Split the query by OR 2. Split each expression by AND 3. Split each expression by NOT 4. Split each expression by wildcard 5. Convert each expression to a spacy pattern 6. Combine the patterns 7. Return the combined pattern \"\"\" or_expressions = query . split ( \" OR \" ) res = [[] for _ in range ( len ( or_expressions ))] for i , expression in enumerate ( or_expressions ): spacy_pattern = [] expression = expression . strip () . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) and_expressions = expression . split ( \" AND \" ) for tok in and_expressions : tok = tok . strip () if not tok : continue if \"*\" in tok or \"?\" in tok : spacy_pattern . append ( get_regex_dict ( tok )) elif \"!\" in tok : spacy_pattern . append ( get_negated_dict ( tok . replace ( \"!\" , \"\" ))) else : spacy_pattern . append ( get_lemma_dict ( tok )) logger . debug ( f \" { expression } -> { spacy_pattern } \" ) res [ i ] = spacy_pattern return res Natural Language Processing Annotations The process of automatically parsing clinical documents before presentation to an annotator is performed in three steps: 1. NLP annotation via the SpaCy traditional NLP pipeline : In this step, sentence boundaries, lemmas and negation status are characterized. Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. Ex. This is not an apple. In the above sentence, the token apple is negated. Parameters: spacy ( token ) \u2013 This is a token of a single word after spacy Returns: \u2013 (bool) : True if the token is negated in the sentence. Source code in cedars/app/nlpprocessor.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def is_negated ( span ): \"\"\" ##### Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. ``` Ex. This is not an apple. In the above sentence, the token apple is negated. ``` Args: spacy token : This is a token of a single word after spacy runs a model on some text. Returns: (bool) : True if the token is negated in the sentence. \"\"\" neg_words = [ 'no' , 'not' , \"n't\" , \"wouldn't\" , 'never' , 'nobody' , 'nothing' , 'neither' , 'nowhere' , 'noone' , 'no-one' , 'hardly' , 'scarcely' , 'barely' ] for token in span . subtree : parents = list ( token . ancestors ) children = list ( token . children ) for parent in token . ancestors : children . extend ( list ( parent . children )) if ( \"neg\" in [ child . dep_ for child in children ]) or ( \"neg\" in [ par . dep_ for par in parents ]): return True parents_text = [ par . text for par in parents ] children_text = [ child . text for child in children ] for word in neg_words : if word in parents_text or word in children_text : return True return False 2. Keyword query matching : only documents with at least one sentence matching the search query are retained. Sentences from documents without a matched will be marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually. Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. Source code in cedars/app/nlpprocessor.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def process_notes ( self , patient_id : str , processes = 1 , batch_size = 20 ): \"\"\" ##### Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. \"\"\" # nlp_model = spacy.load(model_name) assert len ( self . matcher ) == 0 query = db . get_search_query () # load previosly processed documents # document_processed = load_progress() spacy_patterns = query_to_patterns ( query ) for i , item in enumerate ( spacy_patterns ): self . matcher . add ( f \"DVT_ { i } \" , [ item ]) # check all documents already processed documents_to_process = [] if patient_id is not None : # get all note for patient which are not reviewed documents_to_process = db . get_documents_to_annotate ( patient_id ) else : # get all notes which are not in annotation collection. documents_to_process = db . get_documents_to_annotate () document_list = [ document for document in documents_to_process ] if len ( document_list ) == 0 : # no notes found to annotate logger . info ( f \"No documents to process for patient { patient_id } \" ) if db . get_search_query ( \"tag_query\" )[ \"nlp_apply\" ] is True : self . process_patient_pines ( patient_id ) return document_text = [ document [ \"text\" ] for document in document_list ] if patient_id is not None : logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' , patient_id = patient_id ) } to process\" ) else : logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' ) } documents to process\" ) # logger.info(f\"sample document: {document_text[0][:100]}\") annotations = self . nlp_model . pipe ([ document [ \"text\" ] . lower () for document in document_list ], n_process = processes , batch_size = batch_size ) logger . info ( f \"Starting to process document annotations: { len ( document_text ) } \" ) count = 0 docs_with_annotations = 0 for document , doc in zip ( document_list , annotations ): match_count = 0 sentence_start = 0 sentence_end = 0 for sent_no , sentence_annotation in enumerate ( doc . sents ): sentence_text = sentence_annotation . text . strip () sentence_end = sentence_start + len ( sentence_text ) matches = self . matcher ( sentence_annotation ) for match in matches : _ , start , end = match token = sentence_annotation [ start : end ] has_negation = is_negated ( token ) token_start = token . start_char token_end = token_start + len ( token . text ) annotation = { \"sentence\" : sentence_text , \"token\" : token . text , \"isNegated\" : has_negation , \"note_start_index\" : token_start , \"note_end_index\" : token_end , \"sentence_number\" : sent_no , \"sentence_start\" : sentence_start , \"sentence_end\" : sentence_end } annotation [ 'note_id' ] = document [ \"text_id\" ] annotation [ \"text_date\" ] = document [ \"text_date\" ] annotation [ \"patient_id\" ] = document [ \"patient_id\" ] annotation [ \"reviewed\" ] = False db . insert_one_annotation ( annotation ) if not has_negation : if match_count == 0 : docs_with_annotations += 1 match_count += 1 sentence_start = sentence_end + 1 if match_count == 0 : db . mark_note_reviewed ( document [ \"text_id\" ], reviewed_by = \"CEDARS\" ) count += 1 if ( count ) % 10 == 0 : logger . info ( f \"Processed { count } / { len ( document_list ) } documents\" ) # Mark the patient as reviewed if no annotations are found. if docs_with_annotations == 0 : db . mark_patient_reviewed ( patient_id , \"CEDARS\" ) # check if nlp processing is enabled if docs_with_annotations > 0 and db . get_search_query ( \"tag_query\" )[ \"nlp_apply\" ] is True : logger . info ( f \"Processing { docs_with_annotations } documents with PINES\" ) self . process_patient_pines ( patient_id ) 3. Transformer model labelling (optional): individual documents are labelled for their probability ( p ) of occurring at or after a clinical event. This last step is facultative and offers the possibility of further narrowing the scope of material to be reviewed manually, further improving efficiency. Documents with a p inferior to the predetermined threshold and their associated sentences are marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually. PINES predictions Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" pines_api_url = get_pines_url () url = f ' { pines_api_url } /predict' data = { 'text' : note } log_notes = None try : response = requests . post ( url , json = data , timeout = 3600 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score log_notes = re . sub ( r '\\d' , '*' , note [: 20 ]) logger . debug ( f \"Got prediction for note: { log_notes } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { log_notes } \" ) raise e Save PINES predictions Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) count = 0 for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"text_date\" : note . get ( \"text_date\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) count += 1 Event Pre-Loading Sometimes a cohort of patients will already have been assessed with other methods and CEDARS is used as a redundant method to pick up any previously missed events. In this use case, a list of known clinical events with their dates will exist. This information can be loaded on CEDARS as a \"starting point\", so as to avoid re-discovering already documented events. Manual Assessment for Clinical Events The process by which human abstractors annotate patient records for events is described in the End User Manual . This step can be skipped altogether if a PINES model was used to classify documents. An estimated event date will be generated by PINES. Transformer models often exhibit sufficient performance to be used without individual record review, but an audit step as detailed below is strongly advised to confirm satisfactory sensitivity, specifcity and event time estimation. Error Handling and Queues All the jobs are processed at a patient level. For each patient, a job is submitted to a rq . If a job fails, it is retried 3 times before moving it a failed queue. Queue Operations docker ps - to see list of all docker contains docker exec -it <any-worker-docker-container-id> bash export REDIS_HOST=redis - the service name in nginx/nginx.conf rq info (status) rq requeue --queue cedars -a (requeue all failed jobs) Launch a task and add it to Mongo if it doesn't already exist. TODO: insert only one Source code in cedars/app/db.py 1610 1611 1612 1613 1614 1615 1616 def add_task ( task ): \"\"\" Launch a task and add it to Mongo if it doesn't already exist. # TODO: insert only one \"\"\" task_db = mongo . db [ \"TASK\" ] task_db . insert_one ( task ) Dataset Download Once there are no patient records left to review, event data can be downloaded from the database via the GUI Detailed information is provided including clinical event dates, individual annotator contribution and review times. If a PINES model was used but no manual annotations were applied, estimated event dates can be used in a time-to-event analysis instead of manual entry. Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes Source code in cedars/app/ops.py 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 @bp . route ( '/download_annotations' , methods = [ \"POST\" ]) @auth . admin_required def download_file ( filename = 'annotations.csv' ): \"\"\" ##### Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes \"\"\" logger . info ( \"Downloading annotations\" ) filename = request . form . get ( \"filename\" ) file = minio . get_object ( g . bucket_name , f \"annotated_files/ { filename } \" ) logger . info ( f \"Downloaded annotations from s3: { filename } \" ) return flask . Response ( file . stream ( 32 * 1024 ), mimetype = 'text/csv' , headers = { \"Content-Disposition\" : f \"attachment;filename=cedars_ { filename } \" } ) Audit CEDARS is by definition semi-automated, and depending on the specific use case and search query some events might be missed. This problem should be quantified by means of a systematic, old-fashion review of randomly selected patients. Typically, at least 200 patients would be selected and their corpora reviewed manually for events. Alternatively, a different method (e.g. billing codes) could be used. This audit dataset should be overlapped with the CEDARS event table to estimate sensitivity of the search query in the cohort at large. If this parameter falls below the previously established minimum acceptable value, the search query scope should be broadened, followed by a database reset, uploading of previously identified events and a new human annotation pass, followed by a repeat audit. Project Termination Once all events have been tallied and the audit results are satisfactory, if desired the CEDARS project database can be deleted from the MongoDB database. This is an irreversible operation. In future, there will be way to archive CEDARS projects, but this feature is not yet available. Issues Unable to install thinc - downgrade python version < 3.12 Terminate the Project Reset the database to the initial state. Source code in cedars/app/db.py 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) # Delete all mongo DB collections mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) mongo . db . drop_collection ( \"TASK\" ) mongo . db . drop_collection ( \"RESULTS\" ) project_id = os . getenv ( \"PROJECT_ID\" , None ) create_project ( project_name = fake . slug (), investigator_name = fake . name (), project_id = project_id )","title":"Administrator Manual"},{"location":"CEDARS_admin_manual/#cedars-administrator-manual","text":"CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. All CEDARS installations should be reviewed with institutional information security authorities.","title":"CEDARS Administrator Manual"},{"location":"CEDARS_admin_manual/#software-installation","text":"Minimum CPU requirements: 32GB Memory and 8 cores [t2.2xlarge on AWS] In order to run, you will need two .env files The first .env file will be placed under the ROOT DIR The second the .env file under the CEDARS/cedars directory. .sample.env files are available - please modify them with your settings and rename it to .env bash CEDARS/ \u2502 \u251c\u2500\u2500 .env \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 cedars/ \u2502 \u251c\u2500\u2500 .env \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 ... CEDARS/.env : This file contains environment variables used by Docker Compose. CEDARS/cedars/.env : This file contains environment variables specific to cedars application. docker-compose.yml : The Docker Compose configuration file. cedars/Dockerfile : The Dockerfile for building cedars app.","title":"Software Installation"},{"location":"CEDARS_admin_manual/#detailed-requirements","text":"","title":"Detailed Requirements"},{"location":"CEDARS_admin_manual/#local-installation-requirement","text":"WARNING Local installation is not recommended unless you want to modify the underlying codebase. It is recommended to use the Docker deployment method. For example: SECRET_KEY = \\xcfR\\xd9D\\xaa\\x06\\x84S\\x19\\xc0\\xdcA\\t\\xf7it HOST=0.0.0.0 DB_HOST=localhost # change to DB_HOST=db if running docker container DB_NAME=cedars DB_PORT=27017 MINIO_HOST=localhost MINIO_PORT=9000 MINIO_ACCESS_KEY=ROOTUSER MINIO_SECRET_KEY=CHANGEME123 ENV=dev PINES_API_URL=<> # if using PINES RQ_DASHBOARD_URL=/rq # URL for dashboard to interact with redis queues CEDARS is a flask web application and depends on the following software: Python 3.9 - 3.11 You can install Python from the official website . If you have multiple python versions installed, you can manage the environments using pyenv Windows Setup Specification On windows machines for development setups (not using docker) only python 3.9 is supported. If using windows, then installing python via WSL is recommended. Poetry To install poetry, run pipx install poetry or follow the instructions . Mongo 7.0 or later For using Mongo, you have multiple options: You might use your own enterprise Mongo instance You can use a cloud-based service like MongoDB Atlas You can run a local instance of Mongo using Docker You can run a local instance of Mongo using the official installation Minio Similar to Mongo, you have multiple options to install MINIO You might use your own enterprise MINIO instance You can use a cloud-based service like MINIO You can run a local instance of MINIO using Docker You can run a local instance of MINIO using the official installation Redis Mac Fork Issue On MacOS, if you see a issue with fork processes you will need to export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES for running the rq workers To manage long running processes such as upload, download, spacy labelling, PINES jobs etc. You can install redis locally on your computer Run redis docker image","title":"Local Installation Requirement"},{"location":"CEDARS_admin_manual/#docker-requirement","text":"TIP This is the easiest way to run CEDARS and encapsulates all dependencies above. TIP If using docker on windows, it is recommended to install docker via WSL . Install Docker and Docker Compose . TIP Please install docker compose v2 as the spec using deploy which is not compatible with v1.","title":"Docker Requirement"},{"location":"CEDARS_admin_manual/#system-architecture","text":"The CEDARS application runs on a web server and generates an online graphical user interface (GUI) using Flask. All data are stored in a MongoDB instance hosted separately. However, most CEDARS instances are dockerized in order to streamline the project setup process and ensure adequate compatibility of dependencies. Once the instance is running, electronic health record (EHR) documents are imported and processed through the CEDARS natural language processing (NLP) pipeline. Additional document annotation with a PINES model is optional. A CEDARS annotation project can be set up entirely from the GUI, using the administrator panel. The existing annotations can be downloaded at any point from this interface. Annotators can connect to the CEDARS app by accessing a web URL provided by the administrator. CEDARS performs the operations to pull selected documents from the database, process them and present them to the annotators. Data entered by users is processed by CEDARS and saved to the database. Multiple users can work on one CEDARS project at the same time. The application will automatically select individual patient records for each user. Record locking is implemented to prevent collisions and inconsistencies.","title":"System Architecture"},{"location":"CEDARS_admin_manual/#installing-cedars","text":"To install CEDARS, please start by cloning the repository and installing the required dependencies. You can then run the app locally or using Docker. Clone the Repo: git clone git@github.com:CEDARS-NLP/CEDARS.git Change directory: cd CEDARS Initialize submodules: git submodule init Download submodules: git submodule update git submodule update time out If you are accessing git over http - take following steps - update .gitmodules in the root dir with url = https://github.com/CEDARS-NLP/PINES.git - Run: git submodule sync - Run: git submodule update","title":"Installing CEDARS"},{"location":"CEDARS_admin_manual/#standalone-cedars-python-package-installation","text":"Make sure all the local requirements above are met. Then, you can install the package using Poetry: $ cd cedars $ poetry install # do not cd into cedars/app $ poetry run python -m app.wsgi","title":"Standalone CEDARS Python Package Installation"},{"location":"CEDARS_admin_manual/#setting-up-vs-code-debugger-for-flask-application-optional","text":"If you are a developer and wish to use a code debugger while working with CEDARS, then you can follow the steps below to setup a VS Code debugger. 1. Create a python virtual environment (preferably using [pyenv](https://github.com/pyenv/pyenv?tab=readme-ov-file#installation)). 2. Create a profile in launch.json (VS Code) as defined in [this](https://code.visualstudio.com/docs/python/tutorial-flask#_run-the-app-in-the-debugger) article. 3. Set FLASK_APP variable to \u201capp/wsgi.py\u201d in the new launch.json you created. 4. Follow these [instructions](https://code.visualstudio.com/docs/python/environments) to load the python virtual environment you created in step 1. into VS Code. 5. Select you new debugger profile in the debugger tab and run it.","title":"Setting Up VS Code Debugger for Flask Application (OPTIONAL)"},{"location":"CEDARS_admin_manual/#docker-deployment","text":"The most straightforward way to complete a CEDARS project is via docker containers. This approach allows fast and reliable installation on prems or in the cloud with on-demand access to compute resources, including graphics processing unit (GPU). Inclusion of required dependencies in the containers mitigate the problems associated with version incompatibilities inherent to ad hoc builds. Docker images can be easily installed in air-gapped environment, which is sometimes an institutional requirement. A CEDARS docker deployment will include: CEDARS Flask web server MongoDB database service MINIO object storage service PINES NLP annotation service (optional) Each component runs as a service encapsulated in a docker container. Those three elements a coordinated within a deployment.The PINES service requires a GPU for model training. This is optional for inference (i.e. annotating documents). After cloning as described above, create required .env files as mentioned here After creating .env files, run the following commands: $ cd CEDARS # if you do are not using GPU and want all the services to be hosted on docker $ docker compose --profile cpu --profile selfhosted up --build -d # if you are using a GPU $ docker compose --profile gpu --profile selfhosted up --build -d # if you want to use a native service such as AWS Document DB $ docker compose --profile gpu up --build -d # gpu $ docker compose --profile cpu up --build -d # cpu Once all services are started - the app will be available here http://<hostaddress>:80","title":"Docker Deployment"},{"location":"CEDARS_admin_manual/#awsserver-deployment","text":"Install docker: Ubuntu Make sure you have docker compose v2 if you are running docker as sudo - please follow this stackoverflow link to run as a non-sudo Install compose v2 using this link For example to use AWS DocumentDB with tls you can create .env (under CEDARS/cedars) file like this DB_HOST=<your-cluster-ip>.docdb.amazonaws.com DB_NAME=cedars DB_PORT=27017 DB_USER=<docdbuser> DB_PWD=<docDBpassword> DB_PARAMS=\"tls=true&tlsCAFile=global-bundle.pem&replicaSet=rs0&readPreference=secondaryPreferred&retryWrites=false\"","title":"AWS/Server Deployment"},{"location":"CEDARS_admin_manual/#project-execution","text":"","title":"Project Execution"},{"location":"CEDARS_admin_manual/#overview","text":"Determining clinical event dates with CEDARS is a simple, sequential process: After generation of a CEDARS instance, EHR documents are uploaded, a keyword search query is generated and automatic NLP annotations are launched, following which manual data entry can begin. If known event dates exist, those can be imported before annotator work starts. Once all patient records have been annotated manually for clinical events, the dataset can be downloaded and used immediately in time-to-event analyses. Alternatively, estimated event dates can be obtained without the human review step if a PINES model of satisfactory accuracy was used to classify documents. The package authors suggest that a random sample of patients be selected for manual review via independent means. If performance metrics are unsatisfactory, the search query can be modified and CEDARS annotations updated through the same process.","title":"Overview"},{"location":"CEDARS_admin_manual/#setting-up-a-cedars-project-and-users","text":"The first step after running CEDARS is to set up a new project. This is done by the administrator through the GUI. The following steps are required: 1. At first login, the administrator will be prompted to register a new user. This user will be the administrator of the project. 2. The administrator will then fill in Project Details such as Project Name. 3. The administrator can also create new users who will only work on the Annotation Interface. 4. Administrator will provide the credentials to the annotators.","title":"Setting Up a CEDARS Project and Users"},{"location":"CEDARS_admin_manual/#electronic-health-record-corpus-upload","text":"","title":"Electronic Health Record Corpus Upload"},{"location":"CEDARS_admin_manual/#keyword-search-query-design","text":"The CEDARS search query incorporates the following wildcards: \"?\": for one character, for example \"r?d\" would match \"red\" or \"rod\" but not \"reed\" \"*\": for zero to any number of characters, for example \"r*\" would match \"red\", \"rod\", \"reed\", \"rd\", etc. CEDARS also applies the following Boolean operators: \"AND\": both conditions present \"OR\": either present present \"!\": negation, for example \"!red\" would only match sentences without the word \"red\" Lastly, the \"(\" and \")\" operators can be used to further develop logic within a query.","title":"Keyword Search Query Design"},{"location":"CEDARS_admin_manual/#search-query-implementation","text":"Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards.","title":"Search Query Implementation"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.query_to_patterns--spacy-requirements","text":"! - negation Each dictionary in a list matches one token only A list matches all the dictionaries inside it (and condition) A list of list contains OR conditions [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text","title":"Spacy Requirements:"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.query_to_patterns--implementation","text":"Split the query by OR Split each expression by AND Split each expression by NOT Split each expression by wildcard Convert each expression to a spacy pattern Combine the patterns Return the combined pattern Source code in cedars/app/nlpprocessor.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def query_to_patterns ( query : str ) -> list : \"\"\" Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. ##### Spacy Requirements: - ! - negation - Each dictionary in a list matches one token only - A list matches all the dictionaries inside it (and condition) - A list of list contains OR conditions - [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match - [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT - [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text ##### Implementation: 1. Split the query by OR 2. Split each expression by AND 3. Split each expression by NOT 4. Split each expression by wildcard 5. Convert each expression to a spacy pattern 6. Combine the patterns 7. Return the combined pattern \"\"\" or_expressions = query . split ( \" OR \" ) res = [[] for _ in range ( len ( or_expressions ))] for i , expression in enumerate ( or_expressions ): spacy_pattern = [] expression = expression . strip () . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) and_expressions = expression . split ( \" AND \" ) for tok in and_expressions : tok = tok . strip () if not tok : continue if \"*\" in tok or \"?\" in tok : spacy_pattern . append ( get_regex_dict ( tok )) elif \"!\" in tok : spacy_pattern . append ( get_negated_dict ( tok . replace ( \"!\" , \"\" ))) else : spacy_pattern . append ( get_lemma_dict ( tok )) logger . debug ( f \" { expression } -> { spacy_pattern } \" ) res [ i ] = spacy_pattern return res","title":"Implementation:"},{"location":"CEDARS_admin_manual/#natural-language-processing-annotations","text":"The process of automatically parsing clinical documents before presentation to an annotator is performed in three steps: 1. NLP annotation via the SpaCy traditional NLP pipeline : In this step, sentence boundaries, lemmas and negation status are characterized.","title":"Natural Language Processing Annotations"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.is_negated--negation-detection","text":"This function takes a spacy token and determines if it has been negated in the sentence. Ex. This is not an apple. In the above sentence, the token apple is negated. Parameters: spacy ( token ) \u2013 This is a token of a single word after spacy Returns: \u2013 (bool) : True if the token is negated in the sentence. Source code in cedars/app/nlpprocessor.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def is_negated ( span ): \"\"\" ##### Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. ``` Ex. This is not an apple. In the above sentence, the token apple is negated. ``` Args: spacy token : This is a token of a single word after spacy runs a model on some text. Returns: (bool) : True if the token is negated in the sentence. \"\"\" neg_words = [ 'no' , 'not' , \"n't\" , \"wouldn't\" , 'never' , 'nobody' , 'nothing' , 'neither' , 'nowhere' , 'noone' , 'no-one' , 'hardly' , 'scarcely' , 'barely' ] for token in span . subtree : parents = list ( token . ancestors ) children = list ( token . children ) for parent in token . ancestors : children . extend ( list ( parent . children )) if ( \"neg\" in [ child . dep_ for child in children ]) or ( \"neg\" in [ par . dep_ for par in parents ]): return True parents_text = [ par . text for par in parents ] children_text = [ child . text for child in children ] for word in neg_words : if word in parents_text or word in children_text : return True return False 2. Keyword query matching : only documents with at least one sentence matching the search query are retained. Sentences from documents without a matched will be marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually.","title":"Negation Detection"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.NlpProcessor.process_notes--process-query-matching","text":"This function takes a medical note and a regex query as input and annotates the relevant sections of the text. Source code in cedars/app/nlpprocessor.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def process_notes ( self , patient_id : str , processes = 1 , batch_size = 20 ): \"\"\" ##### Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. \"\"\" # nlp_model = spacy.load(model_name) assert len ( self . matcher ) == 0 query = db . get_search_query () # load previosly processed documents # document_processed = load_progress() spacy_patterns = query_to_patterns ( query ) for i , item in enumerate ( spacy_patterns ): self . matcher . add ( f \"DVT_ { i } \" , [ item ]) # check all documents already processed documents_to_process = [] if patient_id is not None : # get all note for patient which are not reviewed documents_to_process = db . get_documents_to_annotate ( patient_id ) else : # get all notes which are not in annotation collection. documents_to_process = db . get_documents_to_annotate () document_list = [ document for document in documents_to_process ] if len ( document_list ) == 0 : # no notes found to annotate logger . info ( f \"No documents to process for patient { patient_id } \" ) if db . get_search_query ( \"tag_query\" )[ \"nlp_apply\" ] is True : self . process_patient_pines ( patient_id ) return document_text = [ document [ \"text\" ] for document in document_list ] if patient_id is not None : logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' , patient_id = patient_id ) } to process\" ) else : logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' ) } documents to process\" ) # logger.info(f\"sample document: {document_text[0][:100]}\") annotations = self . nlp_model . pipe ([ document [ \"text\" ] . lower () for document in document_list ], n_process = processes , batch_size = batch_size ) logger . info ( f \"Starting to process document annotations: { len ( document_text ) } \" ) count = 0 docs_with_annotations = 0 for document , doc in zip ( document_list , annotations ): match_count = 0 sentence_start = 0 sentence_end = 0 for sent_no , sentence_annotation in enumerate ( doc . sents ): sentence_text = sentence_annotation . text . strip () sentence_end = sentence_start + len ( sentence_text ) matches = self . matcher ( sentence_annotation ) for match in matches : _ , start , end = match token = sentence_annotation [ start : end ] has_negation = is_negated ( token ) token_start = token . start_char token_end = token_start + len ( token . text ) annotation = { \"sentence\" : sentence_text , \"token\" : token . text , \"isNegated\" : has_negation , \"note_start_index\" : token_start , \"note_end_index\" : token_end , \"sentence_number\" : sent_no , \"sentence_start\" : sentence_start , \"sentence_end\" : sentence_end } annotation [ 'note_id' ] = document [ \"text_id\" ] annotation [ \"text_date\" ] = document [ \"text_date\" ] annotation [ \"patient_id\" ] = document [ \"patient_id\" ] annotation [ \"reviewed\" ] = False db . insert_one_annotation ( annotation ) if not has_negation : if match_count == 0 : docs_with_annotations += 1 match_count += 1 sentence_start = sentence_end + 1 if match_count == 0 : db . mark_note_reviewed ( document [ \"text_id\" ], reviewed_by = \"CEDARS\" ) count += 1 if ( count ) % 10 == 0 : logger . info ( f \"Processed { count } / { len ( document_list ) } documents\" ) # Mark the patient as reviewed if no annotations are found. if docs_with_annotations == 0 : db . mark_patient_reviewed ( patient_id , \"CEDARS\" ) # check if nlp processing is enabled if docs_with_annotations > 0 and db . get_search_query ( \"tag_query\" )[ \"nlp_apply\" ] is True : logger . info ( f \"Processing { docs_with_annotations } documents with PINES\" ) self . process_patient_pines ( patient_id ) 3. Transformer model labelling (optional): individual documents are labelled for their probability ( p ) of occurring at or after a clinical event. This last step is facultative and offers the possibility of further narrowing the scope of material to be reviewed manually, further improving efficiency. Documents with a p inferior to the predetermined threshold and their associated sentences are marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually.","title":"Process Query Matching"},{"location":"CEDARS_admin_manual/#cedars.app.db.get_prediction--pines-predictions","text":"Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" pines_api_url = get_pines_url () url = f ' { pines_api_url } /predict' data = { 'text' : note } log_notes = None try : response = requests . post ( url , json = data , timeout = 3600 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score log_notes = re . sub ( r '\\d' , '*' , note [: 20 ]) logger . debug ( f \"Got prediction for note: { log_notes } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { log_notes } \" ) raise e","title":"PINES predictions"},{"location":"CEDARS_admin_manual/#cedars.app.db.predict_and_save--save-pines-predictions","text":"Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) count = 0 for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"text_date\" : note . get ( \"text_date\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) count += 1","title":"Save PINES predictions"},{"location":"CEDARS_admin_manual/#event-pre-loading","text":"Sometimes a cohort of patients will already have been assessed with other methods and CEDARS is used as a redundant method to pick up any previously missed events. In this use case, a list of known clinical events with their dates will exist. This information can be loaded on CEDARS as a \"starting point\", so as to avoid re-discovering already documented events.","title":"Event Pre-Loading"},{"location":"CEDARS_admin_manual/#manual-assessment-for-clinical-events","text":"The process by which human abstractors annotate patient records for events is described in the End User Manual . This step can be skipped altogether if a PINES model was used to classify documents. An estimated event date will be generated by PINES. Transformer models often exhibit sufficient performance to be used without individual record review, but an audit step as detailed below is strongly advised to confirm satisfactory sensitivity, specifcity and event time estimation.","title":"Manual Assessment for Clinical Events"},{"location":"CEDARS_admin_manual/#error-handling-and-queues","text":"All the jobs are processed at a patient level. For each patient, a job is submitted to a rq . If a job fails, it is retried 3 times before moving it a failed queue.","title":"Error Handling and Queues"},{"location":"CEDARS_admin_manual/#queue-operations","text":"docker ps - to see list of all docker contains docker exec -it <any-worker-docker-container-id> bash export REDIS_HOST=redis - the service name in nginx/nginx.conf rq info (status) rq requeue --queue cedars -a (requeue all failed jobs) Launch a task and add it to Mongo if it doesn't already exist.","title":"Queue Operations"},{"location":"CEDARS_admin_manual/#cedars.app.db.add_task--todo-insert-only-one","text":"Source code in cedars/app/db.py 1610 1611 1612 1613 1614 1615 1616 def add_task ( task ): \"\"\" Launch a task and add it to Mongo if it doesn't already exist. # TODO: insert only one \"\"\" task_db = mongo . db [ \"TASK\" ] task_db . insert_one ( task )","title":"TODO: insert only one"},{"location":"CEDARS_admin_manual/#dataset-download","text":"Once there are no patient records left to review, event data can be downloaded from the database via the GUI Detailed information is provided including clinical event dates, individual annotator contribution and review times. If a PINES model was used but no manual annotations were applied, estimated event dates can be used in a time-to-event analysis instead of manual entry.","title":"Dataset Download"},{"location":"CEDARS_admin_manual/#cedars.app.ops.download_file--download-completed-annotations","text":"This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes Source code in cedars/app/ops.py 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 @bp . route ( '/download_annotations' , methods = [ \"POST\" ]) @auth . admin_required def download_file ( filename = 'annotations.csv' ): \"\"\" ##### Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes \"\"\" logger . info ( \"Downloading annotations\" ) filename = request . form . get ( \"filename\" ) file = minio . get_object ( g . bucket_name , f \"annotated_files/ { filename } \" ) logger . info ( f \"Downloaded annotations from s3: { filename } \" ) return flask . Response ( file . stream ( 32 * 1024 ), mimetype = 'text/csv' , headers = { \"Content-Disposition\" : f \"attachment;filename=cedars_ { filename } \" } )","title":"Download Completed Annotations"},{"location":"CEDARS_admin_manual/#audit","text":"CEDARS is by definition semi-automated, and depending on the specific use case and search query some events might be missed. This problem should be quantified by means of a systematic, old-fashion review of randomly selected patients. Typically, at least 200 patients would be selected and their corpora reviewed manually for events. Alternatively, a different method (e.g. billing codes) could be used. This audit dataset should be overlapped with the CEDARS event table to estimate sensitivity of the search query in the cohort at large. If this parameter falls below the previously established minimum acceptable value, the search query scope should be broadened, followed by a database reset, uploading of previously identified events and a new human annotation pass, followed by a repeat audit.","title":"Audit"},{"location":"CEDARS_admin_manual/#project-termination","text":"Once all events have been tallied and the audit results are satisfactory, if desired the CEDARS project database can be deleted from the MongoDB database. This is an irreversible operation. In future, there will be way to archive CEDARS projects, but this feature is not yet available.","title":"Project Termination"},{"location":"CEDARS_admin_manual/#issues","text":"Unable to install thinc - downgrade python version < 3.12","title":"Issues"},{"location":"CEDARS_admin_manual/#cedars.app.db.terminate_project--terminate-the-project","text":"Reset the database to the initial state. Source code in cedars/app/db.py 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) # Delete all mongo DB collections mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) mongo . db . drop_collection ( \"TASK\" ) mongo . db . drop_collection ( \"RESULTS\" ) project_id = os . getenv ( \"PROJECT_ID\" , None ) create_project ( project_name = fake . slug (), investigator_name = fake . name (), project_id = project_id )","title":"Terminate the Project"},{"location":"CEDARS_annotator_manual/","text":"CEDARS Annotator Manual Introduction This short manual is intended for data abstractors who will enter information about clinical events detected by CEDARS. CEDARS is a data pipepline set up to optimally present you with sentences drawn from a patient's medical record and potentially indicating the presence of a clinical event. Sentence detection is automatic and based on the words used, but often those sentences do not actually represent a true event. For example, the following sentence does not signal an actual new thrombotic episode: \"The patient was ruled-out for deep vein thrombosis last night.\" If sentence detection is based only on reporting sentences with the words \"deep vein thrombosis\", such a negative finding will be reported. In this case, you would not report an event and move on to the next sentence. Event detection approaches used by your CEDARS system administrator will vary, and some queries will be more selective than others, but generally the system will be set up to detect as many events as possible, at the cost of having a certain number of false positive findings. The intent here is for CEDARS to minimize the number of missed events, even if this approach results in you having to review a greater number of sentences. Sentences are presented in chronological order. Once you have identified and dated a clinical event, CEDARS might be set up by bypass all following sentences for this patient and move on to the next patient. This approach will be used when your system administrator only aims at capturing the first instance of an event of interest. Also, once you have evaluated all sentences of interest for a given patient, CEDARS will move on to the next patient seamlessly. This sequence of events is illustrated below: If you adjudicate a sentence as reporting no event, CEDARS will present the next sentence for the same patient (#1). On the other end, if you enter an event date, CEDARS will move to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. Login Go to your CEDARS URL and use the credentials provided by the administrator. Find Clinical Events As soon as you are logged in, CEDARS will start looking for the next available patient with information to review. It might take a few moments before the first sentence is presented to you. The following is an example from a simulated cohort: Keywords or concepts are highlighted in red to help you locate them in the text. Evaluating a Sentence Only one sentence to review will be presented at any given time. It can be found at the beginning of the section titled \"Selected sentence:\". Your first task is to determine whether or not the sentence refers to an actual clinical event of interest, i.e. if the sentence is a true positive. Typically you will be able to make up your mind just by reading the sentence itself. If the sentence is ambiguous and you would like to obtain more context, you can review the note or report from which the sentence was drawn, situated at the bottom of the screen under the section \"Selected note:\". Also, completely at the bottom of the screen you will find a list of tags with associated data. The information presented here will vary, but would typically include the patient's name, the type of note, the author etc. For your reference, the date of entry for the note from which the sentence was drawn is indicated below the sentence, along with sentence position (first, second, third in line for review, etc) and patient ID. Annotating a Negative Sentence In many cases, the sentence you are looking at will be a false positive, i.e. it does not represent the kind of event you were tasked to report. In this case, simply click on the button \"ADJUDICATE SENTENCE\". This will mark the sentence as such and move to the next one in line. Move Between Sentences Within a Patient's Record Often the sentence and note presented to you will hint at a possible event but remain ambiguous, or an event will be obvious but the timing unclear. In such cases, you can move from sentence to sentence by using the navigation buttons. The buttons operate as follows : - <, > Move one note back or forwards. - <<, >> Move ten notes back or forwards. - |<, >| Move to the first or last note for this patient. You will go from sentence to sentence, following the timeline of electronic record notes/reports. Note that using previous/next will not annotate sentences or otherwise enter information in the CEDARS database. Entering Information About a Patient Entering an Event Date Any known event date will be displayed at the beginning of section titled \"Event date:\". Most of the time this field will be empty, since generally speaking CEDARS projects aim to determine event dates for a cohort for which no prior information exists. However, CEDARS can also be used to verify known event dates, in which case the interface might display an event date for a patient you have not yet assessed. Your CEDARS system administrator will discuss this aspect with you before starting the project. Once you have determined a clinical event did indeed occur, the next step is to assess its timing. As noted above, you might have to travel between sentences or consult complete notes to confirm the date. Once you are ready to enter this information, click on the data entry field under the \"ENTER NEW DATE\" button. You will be prompted with a calendar. Once the date displayed is correct, press on button \"ENTER NEW DATE\". Given the nature of clinical narratives, not all events will be precisely dated. For example, a clinician might refer to an event only with the month and year, not the day. Such information can still be entered by using simple approximation guidelines. In CEDARS, if only the year of an event is known, enter July 1st of that year (e.g. \"2020-07-01\"). If only they year and month are known, enter the 15th day of that month/year (e.g. \"2020-11-15\" if the event was in November of 2020). When approximating a date, it is good practice to document this detail in a comment (see below). Deleting an Event Date It is possible to replace an erroneous date by entering a new one in the date entry field. If there was actually no event, the previously entered date can be deleted by clicking on button \"DELETE OLD DATE\". Entering Comments About a Patient At any point you can enter or edit comments about a patient in the Comments text-box at the bottom left of the adjudications page. Note that while you can click the \"Save Comment\" button to save the comment manually, the comment will also automatically be saved if you - Edit or delete the event date - Adjudicate the annotation - Navigate to another note for that patient Search for a Specific Patient If you want to go back to a specific patient later on, take note of the patient ID number. After logon, CEDARS will automatically present you with the next available patient to review, so if you have already annotated all sentences for a given patient, the only way to find that record again is to do a search. In this case, simply enter the patient ID number under in the box under \"Search for patient\" and click button \"SEARCH\". If you click \"SEARCH\" on an empty field, CEDARS will bring up the next available patient for you to review. Record Locking Only one end user at a time can review or enter information about any given patient in the CEDARS database. If someone else is already looking at a specific patient record, you will be locked from accessing it.","title":"Annotator Manual"},{"location":"CEDARS_annotator_manual/#cedars-annotator-manual","text":"","title":"CEDARS Annotator Manual"},{"location":"CEDARS_annotator_manual/#introduction","text":"This short manual is intended for data abstractors who will enter information about clinical events detected by CEDARS. CEDARS is a data pipepline set up to optimally present you with sentences drawn from a patient's medical record and potentially indicating the presence of a clinical event. Sentence detection is automatic and based on the words used, but often those sentences do not actually represent a true event. For example, the following sentence does not signal an actual new thrombotic episode: \"The patient was ruled-out for deep vein thrombosis last night.\" If sentence detection is based only on reporting sentences with the words \"deep vein thrombosis\", such a negative finding will be reported. In this case, you would not report an event and move on to the next sentence. Event detection approaches used by your CEDARS system administrator will vary, and some queries will be more selective than others, but generally the system will be set up to detect as many events as possible, at the cost of having a certain number of false positive findings. The intent here is for CEDARS to minimize the number of missed events, even if this approach results in you having to review a greater number of sentences. Sentences are presented in chronological order. Once you have identified and dated a clinical event, CEDARS might be set up by bypass all following sentences for this patient and move on to the next patient. This approach will be used when your system administrator only aims at capturing the first instance of an event of interest. Also, once you have evaluated all sentences of interest for a given patient, CEDARS will move on to the next patient seamlessly. This sequence of events is illustrated below: If you adjudicate a sentence as reporting no event, CEDARS will present the next sentence for the same patient (#1). On the other end, if you enter an event date, CEDARS will move to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed.","title":"Introduction"},{"location":"CEDARS_annotator_manual/#login","text":"Go to your CEDARS URL and use the credentials provided by the administrator.","title":"Login"},{"location":"CEDARS_annotator_manual/#find-clinical-events","text":"As soon as you are logged in, CEDARS will start looking for the next available patient with information to review. It might take a few moments before the first sentence is presented to you. The following is an example from a simulated cohort: Keywords or concepts are highlighted in red to help you locate them in the text.","title":"Find Clinical Events"},{"location":"CEDARS_annotator_manual/#evaluating-a-sentence","text":"Only one sentence to review will be presented at any given time. It can be found at the beginning of the section titled \"Selected sentence:\". Your first task is to determine whether or not the sentence refers to an actual clinical event of interest, i.e. if the sentence is a true positive. Typically you will be able to make up your mind just by reading the sentence itself. If the sentence is ambiguous and you would like to obtain more context, you can review the note or report from which the sentence was drawn, situated at the bottom of the screen under the section \"Selected note:\". Also, completely at the bottom of the screen you will find a list of tags with associated data. The information presented here will vary, but would typically include the patient's name, the type of note, the author etc. For your reference, the date of entry for the note from which the sentence was drawn is indicated below the sentence, along with sentence position (first, second, third in line for review, etc) and patient ID.","title":"Evaluating a Sentence"},{"location":"CEDARS_annotator_manual/#annotating-a-negative-sentence","text":"In many cases, the sentence you are looking at will be a false positive, i.e. it does not represent the kind of event you were tasked to report. In this case, simply click on the button \"ADJUDICATE SENTENCE\". This will mark the sentence as such and move to the next one in line.","title":"Annotating a Negative Sentence"},{"location":"CEDARS_annotator_manual/#move-between-sentences-within-a-patients-record","text":"Often the sentence and note presented to you will hint at a possible event but remain ambiguous, or an event will be obvious but the timing unclear. In such cases, you can move from sentence to sentence by using the navigation buttons. The buttons operate as follows : - <, > Move one note back or forwards. - <<, >> Move ten notes back or forwards. - |<, >| Move to the first or last note for this patient. You will go from sentence to sentence, following the timeline of electronic record notes/reports. Note that using previous/next will not annotate sentences or otherwise enter information in the CEDARS database.","title":"Move Between Sentences Within a Patient's Record"},{"location":"CEDARS_annotator_manual/#entering-information-about-a-patient","text":"","title":"Entering Information About a Patient"},{"location":"CEDARS_annotator_manual/#entering-an-event-date","text":"Any known event date will be displayed at the beginning of section titled \"Event date:\". Most of the time this field will be empty, since generally speaking CEDARS projects aim to determine event dates for a cohort for which no prior information exists. However, CEDARS can also be used to verify known event dates, in which case the interface might display an event date for a patient you have not yet assessed. Your CEDARS system administrator will discuss this aspect with you before starting the project. Once you have determined a clinical event did indeed occur, the next step is to assess its timing. As noted above, you might have to travel between sentences or consult complete notes to confirm the date. Once you are ready to enter this information, click on the data entry field under the \"ENTER NEW DATE\" button. You will be prompted with a calendar. Once the date displayed is correct, press on button \"ENTER NEW DATE\". Given the nature of clinical narratives, not all events will be precisely dated. For example, a clinician might refer to an event only with the month and year, not the day. Such information can still be entered by using simple approximation guidelines. In CEDARS, if only the year of an event is known, enter July 1st of that year (e.g. \"2020-07-01\"). If only they year and month are known, enter the 15th day of that month/year (e.g. \"2020-11-15\" if the event was in November of 2020). When approximating a date, it is good practice to document this detail in a comment (see below).","title":"Entering an Event Date"},{"location":"CEDARS_annotator_manual/#deleting-an-event-date","text":"It is possible to replace an erroneous date by entering a new one in the date entry field. If there was actually no event, the previously entered date can be deleted by clicking on button \"DELETE OLD DATE\".","title":"Deleting an Event Date"},{"location":"CEDARS_annotator_manual/#entering-comments-about-a-patient","text":"At any point you can enter or edit comments about a patient in the Comments text-box at the bottom left of the adjudications page. Note that while you can click the \"Save Comment\" button to save the comment manually, the comment will also automatically be saved if you - Edit or delete the event date - Adjudicate the annotation - Navigate to another note for that patient","title":"Entering Comments About a Patient"},{"location":"CEDARS_annotator_manual/#search-for-a-specific-patient","text":"If you want to go back to a specific patient later on, take note of the patient ID number. After logon, CEDARS will automatically present you with the next available patient to review, so if you have already annotated all sentences for a given patient, the only way to find that record again is to do a search. In this case, simply enter the patient ID number under in the box under \"Search for patient\" and click button \"SEARCH\". If you click \"SEARCH\" on an empty field, CEDARS will bring up the next available patient for you to review.","title":"Search for a Specific Patient"},{"location":"CEDARS_annotator_manual/#record-locking","text":"Only one end user at a time can review or enter information about any given patient in the CEDARS database. If someone else is already looking at a specific patient record, you will be locked from accessing it.","title":"Record Locking"},{"location":"TERMS_OF_USE/","text":"Terms of Use CEDARS (Clinical Event Detection And Recording System) PLEASE READ THIS DOCUMENT CAREFULLY BEFORE YOU ACCESS OR USE CEDARS. BY ACCESSING ANY PORTION OF CEDARS, YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS SET FORTH BELOW. IF YOU DO NOT WISH TO BE BOUND BY THESE TERMS AND CONDITIONS, PLEASE DO NOT ACCESS CEDARS. CEDARS is developed and maintained by Memorial Sloan Kettering Cancer Center (\u201cMSK,\u201d \u201cwe\u201d, or \u201cus\u201d) to assist in clinical event detection. MSK may, from time to time, update the software and other content on https://github.com/CEDARS-NLP/CEDARS (\u201cContent\u201d). MSK makes no warranties or representations, and hereby disclaims any warranties, express or implied, with respect to any of the Content, including as to the present accuracy, completeness, timeliness, adequacy, or usefulness of any of the Content. The entire risk as to the quality and performance of the Content is with you. By using this Content, you agree that MSK will not be liable for any losses or damages arising from your use of or reliance on the Content, or other websites or information to which this Content may be linked, including any general, special, incidental or consequential damages arising out of the use or inability to use the Content including, but not limited to, loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the Content to operate with any other software, programs, source code, etc. By making any use of the Content or submitting any information or data along with such to us, you authorize MSK to copy, modify, display, distribute, perform, use, publish, and otherwise exploit the same for any and all purposes, all without compensation to you, for as long as we decide (collectively, the \"Use Rights\"). In addition, you authorize MSK to grant any third party some or all of the Use Rights. By way of example, and not limitation, the Use Rights include the right for us to publish any data or information submitted in whole or in part for as long as we choose. By providing any data or information, you represent and warrant that (i) you own all rights in and to the information or data (including any related intellectual property rights) or have sufficient authority and right to provide the content and to grant the Use Rights; (ii) your submission of the information or data and grant to us of Use Rights do not violate or conflict with the rights of other persons, or breach your obligations to other persons; and (iii) the information or data does not include or contain any personally identifiable information (PII) or protected health information (PHI). DO NOT submit personally identifiable information (PII) or protected health information (PHI) in connection with any information or data or otherwise. You may use CEDARS, the underlying content, and any output therefrom for personal or academic research and noncommercial purposes only, including teaching and research at universities, colleges and other educational institutions. You may not use it for any other purpose. You may not publish the Content in any capacity, including in scientific or academic journals or literature, or the results of such research, without MSK\u2019s express written permission. You may not otherwise redistribute or share the Content with any third party, in part or in whole, for any purpose, without the express written permission of MSK. You may not sell, resell, rent, lease or exchange the Content or any derivative works in any form for commercial purposes, for anything of value, or for any profit whatsoever, including any sort of monetary compensation. Any use of the Content for commercial purposes, including but not restricted to, running business operations, licensing, leasing or selling the Content, distributing the Content for use with commercial products, consulting activities, design of commercial hardware or software products, or a distributing to a commercial entity participating in research projects, requires MSK\u2019s express written permission and provision of an appropriate license. Without limiting the generality of the foregoing, you may not use any part of CEDARS, the underlying Content or the output for any other purpose, including: a) use or incorporation into a commercial product or towards the performance of a commercial service; b) research use in a commercial setting; c) diagnosis, treatment or use for patient care or the provision of medical services; or d) generation of reports in a medical, laboratory, hospital or other patient care setting. You may not copy, transfer, reproduce, modify, sell, sublicense, distribute or create derivative works of CEDARS or the underlying Content for any commercial purpose without the express permission of MSK. Any attempt otherwise to copy, transfer, modify, sublicense or distribute the Content is void, and will automatically terminate your rights under these Terms of Use. The output of CEDARS and the underlying Content is not a substitute for professional medical help, judgment, or advice. Use of CEDARS does not create a physician-patient relationship or in any way make a person a patient of MSK. A physician or other qualified health provider should always be consulted for any health problem or medical condition. Neither these Terms or Use nor the availability of CEDARS should be understood to create an obligation or expectation that MSK will continue to make CEDARS available. MSK may discontinue or restrict the availability of CEDARS at any time. MSK may also modify these Terms or Use at any time. Any use of the Content is subject to MSK\u2019s intellectual property rights, including any granted, pending or filed provisional patent applications, and any other patent, copyright, trademark, trade secret or other intellectual property rights. MSK respects the intellectual property rights of others, just as it expects others to respect its intellectual property. If you believe that any content (including data or information uploaded by you) to the Content or other activity taking place on the website where it is hosted constitutes infringement of a work protected by copyright, please notify us as follows: e-mail Simon Mantha at manthas@mskcc.org Your notice must comply with the Digital Millennium Copyright Act (17 U.S.C. \u00a7512) (the \"DMCA\"). Upon receipt of a compliant notice, we will respond and proceed in accordance with the DMCA. By using CEDARS, you consent to the jurisdiction and venue of the state and federal courts located in New York City, New York, USA, for any claims related to or arising from your use of CEDARS or your violation of these Terms of Use, and agree that you will not bring any claims against MSK that relate to or arise from the foregoing except in those courts. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of these Terms of Use, they do not excuse you from the conditions of these Terms of Use. If any provision of these Terms of Use is held to be invalid or unenforceable, then such provision shall be struck and the remaining provisions shall be enforced. Headings are for reference purposes only and in no way define, limit, construe, or describe the scope or extent of such section. MSK\u2019s failure to act with respect to a breach by you or others does not waive its right to act with respect to subsequent or similar breaches. This agreement and the terms and conditions contained herein set forth the entire understanding and agreement between MSK and you with respect to the subject matter hereof and supersede any prior or contemporaneous understanding, whether written or oral. Inquiries about the Content should be directed to manthas@mskcc.org. If you are interested in using CEDARS for purposes beyond those permitted by these Terms of Use, please contact manthas@mskcc.org to inquire concerning the availability of a license.","title":"Terms of Use"},{"location":"TERMS_OF_USE/#terms-of-use-cedars-clinical-event-detection-and-recording-system","text":"PLEASE READ THIS DOCUMENT CAREFULLY BEFORE YOU ACCESS OR USE CEDARS. BY ACCESSING ANY PORTION OF CEDARS, YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS SET FORTH BELOW. IF YOU DO NOT WISH TO BE BOUND BY THESE TERMS AND CONDITIONS, PLEASE DO NOT ACCESS CEDARS. CEDARS is developed and maintained by Memorial Sloan Kettering Cancer Center (\u201cMSK,\u201d \u201cwe\u201d, or \u201cus\u201d) to assist in clinical event detection. MSK may, from time to time, update the software and other content on https://github.com/CEDARS-NLP/CEDARS (\u201cContent\u201d). MSK makes no warranties or representations, and hereby disclaims any warranties, express or implied, with respect to any of the Content, including as to the present accuracy, completeness, timeliness, adequacy, or usefulness of any of the Content. The entire risk as to the quality and performance of the Content is with you. By using this Content, you agree that MSK will not be liable for any losses or damages arising from your use of or reliance on the Content, or other websites or information to which this Content may be linked, including any general, special, incidental or consequential damages arising out of the use or inability to use the Content including, but not limited to, loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the Content to operate with any other software, programs, source code, etc. By making any use of the Content or submitting any information or data along with such to us, you authorize MSK to copy, modify, display, distribute, perform, use, publish, and otherwise exploit the same for any and all purposes, all without compensation to you, for as long as we decide (collectively, the \"Use Rights\"). In addition, you authorize MSK to grant any third party some or all of the Use Rights. By way of example, and not limitation, the Use Rights include the right for us to publish any data or information submitted in whole or in part for as long as we choose. By providing any data or information, you represent and warrant that (i) you own all rights in and to the information or data (including any related intellectual property rights) or have sufficient authority and right to provide the content and to grant the Use Rights; (ii) your submission of the information or data and grant to us of Use Rights do not violate or conflict with the rights of other persons, or breach your obligations to other persons; and (iii) the information or data does not include or contain any personally identifiable information (PII) or protected health information (PHI). DO NOT submit personally identifiable information (PII) or protected health information (PHI) in connection with any information or data or otherwise. You may use CEDARS, the underlying content, and any output therefrom for personal or academic research and noncommercial purposes only, including teaching and research at universities, colleges and other educational institutions. You may not use it for any other purpose. You may not publish the Content in any capacity, including in scientific or academic journals or literature, or the results of such research, without MSK\u2019s express written permission. You may not otherwise redistribute or share the Content with any third party, in part or in whole, for any purpose, without the express written permission of MSK. You may not sell, resell, rent, lease or exchange the Content or any derivative works in any form for commercial purposes, for anything of value, or for any profit whatsoever, including any sort of monetary compensation. Any use of the Content for commercial purposes, including but not restricted to, running business operations, licensing, leasing or selling the Content, distributing the Content for use with commercial products, consulting activities, design of commercial hardware or software products, or a distributing to a commercial entity participating in research projects, requires MSK\u2019s express written permission and provision of an appropriate license. Without limiting the generality of the foregoing, you may not use any part of CEDARS, the underlying Content or the output for any other purpose, including: a) use or incorporation into a commercial product or towards the performance of a commercial service; b) research use in a commercial setting; c) diagnosis, treatment or use for patient care or the provision of medical services; or d) generation of reports in a medical, laboratory, hospital or other patient care setting. You may not copy, transfer, reproduce, modify, sell, sublicense, distribute or create derivative works of CEDARS or the underlying Content for any commercial purpose without the express permission of MSK. Any attempt otherwise to copy, transfer, modify, sublicense or distribute the Content is void, and will automatically terminate your rights under these Terms of Use. The output of CEDARS and the underlying Content is not a substitute for professional medical help, judgment, or advice. Use of CEDARS does not create a physician-patient relationship or in any way make a person a patient of MSK. A physician or other qualified health provider should always be consulted for any health problem or medical condition. Neither these Terms or Use nor the availability of CEDARS should be understood to create an obligation or expectation that MSK will continue to make CEDARS available. MSK may discontinue or restrict the availability of CEDARS at any time. MSK may also modify these Terms or Use at any time. Any use of the Content is subject to MSK\u2019s intellectual property rights, including any granted, pending or filed provisional patent applications, and any other patent, copyright, trademark, trade secret or other intellectual property rights. MSK respects the intellectual property rights of others, just as it expects others to respect its intellectual property. If you believe that any content (including data or information uploaded by you) to the Content or other activity taking place on the website where it is hosted constitutes infringement of a work protected by copyright, please notify us as follows: e-mail Simon Mantha at manthas@mskcc.org Your notice must comply with the Digital Millennium Copyright Act (17 U.S.C. \u00a7512) (the \"DMCA\"). Upon receipt of a compliant notice, we will respond and proceed in accordance with the DMCA. By using CEDARS, you consent to the jurisdiction and venue of the state and federal courts located in New York City, New York, USA, for any claims related to or arising from your use of CEDARS or your violation of these Terms of Use, and agree that you will not bring any claims against MSK that relate to or arise from the foregoing except in those courts. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of these Terms of Use, they do not excuse you from the conditions of these Terms of Use. If any provision of these Terms of Use is held to be invalid or unenforceable, then such provision shall be struck and the remaining provisions shall be enforced. Headings are for reference purposes only and in no way define, limit, construe, or describe the scope or extent of such section. MSK\u2019s failure to act with respect to a breach by you or others does not waive its right to act with respect to subsequent or similar breaches. This agreement and the terms and conditions contained herein set forth the entire understanding and agreement between MSK and you with respect to the subject matter hereof and supersede any prior or contemporaneous understanding, whether written or oral. Inquiries about the Content should be directed to manthas@mskcc.org. If you are interested in using CEDARS for purposes beyond those permitted by these Terms of Use, please contact manthas@mskcc.org to inquire concerning the availability of a license.","title":"Terms of Use CEDARS (Clinical Event Detection And Recording System)"},{"location":"basic_concepts/","text":"Basic Concepts CEDARS uses a system where keywords are searched for using lemmas in the search query. This query must be in a regex format. After a query is entered all events that match the search query will be displayed to the user in the Adjudications page. However, unless it is otherwise specified all events that contain negations will not be shown in the Adjudications page. Lemmas A lemma is defined as the canonical, dictionary or citation form of a word. For example, the words bleeding, bled and bleed all have the lemma bleed. This allows us to search for a reference to an event regardless of tense or grammar. To learn more about lemmas you may read this article . Regex Patterns A regular expression (regex) pattern is a sequence of characters or words meant to match a pattern in text. For example, the pattern \"bleed|cut\" will search for both the words bleed and cut within a sentence. If either of them are found we can say that the pattern has been matched. To learn more you can learn more here . Negations A negation is the absence or opposite of a positive. For example, in the sentence \"He had no bleeding.\" the lemma for bleed is present, but a researcher looking for instances of bleeding will not be interested in this sentence. This is because the word \"bleeding\" has been negated and so must be excluded from the events.","title":"Basic Concepts"},{"location":"basic_concepts/#basic-concepts","text":"CEDARS uses a system where keywords are searched for using lemmas in the search query. This query must be in a regex format. After a query is entered all events that match the search query will be displayed to the user in the Adjudications page. However, unless it is otherwise specified all events that contain negations will not be shown in the Adjudications page.","title":"Basic Concepts"},{"location":"basic_concepts/#lemmas","text":"A lemma is defined as the canonical, dictionary or citation form of a word. For example, the words bleeding, bled and bleed all have the lemma bleed. This allows us to search for a reference to an event regardless of tense or grammar. To learn more about lemmas you may read this article .","title":"Lemmas"},{"location":"basic_concepts/#regex-patterns","text":"A regular expression (regex) pattern is a sequence of characters or words meant to match a pattern in text. For example, the pattern \"bleed|cut\" will search for both the words bleed and cut within a sentence. If either of them are found we can say that the pattern has been matched. To learn more you can learn more here .","title":"Regex Patterns"},{"location":"basic_concepts/#negations","text":"A negation is the absence or opposite of a positive. For example, in the sentence \"He had no bleeding.\" the lemma for bleed is present, but a researcher looking for instances of bleeding will not be interested in this sentence. This is because the word \"bleeding\" has been negated and so must be excluded from the events.","title":"Negations"},{"location":"developer_tools/","text":"Developer Tools The public CEDARS package includes the following developer tools to make the package easier to work with and use. 1. Testing CEDARS is setup with pytest to test the basic functionality of this package. The tests are stored in the \"cedars/tests\" folder and can be run with the following commands : $ cd cedars $ poetry run python -m pytest 2. Code Linting CEDARS includes flake8 as a code linting service. You can run this using the following commands : $ cd cedars $ poetry run python -m flake8 --count --exit-zero --max-complexity=20 --max-line-length=127 --statistics 3. RQ-Dashboard CEDARS uses python-rq queues to handle queue and multithreaded processes such as processing a search query or executing download jobs. Rq-dashboard is a tool that provides a GUI to view and interact with these queues easily. To access the rq-dashboard you need to login as an admin, navigate to the dropdown on the top right and select \"RQ Dashboard\".","title":"Developer Tools"},{"location":"developer_tools/#developer-tools","text":"The public CEDARS package includes the following developer tools to make the package easier to work with and use.","title":"Developer Tools"},{"location":"developer_tools/#1-testing","text":"CEDARS is setup with pytest to test the basic functionality of this package. The tests are stored in the \"cedars/tests\" folder and can be run with the following commands : $ cd cedars $ poetry run python -m pytest","title":"1. Testing"},{"location":"developer_tools/#2-code-linting","text":"CEDARS includes flake8 as a code linting service. You can run this using the following commands : $ cd cedars $ poetry run python -m flake8 --count --exit-zero --max-complexity=20 --max-line-length=127 --statistics","title":"2. Code Linting"},{"location":"developer_tools/#3-rq-dashboard","text":"CEDARS uses python-rq queues to handle queue and multithreaded processes such as processing a search query or executing download jobs. Rq-dashboard is a tool that provides a GUI to view and interact with these queues easily. To access the rq-dashboard you need to login as an admin, navigate to the dropdown on the top right and select \"RQ Dashboard\".","title":"3. RQ-Dashboard"},{"location":"download_annotations/","text":"Downloading Results Once you have reviewed the generated annotations and marked event dates, you can navigate to the dropdown on the top right. Then you can create a new download task (regular or full). A spinning animation will play while the data is being prepared. After it is done, the file will be added to the list of \"Available Files\" with a \"Download\" button. Clicking this download button will return a file with tabular data in .csv format. The table for the regular download will have the following columns: 1. patient_id (The ID of the patient for which that note was written) 2. total_notes (The total number of notes for this patient) 3. reviewed_notes (The number of notes that were reviewed for this patient) 4. total_sentences (The total number of sentences found for this patient) 5. reviewed_notes (The number of sentences that were reviewed for this patient) 6. event_date (The date at which the event took place) 7. event_information (The sentence where the event was found along with the note ID for the note that sentence belonged to) 8. first_note_date (The earliest note date for that patient) 9. last_note_date (The most recent note date for that patient) 10. comments (Any comments for that patient written by annotators) 11. reviewer (The investigator that reviewed this patient. Will be \"PINES\" if the patient has been adjudicated by a PINES model or \"CEDARS\" if that patient has no annotations.) 12. max_score_note_id (The note ID in which PINES found the highest probability of an event. Will be empty if no PINES model was used.) 13. max_score_note_id (The note date for which PINES found the highest probability of an event. Will be empty if no PINES model was used.) 14. max_score (The highest score PINES assigned to any note for this patient. Will be empty if no PINES model was used.) 15. predicted_notes (The note IDs with the predicted scores for this patient. Will be empty if no PINES model was used.) If a full download task is created an additional column will be added to the output file : - sentences (A list of the annotation IDs with their corresponding sentences for that patient.)","title":"Downloading Results"},{"location":"download_annotations/#downloading-results","text":"Once you have reviewed the generated annotations and marked event dates, you can navigate to the dropdown on the top right. Then you can create a new download task (regular or full). A spinning animation will play while the data is being prepared. After it is done, the file will be added to the list of \"Available Files\" with a \"Download\" button. Clicking this download button will return a file with tabular data in .csv format. The table for the regular download will have the following columns: 1. patient_id (The ID of the patient for which that note was written) 2. total_notes (The total number of notes for this patient) 3. reviewed_notes (The number of notes that were reviewed for this patient) 4. total_sentences (The total number of sentences found for this patient) 5. reviewed_notes (The number of sentences that were reviewed for this patient) 6. event_date (The date at which the event took place) 7. event_information (The sentence where the event was found along with the note ID for the note that sentence belonged to) 8. first_note_date (The earliest note date for that patient) 9. last_note_date (The most recent note date for that patient) 10. comments (Any comments for that patient written by annotators) 11. reviewer (The investigator that reviewed this patient. Will be \"PINES\" if the patient has been adjudicated by a PINES model or \"CEDARS\" if that patient has no annotations.) 12. max_score_note_id (The note ID in which PINES found the highest probability of an event. Will be empty if no PINES model was used.) 13. max_score_note_id (The note date for which PINES found the highest probability of an event. Will be empty if no PINES model was used.) 14. max_score (The highest score PINES assigned to any note for this patient. Will be empty if no PINES model was used.) 15. predicted_notes (The note IDs with the predicted scores for this patient. Will be empty if no PINES model was used.) If a full download task is created an additional column will be added to the output file : - sentences (A list of the annotation IDs with their corresponding sentences for that patient.)","title":"Downloading Results"},{"location":"getting_started/","text":"Getting Started Installation To install CEDARS on your computer you will need to complete the following steps: Download and install Docker Desktop on your computer. Download the CEDARS docker folder . Open the docker application on your computer. Go to the Containers tab in docker. Click the start button under Actions for the CEDARS project. Navigate to the \"http://localhost:5001\" URL in your browser. CEDARS will now be running on this webpage. First Usage The first time that a CEDARS project has been opened, you will see a page prompting you to enter an admin username and password. After this the project will load the interface as normal. Continued Usage After the installation has been complete, CEDARS will continue to run on the same URL until docker is shut down. To start the application again, follow steps 3. - 7. from the Installation section. Note that all data and progress in the project will be saved even after docker shuts down.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"To install CEDARS on your computer you will need to complete the following steps: Download and install Docker Desktop on your computer. Download the CEDARS docker folder . Open the docker application on your computer. Go to the Containers tab in docker. Click the start button under Actions for the CEDARS project. Navigate to the \"http://localhost:5001\" URL in your browser. CEDARS will now be running on this webpage.","title":"Installation"},{"location":"getting_started/#first-usage","text":"The first time that a CEDARS project has been opened, you will see a page prompting you to enter an admin username and password. After this the project will load the interface as normal.","title":"First Usage"},{"location":"getting_started/#continued-usage","text":"After the installation has been complete, CEDARS will continue to run on the same URL until docker is shut down. To start the application again, follow steps 3. - 7. from the Installation section. Note that all data and progress in the project will be saved even after docker shuts down.","title":"Continued Usage"},{"location":"query_database/","text":"Querying the Database To search for medical events using CEDARS you will need to write a regex query. For more information regarding these queries, you can refer to the Basic Concepts section of the documentation. After you enter a query, click submit and the NLP algorithm will run on the database and save instances of the event when it is found. After the database has been searched, you will be redirected to the Adjudications page where you can view the search results. Important Note Keep in mind that entering a new query will erase all records of the prior query and so you are advised to download a copy of the results of prior queries before entering a new one. Reference This file contatins an abstract class for CEDARS to interact with mongodb. add_comment ( annotation_id , comment ) Stores a new comment for a patient. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. comment ( str) ) \u2013 Text of the comment on this annotation. Returns: None Source code in cedars/app/db.py 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 def add_comment ( annotation_id , comment ): \"\"\" Stores a new comment for a patient. Args: annotation_id (str) : Unique ID for the annotation. comment (str) : Text of the comment on this annotation. Returns: None \"\"\" comment = comment . strip () if len ( comment ) == 0 : logger . info ( f \"Comment deleted on annotation # { annotation_id } .\" ) else : logger . debug ( f \"Adding comment to annotation # { annotation_id } \" ) patient_id = mongo . db [ \"ANNOTATIONS\" ] . find_one ( { \"_id\" : ObjectId ( annotation_id )})[ \"patient_id\" ] mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"comments\" : comment } }) upsert_patient_results ( patient_id ) add_task ( task ) Launch a task and add it to Mongo if it doesn't already exist. TODO: insert only one Source code in cedars/app/db.py 1610 1611 1612 1613 1614 1615 1616 def add_task ( task ): \"\"\" Launch a task and add it to Mongo if it doesn't already exist. # TODO: insert only one \"\"\" task_db = mongo . db [ \"TASK\" ] task_db . insert_one ( task ) add_user ( username , password , is_admin = False ) This function is used to add a new user to the database. All this data is kept in the USERS collection. Parameters: username ( str) ) \u2013 The name of this user. password ( str) ) \u2013 The password this user will need to login to the system. Returns: None Source code in cedars/app/db.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def add_user ( username , password , is_admin = False ): \"\"\" This function is used to add a new user to the database. All this data is kept in the USERS collection. Args: username (str) : The name of this user. password (str) : The password this user will need to login to the system. Returns: None \"\"\" info = { \"user\" : username , \"password\" : password , \"is_admin\" : is_admin , \"date_created\" : datetime . now () } mongo . db [ \"USERS\" ] . insert_one ( info ) logger . info ( f \"Added user { username } to database.\" ) check_password ( username , password ) Checks if the password matches the password of that user from the database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The password entered by the user. Returns: \u2013 (bool) : True if the password matches the password of that user from the database. Source code in cedars/app/db.py 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 def check_password ( username , password ): \"\"\" Checks if the password matches the password of that user from the database. Args: username (str) : The name of the new user password (str) : The password entered by the user. Returns: (bool) : True if the password matches the password of that user from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return \"password\" in user and check_password_hash ( user [ \"password\" ], password ) create_db_indices () Creates indices for the ANNOTATIONS and PINES cols in the db. Source code in cedars/app/db.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def create_db_indices (): ''' Creates indices for the ANNOTATIONS and PINES cols in the db. ''' logger . info ( \"All tasks completed.\" ) logger . info ( \"Creating indexes for NOTES.\" ) mongo . db [ \"NOTES\" ] . create_index ([( \"text_id\" , 1 )], unique = True ) mongo . db [ \"NOTES\" ] . create_index ([( \"patient_id\" , 1 )]) mongo . db [ \"NOTES\" ] . create_index ([( \"patient_id\" , 1 ), ( \"text_id\" , 1 )], unique = True ) logger . info ( \"Creating indexes for PATIENTS.\" ) mongo . db [ \"PATIENTS\" ] . create_index ([( \"patient_id\" , 1 )], unique = True ) logger . info ( \"Creating indexes for ANNOTATIONS.\" ) create_index ( \"ANNOTATIONS\" , [ \"patient_id\" , \"note_id\" ]) mongo . db [ \"ANNOTATIONS\" ] . create_index ([( \"patient_id\" , 1 ), ( \"isNegated\" , 1 ), ( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 ) ] ) logger . info ( \"Creating indexes for PINES.\" ) create_index ( \"PINES\" , [( \"text_id\" , { \"unique\" : True })]) create_index ( \"PINES\" , [( \"patient_id\" )]) logger . info ( \"Creating indexes for USERS.\" ) create_index ( \"USERS\" , [( \"user\" , { \"unique\" : True })]) create_index ( collection , index ) This function is used to create an index in a collection Add support for features such as unique=True etc Parameters: collection ( str) ) \u2013 The name of the collection to create the index in. index ( str|tuple) ) \u2013 The name of the index to create or a tuple with the name and options. Source code in cedars/app/db.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def create_index ( collection , index : list ): \"\"\" This function is used to create an index in a collection Add support for features such as unique=True etc Args: collection (str) : The name of the collection to create the index in. index (str|tuple) : The name of the index to create or a tuple with the name and options. \"\"\" for i in index : if isinstance ( i , tuple ): mongo . db [ collection ] . create_index ( i [ 0 ], ** i [ 1 ]) else : mongo . db [ collection ] . create_index ( i ) logger . info ( f \"Created index { i } in collection { collection } .\" ) create_info_col ( project_name , project_id , investigator_name , cedars_version ) This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_info_col ( project_name , project_id , investigator_name , cedars_version ): \"\"\" This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" collection = mongo . db [ \"INFO\" ] info = { \"creation_time\" : datetime . now (), \"project\" : project_name , \"project_id\" : project_id , \"investigator\" : investigator_name , \"CEDARS_version\" : cedars_version } collection . insert_one ( info ) logger . info ( \"Created INFO collection.\" ) create_pines_info ( pines_url , is_url_from_api ) Retrives the PINES url from the relevant source and updates the INFO col with the information. Source code in cedars/app/db.py 64 65 66 67 68 69 70 71 72 def create_pines_info ( pines_url , is_url_from_api ): \"\"\" Retrives the PINES url from the relevant source and updates the INFO col with the information. \"\"\" update_pines_api_url ( pines_url ) update_pines_api_status ( is_url_from_api ) return pines_url create_project ( project_name , investigator_name , project_id = None , cedars_version = '0.1.0' ) This function creates all the collections in the mongodb database for CEDARS. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) , default: '0.1.0' ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def create_project ( project_name , investigator_name , project_id = None , cedars_version = \"0.1.0\" ): \"\"\" This function creates all the collections in the mongodb database for CEDARS. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" create_db_indices () if mongo . db [ \"INFO\" ] . find_one () is not None : logger . info ( \"Database already created.\" ) return if project_id is None : project_id = str ( uuid4 ()) create_info_col ( project_name = project_name , project_id = project_id , investigator_name = investigator_name , cedars_version = cedars_version ) # populate_annotations() # populate_notes() populate_users () # populate_query() populate_results () logger . info ( \"Database creation successful!\" ) delete_event_annotation_id ( patient_id ) Deletes the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 def delete_event_annotation_id ( patient_id : str ): \"\"\" Deletes the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Deleting event_annotation_id on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_annotation_id\" : None }}) delete_event_date ( patient_id ) Deletes the event date for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 def delete_event_date ( patient_id : str ): \"\"\" Deletes the event date for a patient. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Deleting date on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_date\" : None }}) delete_event_annotation_id ( patient_id ) download_annotations ( filename = 'annotations.csv' , get_sentences = False ) Download annotations from the database and stream them to MinIO. Source code in cedars/app/db.py 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 def download_annotations ( filename : str = \"annotations.csv\" , get_sentences : bool = False ) -> bool : \"\"\" Download annotations from the database and stream them to MinIO. \"\"\" schema = { 'patient_id' : pl . Utf8 , 'total_notes' : pl . Int64 , 'reviewed_notes' : pl . Int64 , 'total_sentences' : pl . Int64 , 'reviewed_sentences' : pl . Int64 , 'sentences' : pl . Utf8 , 'event_date' : pl . Datetime , 'event_information' : pl . Utf8 , 'first_note_date' : pl . Datetime , 'last_note_date' : pl . Datetime , 'comments' : pl . Utf8 , 'reviewer' : pl . Utf8 , 'max_score_note_id' : pl . Utf8 , 'max_score_note_date' : pl . Datetime , 'max_score' : pl . Float64 , 'predicted_notes' : pl . Utf8 } if get_sentences is False : schema . pop ( 'sentences' ) try : # Create an in-memory buffer for the CSV data csv_buffer = StringIO () writer = pd . DataFrame ( columns = list ( schema . keys ())) writer . to_csv ( csv_buffer , index = False , header = True ) # Write data in chunks and stream to MinIO columns_to_retrive = { '_id' : False } columns_to_retrive . update ({ column : True for column in schema . keys ()}) project_results = mongo . db [ \"RESULTS\" ] . find ({}, columns_to_retrive ) for chunk in pl . DataFrame ( project_results , orient = \"row\" , schema = schema , infer_schema_length = None ) . write_csv ( include_header = False , batch_size = 1000 ): csv_buffer . write ( chunk ) # Move the cursor to the beginning of the buffer csv_buffer . seek ( 0 ) data_bytes = csv_buffer . getvalue () . encode ( 'utf-8' ) data_stream = BytesIO ( data_bytes ) # Upload to MinIO minio . put_object ( g . bucket_name , f \"annotated_files/ { filename } \" , data_stream , length = len ( data_bytes ), content_type = \"application/csv\" ) logger . info ( f \"Uploaded annotations to s3: { filename } \" ) return True except Exception as e : logger . error ( f \"Failed to upload annotations to s3: { filename } , error: { str ( e ) } \" ) return False drop_database ( name ) Clean Database Source code in cedars/app/db.py 1368 1369 1370 def drop_database ( name ): \"\"\"Clean Database\"\"\" mongo . cx . drop_database ( name ) empty_annotations () Deletes all annotations from the database Source code in cedars/app/db.py 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 def empty_annotations (): \"\"\" Deletes all annotations from the database \"\"\" logger . info ( \"Deleting all data in annotations collection.\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . delete_many ({}) # also reset the queue flask . current_app . task_queue . empty () mongo . db [ \"TASK\" ] . delete_many ({}) get_all_annotations () Returns a list of all annotations from the database. Returns: Annotations (list) : This is a list of all annotations from the database. Source code in cedars/app/db.py 930 931 932 933 934 935 936 937 938 939 940 941 def get_all_annotations (): \"\"\" Returns a list of all annotations from the database. Args: None Returns: Annotations (list) : This is a list of all annotations from the database. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find () return list ( annotations ) get_all_annotations_for_note ( note_id ) This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 536 537 538 539 540 541 542 543 544 545 546 547 def get_all_annotations_for_note ( note_id ): \"\"\" This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"setence_number\" , 1 )]) return list ( annotations ) get_all_annotations_for_patient ( patient_id ) Retrives all annotations for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. Source code in cedars/app/db.py 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def get_all_annotations_for_patient ( patient_id : str ): \"\"\" Retrives all annotations for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. \"\"\" annotations = list ( mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 )])) return annotations get_all_annotations_for_patient_paged ( patient_id , page = 1 , page_size = 1 ) Retrives all annotations for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. Source code in cedars/app/db.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 def get_all_annotations_for_patient_paged ( patient_id : str , page = 1 , page_size = 1 ): \"\"\" Retrives all annotations for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . aggregate ([ { \"$match\" : { \"patient_id\" : patient_id } }, { \"$facet\" : { \"metadata\" : [{ \"$count\" : 'total' }], \"data\" : [ { \"$match\" : { \"patient_id\" : patient_id }}, { \"$sort\" : { \"text_date\" : 1 , \"note_id\" : 1 , \"note_start_index\" : 1 }}, { \"$skip\" : ( page - 1 ) * page_size }, { \"$limit\" : page_size }] } }, { \"$project\" : { \"total\" : { \"$arrayElemAt\" : [ \"$metadata.total\" , 0 ]}, \"annotations\" : \"$data\" } } ]) result = list ( annotations ) if result : # Extract the document data = result [ 0 ] total = data . get ( \"total\" , 0 ) # Total number of annotations annotations = data . get ( \"annotations\" , []) # Annotations for the current page else : # If no results, set default values total = 0 annotations = [] # Return the total count and the current page of annotations return { \"total\" : total , \"annotations\" : annotations } get_all_annotations_for_sentence ( note_id , sentence_number ) This function is used to get all the annotations for a particular sentence in a note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 549 550 551 552 553 554 555 556 557 558 559 560 561 def get_all_annotations_for_sentence ( note_id , sentence_number ): \"\"\" This function is used to get all the annotations for a particular sentence in a note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"sentence_number\" : sentence_number , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"note_start_index\" , 1 )]) return list ( annotations ) get_all_notes ( patient_id ) Returns all notes for that patient. Source code in cedars/app/db.py 1037 1038 1039 1040 1041 1042 def get_all_notes ( patient_id : str ): \"\"\" Returns all notes for that patient. \"\"\" notes = mongo . db [ \"NOTES\" ] . find ({ \"patient_id\" : patient_id }) return list ( notes ) get_all_patient_ids () Returns all the patient IDs in this project Returns: patients (list) : List of all patients in this project Source code in cedars/app/db.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 def get_all_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patients (list) : List of all patients in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find ({}, { 'patient_id' : 1 }) return [ patient [ \"patient_id\" ] for patient in patients ] get_annotated_notes_for_patient ( patient_id ) For a given patient, list all note_ids which have matching keyword annotations Parameters: patient_id ( int) ) \u2013 The patient_id for which we want to retrieve the annotated notes Returns: list [ str ] \u2013 notes (list[str]) : List of note_ids for the patient which have matching keyword annotations Source code in cedars/app/db.py 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 def get_annotated_notes_for_patient ( patient_id : str ) -> list [ str ]: \"\"\" For a given patient, list all note_ids which have matching keyword annotations Args: patient_id (int) : The patient_id for which we want to retrieve the annotated notes Returns: notes (list[str]) : List of note_ids for the patient which have matching keyword annotations \"\"\" annotations = ( mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) . sort ([( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 )])) notes = [] for annotation in annotations : notes . append ( annotation [ \"note_id\" ]) return list ( dict . fromkeys ( notes )) get_annotation ( annotation_id ) Retrives annotation from mongodb. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def get_annotation ( annotation_id ): \"\"\" Retrives annotation from mongodb. Args: annotation_id (str) : Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) return annotation get_annotation_note ( annotation_id ) Retrives note linked to a paticular annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def get_annotation_note ( annotation_id : str ): \"\"\" Retrives note linked to a paticular annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving annotation # { annotation_id } from database.\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) if not annotation : return None note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : annotation [ \"note_id\" ]}) return note get_curr_stats () Returns basic statistics for the project Source code in cedars/app/db.py 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 def get_curr_stats (): \"\"\" Returns basic statistics for the project \"\"\" stats = {} # Aggregation pipeline to count unique patients pipeline_unique_patients = [ { \"$group\" : { \"_id\" : \"$patient_id\" }} ] unique_patients = list ( mongo . db . PATIENTS . aggregate ( pipeline_unique_patients )) stats [ \"number_of_patients\" ] = len ( unique_patients ) pipeline_annotated_patients = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] annotated_patients = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_annotated_patients )) stats [ \"number_of_annotated_patients\" ] = len ( annotated_patients ) # Aggregation pipeline to count reviewed annotations pipeline_reviewed = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] reviewed_annotations = list ( mongo . db . PATIENTS . aggregate ( pipeline_reviewed )) stats [ \"number_of_reviewed\" ] = len ( reviewed_annotations ) # pipeline for notes and reviewed by user for notes with reviewed_by field pipeline_patients = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$reviewed_by\" , \"count\" : { \"$sum\" : 1 }}} ] reviewed_notes = list ( mongo . db . PATIENTS . aggregate ( pipeline_patients )) stats [ \"user_review_stats\" ] = { doc [ \"_id\" ]: doc [ \"count\" ] for doc in reviewed_notes } # Aggregation pipeline for lemma distribution pipeline_lemma_dist = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$token\" , \"count\" : { \"$sum\" : 1 }}}, { \"$sort\" : { \"count\" : - 1 }}, { \"$limit\" : 10 }, { \"$project\" : { \"token\" : \"$_id\" , \"_id\" : 0 , \"count\" : 1 }} ] lemma_dist_results = mongo . db . ANNOTATIONS . aggregate ( pipeline_lemma_dist ) total_tokens = mongo . db . ANNOTATIONS . count_documents ({ \"isNegated\" : False }) stats [ 'lemma_dist' ] = { doc [ 'token' ]: 100 * doc [ 'count' ] / total_tokens for doc in lemma_dist_results } return stats get_curr_version () Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 961 962 963 964 965 966 967 968 969 970 971 972 973 def get_curr_version (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () return proj_info [ \"CEDARS_version\" ] get_documents_to_annotate ( patient_id = None ) Retrives all documents that have not been annotated. Returns: All matching notes from the database. Source code in cedars/app/db.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 def get_documents_to_annotate ( patient_id = None ): \"\"\" Retrives all documents that have not been annotated. Returns: All matching notes from the database. \"\"\" logger . debug ( \"Retriving all annotated documents from database.\" ) match_stage = { \"annotations\" : { \"$eq\" : []}, \"reviewed\" : { \"$ne\" : True } } if patient_id : match_stage [ \"patient_id\" ] = patient_id documents_to_annotate = mongo . db [ \"NOTES\" ] . aggregate ( [{ \"$lookup\" : { \"from\" : \"ANNOTATIONS\" , \"localField\" : \"text_id\" , \"foreignField\" : \"note_id\" , \"as\" : \"annotations\" } }, { \"$match\" : match_stage }]) return documents_to_annotate get_event_annotation_id ( patient_id ) Retrives the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 def get_event_annotation_id ( patient_id : str ): \"\"\" Retrives the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Retriving event_annotation_id for patient # { patient_id } .\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"event_annotation_id\" ] get_event_date ( patient_id ) Find the event date for a patient. Source code in cedars/app/db.py 846 847 848 849 850 851 852 853 854 855 856 857 858 def get_event_date ( patient_id : str ): \"\"\" Find the event date for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) if patient and patient [ 'event_date' ] is not None : #date_format = '%Y-%m-%d' #event_date = datetime.strptime(patient['event_date'], date_format) return patient [ 'event_date' ] return None get_event_date_sentences ( patient_id ) Find the event date from the annotations for a patient. Source code in cedars/app/db.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def get_event_date_sentences ( patient_id : str ): \"\"\" Find the event date from the annotations for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) event_date = get_event_date ( patient_id ) if event_date is None : return [] annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) . sort ( [( \"text_date\" , 1 )] ) annotations = list ( annotations ) res = [] if len ( annotations ) > 0 : res = [ f ' { annotation [ \"note_id\" ] } : { annotation [ \"sentence\" ] } ' for annotation in annotations ] return res get_first_note_date_for_patient ( patient_id ) Retrives the date of the first note for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. Source code in cedars/app/db.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 def get_first_note_date_for_patient ( patient_id : str ): \"\"\" Retrives the date of the first note for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. \"\"\" logger . debug ( f \"Retriving first note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , 1 )]) if not note : return None return note [ \"text_date\" ] get_formatted_patient_predictions ( patient_id ) Checks if the results for this patient exist in the RESULTS collection. Args patient_id (str) : ID of the patient. Returns concat_patient_predictions (str) : A string with each predicted note as well as the prediction scores. Each prediction is in the format {note_id:note_date:prediction_score} . Each prediction is seperated by a newline character. Source code in cedars/app/db.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 def get_formatted_patient_predictions ( patient_id : str ): ''' Checks if the results for this patient exist in the RESULTS collection. Args : - patient_id (str) : ID of the patient. Returns : - concat_patient_predictions (str) : A string with each predicted note as well as the prediction scores. Each prediction is in the format {note_id:note_date:prediction_score} . Each prediction is seperated by a newline character. ''' match_stage = { 'patient_id' : patient_id , \"predicted_score\" :{ '$ne' : None }} group_stage = { '_id' : None , 'note_prediction' : { '$push' : { '$concat' : [ \"$text_id\" , \":\" , { \"$dateToString\" : { \"format\" : \"%Y-%m- %d \" , \"date\" : \"$text_date\" } }, \":\" , { '$toString' : \"$predicted_score\" } ] } } } concat_stage = { 'concat_patient_predictions' : { '$reduce' : { 'input' : \"$note_prediction\" , 'initialValue' : \"\" , 'in' : { '$cond' : [ { \"$eq\" : [ \"$$value\" , \"\" ] }, \"$$this\" , { '$concat' : [ \"$$value\" , \" \\n \" , \"$$this\" ] } ] } }} } pipeline = [] pipeline . append ({ '$match' : match_stage }) pipeline . append ({ '$group' : group_stage }) pipeline . append ({ '$project' : concat_stage }) result = mongo . db [ \"PINES\" ] . aggregate ( pipeline ) result = list ( result ) if len ( result ) > 0 : return result [ 0 ][ 'concat_patient_predictions' ] return None get_info () This function returns the info collection in the mongodb database. Source code in cedars/app/db.py 524 525 526 527 528 529 530 531 532 533 def get_info (): \"\"\" This function returns the info collection in the mongodb database. \"\"\" info = mongo . db [ \"INFO\" ] . find_one () if info is not None : return info return {} get_last_note_date_for_patient ( patient_id ) Retrives the date of the last note for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. Source code in cedars/app/db.py 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def get_last_note_date_for_patient ( patient_id : str ): \"\"\" Retrives the date of the last note for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. \"\"\" logger . debug ( f \"Retriving last note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , - 1 )]) if not note : return None return note [ \"text_date\" ] get_max_prediction_score ( patient_id ) Get the max predicted note score for a patient Source code in cedars/app/db.py 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 def get_max_prediction_score ( patient_id : str ): \"\"\" Get the max predicted note score for a patient \"\"\" return mongo . db . PINES . aggregate ( [ { '$match' : { 'patient_id' : patient_id } }, { '$group' : { '_id' : '$patient_id' , 'max_score' : { '$max' : '$predicted_score' } } }, { '$lookup' : { 'from' : 'PINES' , 'let' : { 'patient_id' : '$_id' , 'max_score' : '$max_score' }, 'pipeline' : [ { '$match' : { '$expr' : { '$and' : [ { '$eq' : [ '$patient_id' , '$$patient_id' ] }, { '$eq' : [ '$predicted_score' , '$$max_score' ] } ] } } }, { '$project' : { 'text_id' : 1 , '_id' : 0 } } ], 'as' : 'max_score_texts' } }, { '$addFields' : { 'text_id' : { '$arrayElemAt' : [ '$max_score_texts.text_id' , 0 ] } } }, { '$project' : { '_id' : 1 , 'max_score' : 1 , 'text_id' : 1 } } ] ) get_note_date ( note_id ) Retrives the date of a note. Parameters: note_id ( str) ) \u2013 Unique ID for a note. Returns: note_date (datetime) : The date of the note. Source code in cedars/app/db.py 880 881 882 883 884 885 886 887 888 889 890 891 def get_note_date ( note_id ): \"\"\" Retrives the date of a note. Args: note_id (str) : Unique ID for a note. Returns: note_date (datetime) : The date of the note. \"\"\" logger . debug ( f \"Retriving date for note # { note_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : note_id }) return note [ \"text_date\" ] get_note_prediction_from_db ( note_id , pines_collection_name = 'PINES' ) Retrieve the prediction score for a given from the database Parameters: pines_collection_name ( str , default: 'PINES' ) \u2013 The name of the collection in the database note_id ( str ) \u2013 The note_id for which we want to retrieve the prediction Returns: float ( Optional [ float ] ) \u2013 The prediction score for the note Source code in cedars/app/db.py 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 def get_note_prediction_from_db ( note_id : str , pines_collection_name : str = \"PINES\" ) -> Optional [ float ]: \"\"\" Retrieve the prediction score for a given from the database Args: pines_collection_name (str): The name of the collection in the database note_id (str): The note_id for which we want to retrieve the prediction Returns: float: The prediction score for the note \"\"\" pines_collection = mongo . db [ pines_collection_name ] query = { \"text_id\" : note_id } pines_pred = pines_collection . find_one ( query ) if pines_pred : logger . debug ( f \"Found prediction in db for : { note_id } : { pines_pred . get ( 'predicted_score' ) } \" ) return round ( pines_pred . get ( \"predicted_score\" ), 2 ) logger . debug ( f \"Prediction not found in db for : { note_id } \" ) return None get_num_patient_notes ( patient_id ) Returns all notes for that patient. Source code in cedars/app/db.py 1044 1045 1046 1047 1048 def get_num_patient_notes ( patient_id : str ): \"\"\" Returns all notes for that patient. \"\"\" return mongo . db [ \"NOTES\" ] . count_documents ({ \"patient_id\" : patient_id }) get_patient () Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Returns: patient_id (int) : Unique ID for a patient. Source code in cedars/app/db.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 def get_patient (): \"\"\" Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Args: None Returns: patient_id (int) : Unique ID for a patient. \"\"\" # todo: make sure it only get patients who have annotations atleast # while adjuticating patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"reviewed\" : False , \"locked\" : False }) if patient is not None and \"patient_id\" in patient . keys (): logger . debug ( f \"Retriving patient # { patient [ 'patient_id' ] } from database.\" , ) return patient [ \"patient_id\" ] logger . info ( \"Failed to retrive any further un-reviewed patients from the database.\" ) return None get_patient_annotation_ids ( p_id , reviewed = False , key = '_id' ) Retrives all annotation IDs for annotations linked to a patient. Parameters: p_id ( str) ) \u2013 Unique ID for a patient. reviewed ( bool) , default: False ) \u2013 True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. Source code in cedars/app/db.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 def get_patient_annotation_ids ( p_id : str , reviewed = False , key = \"_id\" ): \"\"\" Retrives all annotation IDs for annotations linked to a patient. Args: p_id (str) : Unique ID for a patient. reviewed (bool) : True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. \"\"\" logger . debug ( f \"Retriving annotations for patient # { p_id } from database.\" ) query_filter = { \"patient_id\" : p_id , \"isNegated\" : False , \"reviewed\" : reviewed } annotation_ids = mongo . db [ \"ANNOTATIONS\" ] . find ( query_filter ) . sort ([ ( \"note_id\" , 1 ), ( 'text_date' , 1 ), ( \"sentence_number\" , 1 )]) res = [] if key == \"sentence\" : for _id in annotation_ids : cleaned_sentence = ' ' . join ( _id [ key ] . split ()) res . append ( f ' { _id [ \"note_id\" ] } : { str ( _id [ \"text_date\" ])[: 10 ] } : { cleaned_sentence } ' ) else : res = [ str ( _id [ key ]) for _id in annotation_ids ] return res get_patient_by_id ( patient_id ) Retrives a single patient from mongodb. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 def get_patient_by_id ( patient_id : str ): \"\"\" Retrives a single patient from mongodb. Args: patient_id (int) : Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving patient # { patient_id } from database.\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient get_patient_ids () Returns all the patient IDs in this project Returns: patient_ids (list) : List of all patient IDs in this project Source code in cedars/app/db.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 def get_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patient_ids (list) : List of all patient IDs in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find ({ \"reviewed\" : False , \"locked\" : False }) res = [ patient [ \"patient_id\" ] for patient in patients ] logger . info ( f \"Retrived { len ( res ) } patient IDs from the database.\" ) return res get_patient_lock_status ( patient_id ) Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Source code in cedars/app/db.py 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 def get_patient_lock_status ( patient_id : str ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Raises: None \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"locked\" ] get_patient_notes ( patient_id , reviewed = False ) Returns all notes for that patient. Parameters: patient_id ( str) ) \u2013 ID for the patient Returns: notes: A list of all notes for that patient Source code in cedars/app/db.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_patient_notes ( patient_id : str , reviewed = False ): \"\"\" Returns all notes for that patient. Args: patient_id (str) : ID for the patient Returns: notes: A list of all notes for that patient \"\"\" mongodb_search_query = { \"patient_id\" : patient_id , \"reviewed\" : reviewed } notes = mongo . db [ \"NOTES\" ] . find ( mongodb_search_query ) return notes get_patient_reviewer ( patient_id ) Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 def get_patient_reviewer ( patient_id : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" reviewed_by = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id })[ \"reviewed_by\" ] if reviewed_by . strip () == \"\" : return None return reviewed_by get_patients_to_annotate () Retrieves a patient that have not been reviewed Returns: patient_to_annotate: A single patient that needs to manually reviewed Source code in cedars/app/db.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 def get_patients_to_annotate (): \"\"\" Retrieves a patient that have not been reviewed Args: None Returns: patient_to_annotate: A single patient that needs to manually reviewed \"\"\" logger . debug ( \"Retriving all un-reviewed patients from database.\" ) # check is this patient has any unreviewed annotations for patient_id in get_patient_ids (): annotations = get_patient_annotation_ids ( patient_id ) if len ( annotations ) > 0 : return patient_id return None get_pines_url () Retrives PINES url from INFO col. Source code in cedars/app/db.py 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 def get_pines_url (): ''' Retrives PINES url from INFO col. ''' info_col = mongo . db [ \"INFO\" ] . find_one () if info_col : return info_col [ \"pines_url\" ] return None get_prediction ( note ) PINES predictions Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" pines_api_url = get_pines_url () url = f ' { pines_api_url } /predict' data = { 'text' : note } log_notes = None try : response = requests . post ( url , json = data , timeout = 3600 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score log_notes = re . sub ( r '\\d' , '*' , note [: 20 ]) logger . debug ( f \"Got prediction for note: { log_notes } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { log_notes } \" ) raise e get_proj_name () Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 def get_proj_name (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () if proj_info is None : return None proj_name = proj_info [ \"project\" ] return proj_name get_project_users () Returns all the usernames for approved users (including the admin) for this project Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project Source code in cedars/app/db.py 976 977 978 979 980 981 982 983 984 985 986 987 988 def get_project_users (): \"\"\" Returns all the usernames for approved users (including the admin) for this project Args: None Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project \"\"\" users = mongo . db [ \"USERS\" ] . find ({}) return [ user [ \"user\" ] for user in users ] get_search_query ( query_key = 'query' ) This function is used to get the current search query from the database. All this data is kept in the QUERY collection. Source code in cedars/app/db.py 497 498 499 500 501 502 503 504 505 506 507 def get_search_query ( query_key = \"query\" ): \"\"\" This function is used to get the current search query from the database. All this data is kept in the QUERY collection. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : return query [ query_key ] return \"\" get_search_query_details () This function is used to get the current search query details from the database. Source code in cedars/app/db.py 510 511 512 513 514 515 516 517 518 519 520 521 def get_search_query_details (): \"\"\" This function is used to get the current search query details from the database. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : query . pop ( \"_id\" ) return query return {} get_task ( task_id ) Returns the task with this ID, regardless of it's completion status. Source code in cedars/app/db.py 1636 1637 1638 1639 1640 1641 def get_task ( task_id ): \"\"\" Returns the task with this ID, regardless of it's completion status. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find_one ({ \"job_id\" : task_id }) get_task_in_progress ( task_id ) Returns the task with this ID, if it has not been completed. Source code in cedars/app/db.py 1627 1628 1629 1630 1631 1632 1633 def get_task_in_progress ( task_id ): \"\"\" Returns the task with this ID, if it has not been completed. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find_one ({ \"job_id\" : task_id , \"complete\" : False }) get_tasks_in_progress () Returns tasks that have not been completed yet. Source code in cedars/app/db.py 1619 1620 1621 1622 1623 1624 def get_tasks_in_progress (): \"\"\" Returns tasks that have not been completed yet. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find ({ \"complete\" : False }) get_total_counts ( collection_name , ** kwargs ) Returns the total number of documents in a collection. Parameters: collection_name ( str) ) \u2013 The name of the collection to search. **kwargs \u2013 Additional arguments to pass to the find Returns: count (int) : The number of documents in the collection. Source code in cedars/app/db.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 def get_total_counts ( collection_name : str , ** kwargs ) -> int : \"\"\" Returns the total number of documents in a collection. Args: collection_name (str) : The name of the collection to search. **kwargs : Additional arguments to pass to the find Returns: count (int) : The number of documents in the collection. \"\"\" return mongo . db [ collection_name ] . count_documents ({ ** kwargs }) get_user ( username ) This function is used to get a user from the database. Parameters: username ( str) ) \u2013 The name of the user to get. Returns: user (dict) : The user object from the database. Source code in cedars/app/db.py 484 485 486 487 488 489 490 491 492 493 494 def get_user ( username ): \"\"\" This function is used to get a user from the database. Args: username (str) : The name of the user to get. Returns: user (dict) : The user object from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return user insert_one_annotation ( annotation ) Adds an annotation to the database. Parameters: annotation ( dict) ) \u2013 The annotation we are inserting Returns: None Source code in cedars/app/db.py 387 388 389 390 391 392 393 394 395 396 397 398 def insert_one_annotation ( annotation ): \"\"\" Adds an annotation to the database. Args: annotation (dict) : The annotation we are inserting Returns: None \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] annotations_collection . insert_one ( annotation ) is_admin_user ( username ) check if the user is admin Source code in cedars/app/db.py 1391 1392 1393 1394 1395 1396 1397 1398 def is_admin_user ( username ): \"\"\"check if the user is admin\"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ 'user' : username }) if user is not None and user [ \"is_admin\" ]: return True return False is_pines_api_running () Returns True if a SuperBIO PINES API server is running. Source code in cedars/app/db.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 def is_pines_api_running (): ''' Returns True if a SuperBIO PINES API server is running. ''' info_col = mongo . db [ \"INFO\" ] . find_one () if info_col : return info_col [ \"is_pines_server_enabled\" ] return False mark_annotation_reviewed ( annotation_id ) Updates the annotation in the database to mark it as reviewed. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 def mark_annotation_reviewed ( annotation_id ): \"\"\" Updates the annotation in the database to mark it as reviewed. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Marking annotation # { annotation_id } as reviewed.\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"reviewed\" : True }}) mark_note_reviewed ( note_id , reviewed_by ) Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 1265 1266 1267 1268 1269 1270 1271 1272 def mark_note_reviewed ( note_id , reviewed_by : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" logger . debug ( f \"Marking note # { note_id } as reviewed.\" ) mongo . db [ \"NOTES\" ] . update_one ({ \"text_id\" : note_id }, { \"$set\" : { \"reviewed\" : True , \"reviewed_by\" : reviewed_by }}) mark_patient_reviewed ( patient_id , reviewed_by , is_reviewed = True ) Updates the patient's status to reviewed in the database. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. reviewed_by ( str) ) \u2013 The name of the user who reviewed the patient. is_reviewed ( bool) , default: True ) \u2013 True if patient's annotations have been reviewed. Returns: None Source code in cedars/app/db.py 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 def mark_patient_reviewed ( patient_id : str , reviewed_by : str , is_reviewed = True ): \"\"\" Updates the patient's status to reviewed in the database. Args: patient_id (int) : Unique ID for a patient. reviewed_by (str) : The name of the user who reviewed the patient. is_reviewed (bool) : True if patient's annotations have been reviewed. Returns: None \"\"\" logger . debug ( f \"Marking patient # { patient_id } as reviewed.\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"reviewed\" : is_reviewed , \"reviewed_by\" : reviewed_by }}) logger . info ( f \"Storing results for patient # { patient_id } \" ) upsert_patient_results ( patient_id ) patient_results_exist ( patient_id ) Checks if the results for this patient exist in the RESULTS collection. Args patient_id (str) : ID of the patient. Returns has_result (bool) : True if this patient has a stored result. Source code in cedars/app/db.py 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 def patient_results_exist ( patient_id : str ): ''' Checks if the results for this patient exist in the RESULTS collection. Args : - patient_id (str) : ID of the patient. Returns : - has_result (bool) : True if this patient has a stored result. ''' stored_results = mongo . db [ \"RESULTS\" ] . find_one ({ \"patient_id\" : patient_id }) if stored_results is None : return False return True populate_task () This database stores tasks in rq Source code in cedars/app/db.py 170 171 172 173 174 175 176 177 178 def populate_task (): \"\"\" This database stores tasks in rq \"\"\" # Pylint disabled for pointless statement. # This statement is used to create a collection. task = mongo . db [ \"TASK\" ] # task.create_index(\"job_id\", unique=True) logger . info ( \"Created %s collection.\" , task . name ) populate_users () This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. Source code in cedars/app/db.py 148 149 150 151 152 153 154 155 156 def populate_users (): \"\"\" This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. \"\"\" users = mongo . db [ \"USERS\" ] users . create_index ( \"user\" , unique = True ) logger . info ( \"Created USERS collection.\" ) predict_and_save ( text_ids = None , note_collection_name = 'NOTES' , pines_collection_name = 'PINES' , force_update = False ) Save PINES predictions Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) count = 0 for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"text_date\" : note . get ( \"text_date\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) count += 1 remove_all_locked () Sets the locked status of all patients to False. This is done when the server is shutting down. Source code in cedars/app/db.py 1328 1329 1330 1331 1332 1333 1334 1335 def remove_all_locked (): \"\"\" Sets the locked status of all patients to False. This is done when the server is shutting down. \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_many ({}, { \"$set\" : { \"locked\" : False }}) report_failure ( job ) Saves the data associated with a job that failed to complete. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. Source code in cedars/app/db.py 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 def report_failure ( job ): \"\"\" Saves the data associated with a job that failed to complete. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. \"\"\" job . meta [ 'progress' ] = 0 job . save_meta () update_db_task_progress ( job . get_id (), 0 ) report_success ( job ) Saves the data associated with a successful job after completion. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. Source code in cedars/app/db.py 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 def report_success ( job ): \"\"\" Saves the data associated with a successful job after completion. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. \"\"\" job . meta [ 'progress' ] = 100 job . save_meta () update_db_task_progress ( job . get_id (), 100 ) reset_patient_reviewed () Update all patients, notes to be un-reviewed. Source code in cedars/app/db.py 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 def reset_patient_reviewed (): \"\"\" Update all patients, notes to be un-reviewed. \"\"\" mongo . db [ \"PATIENTS\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" , \"comments\" : \"\" }}) mongo . db [ \"NOTES\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" }}) save_query ( query , exclude_negated , hide_duplicates , skip_after_event , tag_query , date_min = datetime . now (), date_max = datetime . now ()) This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Parameters: query ( str) ) \u2013 The regex query. exclude_negated ( bool) ) \u2013 True if we want to exclude negated tokens. hide_duplicates ( bool) ) \u2013 True if we want to restrict duplicate queries. skip_after_event ( bool) ) \u2013 True if sentences occurring after a recorded clinical event are to be skipped. tag_query ( dict of mapping [str ) \u2013 list]) : Key words to include or exclude in the search. date_min ( str) , default: now () ) \u2013 Smallest date for valid query. date_max ( str) , default: now () ) \u2013 Greatest date for valid query. Returns: Status (bool) : True if the query was saved, False if query same quqery already exists. Source code in cedars/app/db.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def save_query ( query , exclude_negated , hide_duplicates , # pylint: disable=R0913 skip_after_event , tag_query , date_min = datetime . now (), date_max = datetime . now ()): \"\"\" This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Args: query (str) : The regex query. exclude_negated (bool) : True if we want to exclude negated tokens. hide_duplicates (bool) : True if we want to restrict duplicate queries. skip_after_event (bool) : True if sentences occurring after a recorded clinical event are to be skipped. tag_query (dict of mapping [str : list]) : Key words to include or exclude in the search. date_min (str) : Smallest date for valid query. date_max (str) : Greatest date for valid query. Returns: Status (bool) : True if the query was saved, False if query same quqery already exists. \"\"\" info = { \"query\" : query , \"exclude_negated\" : exclude_negated , \"hide_duplicates\" : hide_duplicates , \"skip_after_event\" : skip_after_event , \"tag_query\" : tag_query , \"date_min\" : date_min , \"date_max\" : date_max } collection = mongo . db [ \"QUERY\" ] # only one query is current at a time. # TODO: make a query history and enable multiple queries. info [ \"current\" ] = True if ( query == get_search_query () and skip_after_event == get_search_query ( \"skip_after_event\" ) and tag_query . get ( 'nlp_apply' , False ) == get_search_query ( \"tag_query\" ) . get ( 'nlp_apply' , False )): logger . info ( f \"Query already saved : { query } .\" ) return False collection . update_one ({ \"current\" : True }, { \"$set\" : { \"current\" : False }}) collection . insert_one ( info ) logger . info ( f \"Saved query : { query } .\" ) return True set_patient_lock_status ( patient_id , status ) Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking status ( bool) ) \u2013 True if the patient is being locked, False otherwise. Returns: \u2013 None Source code in cedars/app/db.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 def set_patient_lock_status ( patient_id : str , status ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking status (bool) : True if the patient is being locked, False otherwise. Returns: None \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"locked\" : status }}) terminate_project () Terminate the Project Reset the database to the initial state. Source code in cedars/app/db.py 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) # Delete all mongo DB collections mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) mongo . db . drop_collection ( \"TASK\" ) mongo . db . drop_collection ( \"RESULTS\" ) project_id = os . getenv ( \"PROJECT_ID\" , None ) create_project ( project_name = fake . slug (), investigator_name = fake . name (), project_id = project_id ) update_annotation_reviewed ( note_id ) Mark all annotations for a note as reviewed. Parameters: note_id ( str) ) \u2013 The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. Source code in cedars/app/db.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def update_annotation_reviewed ( note_id : str ) -> int : \"\"\" Mark all annotations for a note as reviewed. Args: note_id (str) : The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] result = annotations_collection . update_many ({ \"note_id\" : note_id }, { \"$set\" : { \"reviewed\" : True }}) return result . modified_count update_db_task_progress ( task_id , progress ) Updates the progress of a task and checks if it has completed. This function will also automatically unlock the patient after completion. Source code in cedars/app/db.py 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 def update_db_task_progress ( task_id , progress ): \"\"\" Updates the progress of a task and checks if it has completed. This function will also automatically unlock the patient after completion. \"\"\" task_db = mongo . db [ \"TASK\" ] task = task_db . find_one ({ \"job_id\" : task_id }) completed = False if not task : # this might be the case if we have old messages # in the queue logger . error ( f \"Task { task_id } not found in database.\" ) return if progress >= 100 : completed = True task_db . update_one ({ \"job_id\" : task [ \"job_id\" ]}, { \"$set\" : { \"progress\" : progress , \"complete\" : completed }}) patient_id = ( task_id . split ( \":\" )[ 1 ]) . strip () # TODO: handle failed patients? set_patient_lock_status ( patient_id , False ) update_event_annotation_id ( patient_id , annotation_id ) Updates the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. annotation_id ( str) ) \u2013 ID of the annotation where the event date for this patient was entered. Returns: None Source code in cedars/app/db.py 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 def update_event_annotation_id ( patient_id : str , annotation_id ): \"\"\" Updates the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. annotation_id (str) : ID of the annotation where the event date for this patient was entered. Returns: None \"\"\" logger . debug ( f \"Updating event_annotation_id on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_annotation_id\" : annotation_id }}) update_event_date ( patient_id , new_date , annotation_id ) Enters a new event date for an patient. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. new_date ( str) ) \u2013 The new value to update the event date of the patient with. Must be in the format YYYY-MM-DD. annotation_id ( str) ) \u2013 ID for the annotation at which the new_date was marked. Returns: None Source code in cedars/app/db.py 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 def update_event_date ( patient_id : str , new_date , annotation_id ): \"\"\" Enters a new event date for an patient. Args: patient_id (str) : Unique ID for the patient. new_date (str) : The new value to update the event date of the patient with. Must be in the format YYYY-MM-DD. annotation_id (str) : ID for the annotation at which the new_date was marked. Returns: None \"\"\" # TODO: UTC dates logger . debug ( f \"Updating date on patient # { patient_id } to { new_date } .\" ) date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( new_date , date_format ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_date\" : datetime_obj }}) update_event_annotation_id ( patient_id , annotation_id ) update_patient_results ( update_existing_results = False ) Creates the results collection if it does not exist and inserts data for patients that do not have any. Optionally updates the data for all patients including patients which already have results stored. Args update_existing_results (bool) : True if data for patients that already have results must be updated. Returns None Source code in cedars/app/db.py 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 def update_patient_results ( update_existing_results = False ): ''' Creates the results collection if it does not exist and inserts data for patients that do not have any. Optionally updates the data for all patients including patients which already have results stored. Args : - update_existing_results (bool) : True if data for patients that already have results must be updated. Returns : - None ''' if \"RESULTS\" not in mongo . db . list_collection_names (): # Create results collection populate_results () for patient_id in get_all_patient_ids (): if update_existing_results or ( not patient_results_exist ( patient_id )): upsert_patient_results ( patient_id ) update_pines_api_status ( new_status ) Updates the is_pines_server_enabled in the INFO collection of the database to reflect the status of the PINES server. Parameters: new_status ( bool) ) \u2013 True if the PINES server is running. Returns: None Source code in cedars/app/db.py 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 def update_pines_api_status ( new_status ): \"\"\" Updates the is_pines_server_enabled in the INFO collection of the database to reflect the status of the PINES server. Args: new_status (bool) : True if the PINES server is running. Returns: None \"\"\" logger . info ( f \"Setting PINES API status to { new_status } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"is_pines_server_enabled\" : new_status }}) update_pines_api_url ( new_url ) Updates the PINES API url in the INFO collection of the database to reflect the address of the PINES server. Parameters: new_url ( str) ) \u2013 The url of the PINES server's API. Returns: None Source code in cedars/app/db.py 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 def update_pines_api_url ( new_url ): \"\"\" Updates the PINES API url in the INFO collection of the database to reflect the address of the PINES server. Args: new_url (str) : The url of the PINES server's API. Returns: None \"\"\" logger . info ( f \"Setting PINES API url to { new_url } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"pines_url\" : new_url }}) update_project_name ( new_name ) Updates the project name in the INFO collection of the database. Parameters: new_name ( str) ) \u2013 New name of the project. Returns: None Source code in cedars/app/db.py 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 def update_project_name ( new_name ): \"\"\" Updates the project name in the INFO collection of the database. Args: new_name (str) : New name of the project. Returns: None \"\"\" logger . info ( f \"Updating project name to # { new_name } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"project\" : new_name }}) upsert_patient_results ( patient_id ) Stores the results of a patient who has been reviewed. If this patient already has results stored, the code will update the results for that patient. Args patient_id (str) : ID of the patient who has been reviewed. Returns None Source code in cedars/app/db.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def upsert_patient_results ( patient_id : str ): ''' Stores the results of a patient who has been reviewed. If this patient already has results stored, the code will update the results for that patient. Args : - patient_id (str) : ID of the patient who has been reviewed. Returns : - None ''' num_reviewed_notes = mongo . db [ \"NOTES\" ] . count_documents ({ 'patient_id' : patient_id , 'reviewed' : True }) all_note_details = get_formatted_patient_predictions ( patient_id ) reviewed_sentences = get_patient_annotation_ids ( patient_id , reviewed = True , key = \"sentence\" ) unreviewed_sentences = get_patient_annotation_ids ( patient_id , reviewed = False , key = \"sentence\" ) sentences = reviewed_sentences + unreviewed_sentences event_date = get_event_date ( patient_id ) key_annotation_id = get_event_annotation_id ( patient_id ) event_information = \"\" if event_date and key_annotation_id : key_annotation = get_annotation ( key_annotation_id ) event_information = key_annotation [ \"sentence\" ] key_note_id = key_annotation [ \"note_id\" ] event_information += f \" \\n Note_id : { key_note_id } \" first_note_date = get_first_note_date_for_patient ( patient_id ) last_note_date = get_last_note_date_for_patient ( patient_id ) patient = get_patient_by_id ( patient_id ) comments = patient . get ( \"comments\" , \"\" ) reviewer = get_patient_reviewer ( patient_id ) max_score = None max_score_note_id = \"\" max_score_note_date = None try : res = list ( get_max_prediction_score ( patient_id )) if len ( res ) > 0 : res = res [ 0 ] max_score = res [ \"max_score\" ] max_score_note_id = res [ \"text_id\" ] max_score_note_date = get_note_date ( max_score_note_id ) except Exception : logger . info ( f \"PINES results not available for patient: { patient_id } \" ) patient_results = { 'patient_id' : patient_id , 'total_notes' : get_num_patient_notes ( patient_id ), 'reviewed_notes' : num_reviewed_notes , 'total_sentences' : len ( sentences ), 'reviewed_sentences' : len ( reviewed_sentences ), 'sentences' : \" \\n \" . join ( sentences ), 'event_date' : event_date , 'event_information' : event_information , 'first_note_date' : first_note_date , 'last_note_date' : last_note_date , 'comments' : comments , 'reviewer' : reviewer , 'max_score_note_id' : max_score_note_id , 'max_score_note_date' : max_score_note_date , 'max_score' : max_score , 'predicted_notes' : all_note_details } if patient_results_exist ( patient_id ): # If the patient already has some results, we will override them logger . info ( f \"Results for patient # { patient_id } already exist, updating records.\" ) patient_results . pop ( \"patient_id\" ) mongo . db [ \"RESULTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : patient_results }) else : logger . info ( f \"Inserting results for patient # { patient_id } into the database.\" ) mongo . db [ \"RESULTS\" ] . insert_one ( patient_results )","title":"Querying the Database"},{"location":"query_database/#querying-the-database","text":"To search for medical events using CEDARS you will need to write a regex query. For more information regarding these queries, you can refer to the Basic Concepts section of the documentation. After you enter a query, click submit and the NLP algorithm will run on the database and save instances of the event when it is found. After the database has been searched, you will be redirected to the Adjudications page where you can view the search results.","title":"Querying the Database"},{"location":"query_database/#important-note","text":"Keep in mind that entering a new query will erase all records of the prior query and so you are advised to download a copy of the results of prior queries before entering a new one.","title":"Important Note"},{"location":"query_database/#reference","text":"This file contatins an abstract class for CEDARS to interact with mongodb.","title":"Reference"},{"location":"query_database/#cedars.app.ops.db.add_comment","text":"Stores a new comment for a patient. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. comment ( str) ) \u2013 Text of the comment on this annotation. Returns: None Source code in cedars/app/db.py 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 def add_comment ( annotation_id , comment ): \"\"\" Stores a new comment for a patient. Args: annotation_id (str) : Unique ID for the annotation. comment (str) : Text of the comment on this annotation. Returns: None \"\"\" comment = comment . strip () if len ( comment ) == 0 : logger . info ( f \"Comment deleted on annotation # { annotation_id } .\" ) else : logger . debug ( f \"Adding comment to annotation # { annotation_id } \" ) patient_id = mongo . db [ \"ANNOTATIONS\" ] . find_one ( { \"_id\" : ObjectId ( annotation_id )})[ \"patient_id\" ] mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"comments\" : comment } }) upsert_patient_results ( patient_id )","title":"add_comment"},{"location":"query_database/#cedars.app.ops.db.add_task","text":"Launch a task and add it to Mongo if it doesn't already exist.","title":"add_task"},{"location":"query_database/#cedars.app.ops.db.add_task--todo-insert-only-one","text":"Source code in cedars/app/db.py 1610 1611 1612 1613 1614 1615 1616 def add_task ( task ): \"\"\" Launch a task and add it to Mongo if it doesn't already exist. # TODO: insert only one \"\"\" task_db = mongo . db [ \"TASK\" ] task_db . insert_one ( task )","title":"TODO: insert only one"},{"location":"query_database/#cedars.app.ops.db.add_user","text":"This function is used to add a new user to the database. All this data is kept in the USERS collection. Parameters: username ( str) ) \u2013 The name of this user. password ( str) ) \u2013 The password this user will need to login to the system. Returns: None Source code in cedars/app/db.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def add_user ( username , password , is_admin = False ): \"\"\" This function is used to add a new user to the database. All this data is kept in the USERS collection. Args: username (str) : The name of this user. password (str) : The password this user will need to login to the system. Returns: None \"\"\" info = { \"user\" : username , \"password\" : password , \"is_admin\" : is_admin , \"date_created\" : datetime . now () } mongo . db [ \"USERS\" ] . insert_one ( info ) logger . info ( f \"Added user { username } to database.\" )","title":"add_user"},{"location":"query_database/#cedars.app.ops.db.check_password","text":"Checks if the password matches the password of that user from the database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The password entered by the user. Returns: \u2013 (bool) : True if the password matches the password of that user from the database. Source code in cedars/app/db.py 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 def check_password ( username , password ): \"\"\" Checks if the password matches the password of that user from the database. Args: username (str) : The name of the new user password (str) : The password entered by the user. Returns: (bool) : True if the password matches the password of that user from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return \"password\" in user and check_password_hash ( user [ \"password\" ], password )","title":"check_password"},{"location":"query_database/#cedars.app.ops.db.create_db_indices","text":"Creates indices for the ANNOTATIONS and PINES cols in the db. Source code in cedars/app/db.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def create_db_indices (): ''' Creates indices for the ANNOTATIONS and PINES cols in the db. ''' logger . info ( \"All tasks completed.\" ) logger . info ( \"Creating indexes for NOTES.\" ) mongo . db [ \"NOTES\" ] . create_index ([( \"text_id\" , 1 )], unique = True ) mongo . db [ \"NOTES\" ] . create_index ([( \"patient_id\" , 1 )]) mongo . db [ \"NOTES\" ] . create_index ([( \"patient_id\" , 1 ), ( \"text_id\" , 1 )], unique = True ) logger . info ( \"Creating indexes for PATIENTS.\" ) mongo . db [ \"PATIENTS\" ] . create_index ([( \"patient_id\" , 1 )], unique = True ) logger . info ( \"Creating indexes for ANNOTATIONS.\" ) create_index ( \"ANNOTATIONS\" , [ \"patient_id\" , \"note_id\" ]) mongo . db [ \"ANNOTATIONS\" ] . create_index ([( \"patient_id\" , 1 ), ( \"isNegated\" , 1 ), ( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 ) ] ) logger . info ( \"Creating indexes for PINES.\" ) create_index ( \"PINES\" , [( \"text_id\" , { \"unique\" : True })]) create_index ( \"PINES\" , [( \"patient_id\" )]) logger . info ( \"Creating indexes for USERS.\" ) create_index ( \"USERS\" , [( \"user\" , { \"unique\" : True })])","title":"create_db_indices"},{"location":"query_database/#cedars.app.ops.db.create_index","text":"This function is used to create an index in a collection Add support for features such as unique=True etc Parameters: collection ( str) ) \u2013 The name of the collection to create the index in. index ( str|tuple) ) \u2013 The name of the index to create or a tuple with the name and options. Source code in cedars/app/db.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def create_index ( collection , index : list ): \"\"\" This function is used to create an index in a collection Add support for features such as unique=True etc Args: collection (str) : The name of the collection to create the index in. index (str|tuple) : The name of the index to create or a tuple with the name and options. \"\"\" for i in index : if isinstance ( i , tuple ): mongo . db [ collection ] . create_index ( i [ 0 ], ** i [ 1 ]) else : mongo . db [ collection ] . create_index ( i ) logger . info ( f \"Created index { i } in collection { collection } .\" )","title":"create_index"},{"location":"query_database/#cedars.app.ops.db.create_info_col","text":"This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def create_info_col ( project_name , project_id , investigator_name , cedars_version ): \"\"\" This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" collection = mongo . db [ \"INFO\" ] info = { \"creation_time\" : datetime . now (), \"project\" : project_name , \"project_id\" : project_id , \"investigator\" : investigator_name , \"CEDARS_version\" : cedars_version } collection . insert_one ( info ) logger . info ( \"Created INFO collection.\" )","title":"create_info_col"},{"location":"query_database/#cedars.app.ops.db.create_pines_info","text":"Retrives the PINES url from the relevant source and updates the INFO col with the information. Source code in cedars/app/db.py 64 65 66 67 68 69 70 71 72 def create_pines_info ( pines_url , is_url_from_api ): \"\"\" Retrives the PINES url from the relevant source and updates the INFO col with the information. \"\"\" update_pines_api_url ( pines_url ) update_pines_api_status ( is_url_from_api ) return pines_url","title":"create_pines_info"},{"location":"query_database/#cedars.app.ops.db.create_project","text":"This function creates all the collections in the mongodb database for CEDARS. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) , default: '0.1.0' ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def create_project ( project_name , investigator_name , project_id = None , cedars_version = \"0.1.0\" ): \"\"\" This function creates all the collections in the mongodb database for CEDARS. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" create_db_indices () if mongo . db [ \"INFO\" ] . find_one () is not None : logger . info ( \"Database already created.\" ) return if project_id is None : project_id = str ( uuid4 ()) create_info_col ( project_name = project_name , project_id = project_id , investigator_name = investigator_name , cedars_version = cedars_version ) # populate_annotations() # populate_notes() populate_users () # populate_query() populate_results () logger . info ( \"Database creation successful!\" )","title":"create_project"},{"location":"query_database/#cedars.app.ops.db.delete_event_annotation_id","text":"Deletes the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 def delete_event_annotation_id ( patient_id : str ): \"\"\" Deletes the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Deleting event_annotation_id on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_annotation_id\" : None }})","title":"delete_event_annotation_id"},{"location":"query_database/#cedars.app.ops.db.delete_event_date","text":"Deletes the event date for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 def delete_event_date ( patient_id : str ): \"\"\" Deletes the event date for a patient. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Deleting date on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_date\" : None }}) delete_event_annotation_id ( patient_id )","title":"delete_event_date"},{"location":"query_database/#cedars.app.ops.db.download_annotations","text":"Download annotations from the database and stream them to MinIO. Source code in cedars/app/db.py 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 def download_annotations ( filename : str = \"annotations.csv\" , get_sentences : bool = False ) -> bool : \"\"\" Download annotations from the database and stream them to MinIO. \"\"\" schema = { 'patient_id' : pl . Utf8 , 'total_notes' : pl . Int64 , 'reviewed_notes' : pl . Int64 , 'total_sentences' : pl . Int64 , 'reviewed_sentences' : pl . Int64 , 'sentences' : pl . Utf8 , 'event_date' : pl . Datetime , 'event_information' : pl . Utf8 , 'first_note_date' : pl . Datetime , 'last_note_date' : pl . Datetime , 'comments' : pl . Utf8 , 'reviewer' : pl . Utf8 , 'max_score_note_id' : pl . Utf8 , 'max_score_note_date' : pl . Datetime , 'max_score' : pl . Float64 , 'predicted_notes' : pl . Utf8 } if get_sentences is False : schema . pop ( 'sentences' ) try : # Create an in-memory buffer for the CSV data csv_buffer = StringIO () writer = pd . DataFrame ( columns = list ( schema . keys ())) writer . to_csv ( csv_buffer , index = False , header = True ) # Write data in chunks and stream to MinIO columns_to_retrive = { '_id' : False } columns_to_retrive . update ({ column : True for column in schema . keys ()}) project_results = mongo . db [ \"RESULTS\" ] . find ({}, columns_to_retrive ) for chunk in pl . DataFrame ( project_results , orient = \"row\" , schema = schema , infer_schema_length = None ) . write_csv ( include_header = False , batch_size = 1000 ): csv_buffer . write ( chunk ) # Move the cursor to the beginning of the buffer csv_buffer . seek ( 0 ) data_bytes = csv_buffer . getvalue () . encode ( 'utf-8' ) data_stream = BytesIO ( data_bytes ) # Upload to MinIO minio . put_object ( g . bucket_name , f \"annotated_files/ { filename } \" , data_stream , length = len ( data_bytes ), content_type = \"application/csv\" ) logger . info ( f \"Uploaded annotations to s3: { filename } \" ) return True except Exception as e : logger . error ( f \"Failed to upload annotations to s3: { filename } , error: { str ( e ) } \" ) return False","title":"download_annotations"},{"location":"query_database/#cedars.app.ops.db.drop_database","text":"Clean Database Source code in cedars/app/db.py 1368 1369 1370 def drop_database ( name ): \"\"\"Clean Database\"\"\" mongo . cx . drop_database ( name )","title":"drop_database"},{"location":"query_database/#cedars.app.ops.db.empty_annotations","text":"Deletes all annotations from the database Source code in cedars/app/db.py 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 def empty_annotations (): \"\"\" Deletes all annotations from the database \"\"\" logger . info ( \"Deleting all data in annotations collection.\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . delete_many ({}) # also reset the queue flask . current_app . task_queue . empty () mongo . db [ \"TASK\" ] . delete_many ({})","title":"empty_annotations"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations","text":"Returns a list of all annotations from the database. Returns: Annotations (list) : This is a list of all annotations from the database. Source code in cedars/app/db.py 930 931 932 933 934 935 936 937 938 939 940 941 def get_all_annotations (): \"\"\" Returns a list of all annotations from the database. Args: None Returns: Annotations (list) : This is a list of all annotations from the database. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find () return list ( annotations )","title":"get_all_annotations"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations_for_note","text":"This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 536 537 538 539 540 541 542 543 544 545 546 547 def get_all_annotations_for_note ( note_id ): \"\"\" This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"setence_number\" , 1 )]) return list ( annotations )","title":"get_all_annotations_for_note"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations_for_patient","text":"Retrives all annotations for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. Source code in cedars/app/db.py 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def get_all_annotations_for_patient ( patient_id : str ): \"\"\" Retrives all annotations for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. \"\"\" annotations = list ( mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 )])) return annotations","title":"get_all_annotations_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations_for_patient_paged","text":"Retrives all annotations for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. Source code in cedars/app/db.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 def get_all_annotations_for_patient_paged ( patient_id : str , page = 1 , page_size = 1 ): \"\"\" Retrives all annotations for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: annotations (list) : A list of all annotations for that patient. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . aggregate ([ { \"$match\" : { \"patient_id\" : patient_id } }, { \"$facet\" : { \"metadata\" : [{ \"$count\" : 'total' }], \"data\" : [ { \"$match\" : { \"patient_id\" : patient_id }}, { \"$sort\" : { \"text_date\" : 1 , \"note_id\" : 1 , \"note_start_index\" : 1 }}, { \"$skip\" : ( page - 1 ) * page_size }, { \"$limit\" : page_size }] } }, { \"$project\" : { \"total\" : { \"$arrayElemAt\" : [ \"$metadata.total\" , 0 ]}, \"annotations\" : \"$data\" } } ]) result = list ( annotations ) if result : # Extract the document data = result [ 0 ] total = data . get ( \"total\" , 0 ) # Total number of annotations annotations = data . get ( \"annotations\" , []) # Annotations for the current page else : # If no results, set default values total = 0 annotations = [] # Return the total count and the current page of annotations return { \"total\" : total , \"annotations\" : annotations }","title":"get_all_annotations_for_patient_paged"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations_for_sentence","text":"This function is used to get all the annotations for a particular sentence in a note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 549 550 551 552 553 554 555 556 557 558 559 560 561 def get_all_annotations_for_sentence ( note_id , sentence_number ): \"\"\" This function is used to get all the annotations for a particular sentence in a note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"sentence_number\" : sentence_number , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ), ( \"note_start_index\" , 1 )]) return list ( annotations )","title":"get_all_annotations_for_sentence"},{"location":"query_database/#cedars.app.ops.db.get_all_notes","text":"Returns all notes for that patient. Source code in cedars/app/db.py 1037 1038 1039 1040 1041 1042 def get_all_notes ( patient_id : str ): \"\"\" Returns all notes for that patient. \"\"\" notes = mongo . db [ \"NOTES\" ] . find ({ \"patient_id\" : patient_id }) return list ( notes )","title":"get_all_notes"},{"location":"query_database/#cedars.app.ops.db.get_all_patient_ids","text":"Returns all the patient IDs in this project Returns: patients (list) : List of all patients in this project Source code in cedars/app/db.py 991 992 993 994 995 996 997 998 999 1000 1001 1002 def get_all_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patients (list) : List of all patients in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find ({}, { 'patient_id' : 1 }) return [ patient [ \"patient_id\" ] for patient in patients ]","title":"get_all_patient_ids"},{"location":"query_database/#cedars.app.ops.db.get_annotated_notes_for_patient","text":"For a given patient, list all note_ids which have matching keyword annotations Parameters: patient_id ( int) ) \u2013 The patient_id for which we want to retrieve the annotated notes Returns: list [ str ] \u2013 notes (list[str]) : List of note_ids for the patient which have matching keyword annotations Source code in cedars/app/db.py 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 def get_annotated_notes_for_patient ( patient_id : str ) -> list [ str ]: \"\"\" For a given patient, list all note_ids which have matching keyword annotations Args: patient_id (int) : The patient_id for which we want to retrieve the annotated notes Returns: notes (list[str]) : List of note_ids for the patient which have matching keyword annotations \"\"\" annotations = ( mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) . sort ([( \"text_date\" , 1 ), ( \"note_id\" , 1 ), ( \"note_start_index\" , 1 )])) notes = [] for annotation in annotations : notes . append ( annotation [ \"note_id\" ]) return list ( dict . fromkeys ( notes ))","title":"get_annotated_notes_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_annotation","text":"Retrives annotation from mongodb. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def get_annotation ( annotation_id ): \"\"\" Retrives annotation from mongodb. Args: annotation_id (str) : Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) return annotation","title":"get_annotation"},{"location":"query_database/#cedars.app.ops.db.get_annotation_note","text":"Retrives note linked to a paticular annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def get_annotation_note ( annotation_id : str ): \"\"\" Retrives note linked to a paticular annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving annotation # { annotation_id } from database.\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) if not annotation : return None note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : annotation [ \"note_id\" ]}) return note","title":"get_annotation_note"},{"location":"query_database/#cedars.app.ops.db.get_curr_stats","text":"Returns basic statistics for the project Source code in cedars/app/db.py 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 def get_curr_stats (): \"\"\" Returns basic statistics for the project \"\"\" stats = {} # Aggregation pipeline to count unique patients pipeline_unique_patients = [ { \"$group\" : { \"_id\" : \"$patient_id\" }} ] unique_patients = list ( mongo . db . PATIENTS . aggregate ( pipeline_unique_patients )) stats [ \"number_of_patients\" ] = len ( unique_patients ) pipeline_annotated_patients = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] annotated_patients = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_annotated_patients )) stats [ \"number_of_annotated_patients\" ] = len ( annotated_patients ) # Aggregation pipeline to count reviewed annotations pipeline_reviewed = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] reviewed_annotations = list ( mongo . db . PATIENTS . aggregate ( pipeline_reviewed )) stats [ \"number_of_reviewed\" ] = len ( reviewed_annotations ) # pipeline for notes and reviewed by user for notes with reviewed_by field pipeline_patients = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$reviewed_by\" , \"count\" : { \"$sum\" : 1 }}} ] reviewed_notes = list ( mongo . db . PATIENTS . aggregate ( pipeline_patients )) stats [ \"user_review_stats\" ] = { doc [ \"_id\" ]: doc [ \"count\" ] for doc in reviewed_notes } # Aggregation pipeline for lemma distribution pipeline_lemma_dist = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$token\" , \"count\" : { \"$sum\" : 1 }}}, { \"$sort\" : { \"count\" : - 1 }}, { \"$limit\" : 10 }, { \"$project\" : { \"token\" : \"$_id\" , \"_id\" : 0 , \"count\" : 1 }} ] lemma_dist_results = mongo . db . ANNOTATIONS . aggregate ( pipeline_lemma_dist ) total_tokens = mongo . db . ANNOTATIONS . count_documents ({ \"isNegated\" : False }) stats [ 'lemma_dist' ] = { doc [ 'token' ]: 100 * doc [ 'count' ] / total_tokens for doc in lemma_dist_results } return stats","title":"get_curr_stats"},{"location":"query_database/#cedars.app.ops.db.get_curr_version","text":"Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 961 962 963 964 965 966 967 968 969 970 971 972 973 def get_curr_version (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () return proj_info [ \"CEDARS_version\" ]","title":"get_curr_version"},{"location":"query_database/#cedars.app.ops.db.get_documents_to_annotate","text":"Retrives all documents that have not been annotated. Returns: All matching notes from the database. Source code in cedars/app/db.py 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 def get_documents_to_annotate ( patient_id = None ): \"\"\" Retrives all documents that have not been annotated. Returns: All matching notes from the database. \"\"\" logger . debug ( \"Retriving all annotated documents from database.\" ) match_stage = { \"annotations\" : { \"$eq\" : []}, \"reviewed\" : { \"$ne\" : True } } if patient_id : match_stage [ \"patient_id\" ] = patient_id documents_to_annotate = mongo . db [ \"NOTES\" ] . aggregate ( [{ \"$lookup\" : { \"from\" : \"ANNOTATIONS\" , \"localField\" : \"text_id\" , \"foreignField\" : \"note_id\" , \"as\" : \"annotations\" } }, { \"$match\" : match_stage }]) return documents_to_annotate","title":"get_documents_to_annotate"},{"location":"query_database/#cedars.app.ops.db.get_event_annotation_id","text":"Retrives the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. Returns: None Source code in cedars/app/db.py 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 def get_event_annotation_id ( patient_id : str ): \"\"\" Retrives the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. Returns: None \"\"\" logger . debug ( f \"Retriving event_annotation_id for patient # { patient_id } .\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"event_annotation_id\" ]","title":"get_event_annotation_id"},{"location":"query_database/#cedars.app.ops.db.get_event_date","text":"Find the event date for a patient. Source code in cedars/app/db.py 846 847 848 849 850 851 852 853 854 855 856 857 858 def get_event_date ( patient_id : str ): \"\"\" Find the event date for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) if patient and patient [ 'event_date' ] is not None : #date_format = '%Y-%m-%d' #event_date = datetime.strptime(patient['event_date'], date_format) return patient [ 'event_date' ] return None","title":"get_event_date"},{"location":"query_database/#cedars.app.ops.db.get_event_date_sentences","text":"Find the event date from the annotations for a patient. Source code in cedars/app/db.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def get_event_date_sentences ( patient_id : str ): \"\"\" Find the event date from the annotations for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) event_date = get_event_date ( patient_id ) if event_date is None : return [] annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) . sort ( [( \"text_date\" , 1 )] ) annotations = list ( annotations ) res = [] if len ( annotations ) > 0 : res = [ f ' { annotation [ \"note_id\" ] } : { annotation [ \"sentence\" ] } ' for annotation in annotations ] return res","title":"get_event_date_sentences"},{"location":"query_database/#cedars.app.ops.db.get_first_note_date_for_patient","text":"Retrives the date of the first note for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. Source code in cedars/app/db.py 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 def get_first_note_date_for_patient ( patient_id : str ): \"\"\" Retrives the date of the first note for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. \"\"\" logger . debug ( f \"Retriving first note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , 1 )]) if not note : return None return note [ \"text_date\" ]","title":"get_first_note_date_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_formatted_patient_predictions","text":"Checks if the results for this patient exist in the RESULTS collection. Args patient_id (str) : ID of the patient. Returns concat_patient_predictions (str) : A string with each predicted note as well as the prediction scores. Each prediction is in the format {note_id:note_date:prediction_score} . Each prediction is seperated by a newline character. Source code in cedars/app/db.py 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 def get_formatted_patient_predictions ( patient_id : str ): ''' Checks if the results for this patient exist in the RESULTS collection. Args : - patient_id (str) : ID of the patient. Returns : - concat_patient_predictions (str) : A string with each predicted note as well as the prediction scores. Each prediction is in the format {note_id:note_date:prediction_score} . Each prediction is seperated by a newline character. ''' match_stage = { 'patient_id' : patient_id , \"predicted_score\" :{ '$ne' : None }} group_stage = { '_id' : None , 'note_prediction' : { '$push' : { '$concat' : [ \"$text_id\" , \":\" , { \"$dateToString\" : { \"format\" : \"%Y-%m- %d \" , \"date\" : \"$text_date\" } }, \":\" , { '$toString' : \"$predicted_score\" } ] } } } concat_stage = { 'concat_patient_predictions' : { '$reduce' : { 'input' : \"$note_prediction\" , 'initialValue' : \"\" , 'in' : { '$cond' : [ { \"$eq\" : [ \"$$value\" , \"\" ] }, \"$$this\" , { '$concat' : [ \"$$value\" , \" \\n \" , \"$$this\" ] } ] } }} } pipeline = [] pipeline . append ({ '$match' : match_stage }) pipeline . append ({ '$group' : group_stage }) pipeline . append ({ '$project' : concat_stage }) result = mongo . db [ \"PINES\" ] . aggregate ( pipeline ) result = list ( result ) if len ( result ) > 0 : return result [ 0 ][ 'concat_patient_predictions' ] return None","title":"get_formatted_patient_predictions"},{"location":"query_database/#cedars.app.ops.db.get_info","text":"This function returns the info collection in the mongodb database. Source code in cedars/app/db.py 524 525 526 527 528 529 530 531 532 533 def get_info (): \"\"\" This function returns the info collection in the mongodb database. \"\"\" info = mongo . db [ \"INFO\" ] . find_one () if info is not None : return info return {}","title":"get_info"},{"location":"query_database/#cedars.app.ops.db.get_last_note_date_for_patient","text":"Retrives the date of the last note for a patient. Parameters: patient_id ( str) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. Source code in cedars/app/db.py 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def get_last_note_date_for_patient ( patient_id : str ): \"\"\" Retrives the date of the last note for a patient. Args: patient_id (str) : Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. \"\"\" logger . debug ( f \"Retriving last note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , - 1 )]) if not note : return None return note [ \"text_date\" ]","title":"get_last_note_date_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_max_prediction_score","text":"Get the max predicted note score for a patient Source code in cedars/app/db.py 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 def get_max_prediction_score ( patient_id : str ): \"\"\" Get the max predicted note score for a patient \"\"\" return mongo . db . PINES . aggregate ( [ { '$match' : { 'patient_id' : patient_id } }, { '$group' : { '_id' : '$patient_id' , 'max_score' : { '$max' : '$predicted_score' } } }, { '$lookup' : { 'from' : 'PINES' , 'let' : { 'patient_id' : '$_id' , 'max_score' : '$max_score' }, 'pipeline' : [ { '$match' : { '$expr' : { '$and' : [ { '$eq' : [ '$patient_id' , '$$patient_id' ] }, { '$eq' : [ '$predicted_score' , '$$max_score' ] } ] } } }, { '$project' : { 'text_id' : 1 , '_id' : 0 } } ], 'as' : 'max_score_texts' } }, { '$addFields' : { 'text_id' : { '$arrayElemAt' : [ '$max_score_texts.text_id' , 0 ] } } }, { '$project' : { '_id' : 1 , 'max_score' : 1 , 'text_id' : 1 } } ] )","title":"get_max_prediction_score"},{"location":"query_database/#cedars.app.ops.db.get_note_date","text":"Retrives the date of a note. Parameters: note_id ( str) ) \u2013 Unique ID for a note. Returns: note_date (datetime) : The date of the note. Source code in cedars/app/db.py 880 881 882 883 884 885 886 887 888 889 890 891 def get_note_date ( note_id ): \"\"\" Retrives the date of a note. Args: note_id (str) : Unique ID for a note. Returns: note_date (datetime) : The date of the note. \"\"\" logger . debug ( f \"Retriving date for note # { note_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : note_id }) return note [ \"text_date\" ]","title":"get_note_date"},{"location":"query_database/#cedars.app.ops.db.get_note_prediction_from_db","text":"Retrieve the prediction score for a given from the database Parameters: pines_collection_name ( str , default: 'PINES' ) \u2013 The name of the collection in the database note_id ( str ) \u2013 The note_id for which we want to retrieve the prediction Returns: float ( Optional [ float ] ) \u2013 The prediction score for the note Source code in cedars/app/db.py 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 def get_note_prediction_from_db ( note_id : str , pines_collection_name : str = \"PINES\" ) -> Optional [ float ]: \"\"\" Retrieve the prediction score for a given from the database Args: pines_collection_name (str): The name of the collection in the database note_id (str): The note_id for which we want to retrieve the prediction Returns: float: The prediction score for the note \"\"\" pines_collection = mongo . db [ pines_collection_name ] query = { \"text_id\" : note_id } pines_pred = pines_collection . find_one ( query ) if pines_pred : logger . debug ( f \"Found prediction in db for : { note_id } : { pines_pred . get ( 'predicted_score' ) } \" ) return round ( pines_pred . get ( \"predicted_score\" ), 2 ) logger . debug ( f \"Prediction not found in db for : { note_id } \" ) return None","title":"get_note_prediction_from_db"},{"location":"query_database/#cedars.app.ops.db.get_num_patient_notes","text":"Returns all notes for that patient. Source code in cedars/app/db.py 1044 1045 1046 1047 1048 def get_num_patient_notes ( patient_id : str ): \"\"\" Returns all notes for that patient. \"\"\" return mongo . db [ \"NOTES\" ] . count_documents ({ \"patient_id\" : patient_id })","title":"get_num_patient_notes"},{"location":"query_database/#cedars.app.ops.db.get_patient","text":"Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Returns: patient_id (int) : Unique ID for a patient. Source code in cedars/app/db.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 def get_patient (): \"\"\" Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Args: None Returns: patient_id (int) : Unique ID for a patient. \"\"\" # todo: make sure it only get patients who have annotations atleast # while adjuticating patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"reviewed\" : False , \"locked\" : False }) if patient is not None and \"patient_id\" in patient . keys (): logger . debug ( f \"Retriving patient # { patient [ 'patient_id' ] } from database.\" , ) return patient [ \"patient_id\" ] logger . info ( \"Failed to retrive any further un-reviewed patients from the database.\" ) return None","title":"get_patient"},{"location":"query_database/#cedars.app.ops.db.get_patient_annotation_ids","text":"Retrives all annotation IDs for annotations linked to a patient. Parameters: p_id ( str) ) \u2013 Unique ID for a patient. reviewed ( bool) , default: False ) \u2013 True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. Source code in cedars/app/db.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 def get_patient_annotation_ids ( p_id : str , reviewed = False , key = \"_id\" ): \"\"\" Retrives all annotation IDs for annotations linked to a patient. Args: p_id (str) : Unique ID for a patient. reviewed (bool) : True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. \"\"\" logger . debug ( f \"Retriving annotations for patient # { p_id } from database.\" ) query_filter = { \"patient_id\" : p_id , \"isNegated\" : False , \"reviewed\" : reviewed } annotation_ids = mongo . db [ \"ANNOTATIONS\" ] . find ( query_filter ) . sort ([ ( \"note_id\" , 1 ), ( 'text_date' , 1 ), ( \"sentence_number\" , 1 )]) res = [] if key == \"sentence\" : for _id in annotation_ids : cleaned_sentence = ' ' . join ( _id [ key ] . split ()) res . append ( f ' { _id [ \"note_id\" ] } : { str ( _id [ \"text_date\" ])[: 10 ] } : { cleaned_sentence } ' ) else : res = [ str ( _id [ key ]) for _id in annotation_ids ] return res","title":"get_patient_annotation_ids"},{"location":"query_database/#cedars.app.ops.db.get_patient_by_id","text":"Retrives a single patient from mongodb. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 def get_patient_by_id ( patient_id : str ): \"\"\" Retrives a single patient from mongodb. Args: patient_id (int) : Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving patient # { patient_id } from database.\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient","title":"get_patient_by_id"},{"location":"query_database/#cedars.app.ops.db.get_patient_ids","text":"Returns all the patient IDs in this project Returns: patient_ids (list) : List of all patient IDs in this project Source code in cedars/app/db.py 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 def get_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patient_ids (list) : List of all patient IDs in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find ({ \"reviewed\" : False , \"locked\" : False }) res = [ patient [ \"patient_id\" ] for patient in patients ] logger . info ( f \"Retrived { len ( res ) } patient IDs from the database.\" ) return res","title":"get_patient_ids"},{"location":"query_database/#cedars.app.ops.db.get_patient_lock_status","text":"Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Source code in cedars/app/db.py 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 def get_patient_lock_status ( patient_id : str ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Raises: None \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"locked\" ]","title":"get_patient_lock_status"},{"location":"query_database/#cedars.app.ops.db.get_patient_notes","text":"Returns all notes for that patient. Parameters: patient_id ( str) ) \u2013 ID for the patient Returns: notes: A list of all notes for that patient Source code in cedars/app/db.py 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_patient_notes ( patient_id : str , reviewed = False ): \"\"\" Returns all notes for that patient. Args: patient_id (str) : ID for the patient Returns: notes: A list of all notes for that patient \"\"\" mongodb_search_query = { \"patient_id\" : patient_id , \"reviewed\" : reviewed } notes = mongo . db [ \"NOTES\" ] . find ( mongodb_search_query ) return notes","title":"get_patient_notes"},{"location":"query_database/#cedars.app.ops.db.get_patient_reviewer","text":"Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 def get_patient_reviewer ( patient_id : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" reviewed_by = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id })[ \"reviewed_by\" ] if reviewed_by . strip () == \"\" : return None return reviewed_by","title":"get_patient_reviewer"},{"location":"query_database/#cedars.app.ops.db.get_patients_to_annotate","text":"Retrieves a patient that have not been reviewed Returns: patient_to_annotate: A single patient that needs to manually reviewed Source code in cedars/app/db.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 def get_patients_to_annotate (): \"\"\" Retrieves a patient that have not been reviewed Args: None Returns: patient_to_annotate: A single patient that needs to manually reviewed \"\"\" logger . debug ( \"Retriving all un-reviewed patients from database.\" ) # check is this patient has any unreviewed annotations for patient_id in get_patient_ids (): annotations = get_patient_annotation_ids ( patient_id ) if len ( annotations ) > 0 : return patient_id return None","title":"get_patients_to_annotate"},{"location":"query_database/#cedars.app.ops.db.get_pines_url","text":"Retrives PINES url from INFO col. Source code in cedars/app/db.py 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 def get_pines_url (): ''' Retrives PINES url from INFO col. ''' info_col = mongo . db [ \"INFO\" ] . find_one () if info_col : return info_col [ \"pines_url\" ] return None","title":"get_pines_url"},{"location":"query_database/#cedars.app.ops.db.get_prediction","text":"","title":"get_prediction"},{"location":"query_database/#cedars.app.ops.db.get_prediction--pines-predictions","text":"Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" pines_api_url = get_pines_url () url = f ' { pines_api_url } /predict' data = { 'text' : note } log_notes = None try : response = requests . post ( url , json = data , timeout = 3600 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score log_notes = re . sub ( r '\\d' , '*' , note [: 20 ]) logger . debug ( f \"Got prediction for note: { log_notes } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { log_notes } \" ) raise e","title":"PINES predictions"},{"location":"query_database/#cedars.app.ops.db.get_proj_name","text":"Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 def get_proj_name (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () if proj_info is None : return None proj_name = proj_info [ \"project\" ] return proj_name","title":"get_proj_name"},{"location":"query_database/#cedars.app.ops.db.get_project_users","text":"Returns all the usernames for approved users (including the admin) for this project Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project Source code in cedars/app/db.py 976 977 978 979 980 981 982 983 984 985 986 987 988 def get_project_users (): \"\"\" Returns all the usernames for approved users (including the admin) for this project Args: None Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project \"\"\" users = mongo . db [ \"USERS\" ] . find ({}) return [ user [ \"user\" ] for user in users ]","title":"get_project_users"},{"location":"query_database/#cedars.app.ops.db.get_search_query","text":"This function is used to get the current search query from the database. All this data is kept in the QUERY collection. Source code in cedars/app/db.py 497 498 499 500 501 502 503 504 505 506 507 def get_search_query ( query_key = \"query\" ): \"\"\" This function is used to get the current search query from the database. All this data is kept in the QUERY collection. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : return query [ query_key ] return \"\"","title":"get_search_query"},{"location":"query_database/#cedars.app.ops.db.get_search_query_details","text":"This function is used to get the current search query details from the database. Source code in cedars/app/db.py 510 511 512 513 514 515 516 517 518 519 520 521 def get_search_query_details (): \"\"\" This function is used to get the current search query details from the database. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : query . pop ( \"_id\" ) return query return {}","title":"get_search_query_details"},{"location":"query_database/#cedars.app.ops.db.get_task","text":"Returns the task with this ID, regardless of it's completion status. Source code in cedars/app/db.py 1636 1637 1638 1639 1640 1641 def get_task ( task_id ): \"\"\" Returns the task with this ID, regardless of it's completion status. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find_one ({ \"job_id\" : task_id })","title":"get_task"},{"location":"query_database/#cedars.app.ops.db.get_task_in_progress","text":"Returns the task with this ID, if it has not been completed. Source code in cedars/app/db.py 1627 1628 1629 1630 1631 1632 1633 def get_task_in_progress ( task_id ): \"\"\" Returns the task with this ID, if it has not been completed. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find_one ({ \"job_id\" : task_id , \"complete\" : False })","title":"get_task_in_progress"},{"location":"query_database/#cedars.app.ops.db.get_tasks_in_progress","text":"Returns tasks that have not been completed yet. Source code in cedars/app/db.py 1619 1620 1621 1622 1623 1624 def get_tasks_in_progress (): \"\"\" Returns tasks that have not been completed yet. \"\"\" task_db = mongo . db [ \"TASK\" ] return task_db . find ({ \"complete\" : False })","title":"get_tasks_in_progress"},{"location":"query_database/#cedars.app.ops.db.get_total_counts","text":"Returns the total number of documents in a collection. Parameters: collection_name ( str) ) \u2013 The name of the collection to search. **kwargs \u2013 Additional arguments to pass to the find Returns: count (int) : The number of documents in the collection. Source code in cedars/app/db.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 def get_total_counts ( collection_name : str , ** kwargs ) -> int : \"\"\" Returns the total number of documents in a collection. Args: collection_name (str) : The name of the collection to search. **kwargs : Additional arguments to pass to the find Returns: count (int) : The number of documents in the collection. \"\"\" return mongo . db [ collection_name ] . count_documents ({ ** kwargs })","title":"get_total_counts"},{"location":"query_database/#cedars.app.ops.db.get_user","text":"This function is used to get a user from the database. Parameters: username ( str) ) \u2013 The name of the user to get. Returns: user (dict) : The user object from the database. Source code in cedars/app/db.py 484 485 486 487 488 489 490 491 492 493 494 def get_user ( username ): \"\"\" This function is used to get a user from the database. Args: username (str) : The name of the user to get. Returns: user (dict) : The user object from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return user","title":"get_user"},{"location":"query_database/#cedars.app.ops.db.insert_one_annotation","text":"Adds an annotation to the database. Parameters: annotation ( dict) ) \u2013 The annotation we are inserting Returns: None Source code in cedars/app/db.py 387 388 389 390 391 392 393 394 395 396 397 398 def insert_one_annotation ( annotation ): \"\"\" Adds an annotation to the database. Args: annotation (dict) : The annotation we are inserting Returns: None \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] annotations_collection . insert_one ( annotation )","title":"insert_one_annotation"},{"location":"query_database/#cedars.app.ops.db.is_admin_user","text":"check if the user is admin Source code in cedars/app/db.py 1391 1392 1393 1394 1395 1396 1397 1398 def is_admin_user ( username ): \"\"\"check if the user is admin\"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ 'user' : username }) if user is not None and user [ \"is_admin\" ]: return True return False","title":"is_admin_user"},{"location":"query_database/#cedars.app.ops.db.is_pines_api_running","text":"Returns True if a SuperBIO PINES API server is running. Source code in cedars/app/db.py 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 def is_pines_api_running (): ''' Returns True if a SuperBIO PINES API server is running. ''' info_col = mongo . db [ \"INFO\" ] . find_one () if info_col : return info_col [ \"is_pines_server_enabled\" ] return False","title":"is_pines_api_running"},{"location":"query_database/#cedars.app.ops.db.mark_annotation_reviewed","text":"Updates the annotation in the database to mark it as reviewed. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 def mark_annotation_reviewed ( annotation_id ): \"\"\" Updates the annotation in the database to mark it as reviewed. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Marking annotation # { annotation_id } as reviewed.\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"reviewed\" : True }})","title":"mark_annotation_reviewed"},{"location":"query_database/#cedars.app.ops.db.mark_note_reviewed","text":"Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 1265 1266 1267 1268 1269 1270 1271 1272 def mark_note_reviewed ( note_id , reviewed_by : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" logger . debug ( f \"Marking note # { note_id } as reviewed.\" ) mongo . db [ \"NOTES\" ] . update_one ({ \"text_id\" : note_id }, { \"$set\" : { \"reviewed\" : True , \"reviewed_by\" : reviewed_by }})","title":"mark_note_reviewed"},{"location":"query_database/#cedars.app.ops.db.mark_patient_reviewed","text":"Updates the patient's status to reviewed in the database. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. reviewed_by ( str) ) \u2013 The name of the user who reviewed the patient. is_reviewed ( bool) , default: True ) \u2013 True if patient's annotations have been reviewed. Returns: None Source code in cedars/app/db.py 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 def mark_patient_reviewed ( patient_id : str , reviewed_by : str , is_reviewed = True ): \"\"\" Updates the patient's status to reviewed in the database. Args: patient_id (int) : Unique ID for a patient. reviewed_by (str) : The name of the user who reviewed the patient. is_reviewed (bool) : True if patient's annotations have been reviewed. Returns: None \"\"\" logger . debug ( f \"Marking patient # { patient_id } as reviewed.\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"reviewed\" : is_reviewed , \"reviewed_by\" : reviewed_by }}) logger . info ( f \"Storing results for patient # { patient_id } \" ) upsert_patient_results ( patient_id )","title":"mark_patient_reviewed"},{"location":"query_database/#cedars.app.ops.db.patient_results_exist","text":"Checks if the results for this patient exist in the RESULTS collection. Args patient_id (str) : ID of the patient. Returns has_result (bool) : True if this patient has a stored result. Source code in cedars/app/db.py 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 def patient_results_exist ( patient_id : str ): ''' Checks if the results for this patient exist in the RESULTS collection. Args : - patient_id (str) : ID of the patient. Returns : - has_result (bool) : True if this patient has a stored result. ''' stored_results = mongo . db [ \"RESULTS\" ] . find_one ({ \"patient_id\" : patient_id }) if stored_results is None : return False return True","title":"patient_results_exist"},{"location":"query_database/#cedars.app.ops.db.populate_task","text":"This database stores tasks in rq Source code in cedars/app/db.py 170 171 172 173 174 175 176 177 178 def populate_task (): \"\"\" This database stores tasks in rq \"\"\" # Pylint disabled for pointless statement. # This statement is used to create a collection. task = mongo . db [ \"TASK\" ] # task.create_index(\"job_id\", unique=True) logger . info ( \"Created %s collection.\" , task . name )","title":"populate_task"},{"location":"query_database/#cedars.app.ops.db.populate_users","text":"This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. Source code in cedars/app/db.py 148 149 150 151 152 153 154 155 156 def populate_users (): \"\"\" This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. \"\"\" users = mongo . db [ \"USERS\" ] users . create_index ( \"user\" , unique = True ) logger . info ( \"Created USERS collection.\" )","title":"populate_users"},{"location":"query_database/#cedars.app.ops.db.predict_and_save","text":"","title":"predict_and_save"},{"location":"query_database/#cedars.app.ops.db.predict_and_save--save-pines-predictions","text":"Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) count = 0 for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"text_date\" : note . get ( \"text_date\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) count += 1","title":"Save PINES predictions"},{"location":"query_database/#cedars.app.ops.db.remove_all_locked","text":"Sets the locked status of all patients to False. This is done when the server is shutting down. Source code in cedars/app/db.py 1328 1329 1330 1331 1332 1333 1334 1335 def remove_all_locked (): \"\"\" Sets the locked status of all patients to False. This is done when the server is shutting down. \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_many ({}, { \"$set\" : { \"locked\" : False }})","title":"remove_all_locked"},{"location":"query_database/#cedars.app.ops.db.report_failure","text":"Saves the data associated with a job that failed to complete. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. Source code in cedars/app/db.py 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 def report_failure ( job ): \"\"\" Saves the data associated with a job that failed to complete. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. \"\"\" job . meta [ 'progress' ] = 0 job . save_meta () update_db_task_progress ( job . get_id (), 0 )","title":"report_failure"},{"location":"query_database/#cedars.app.ops.db.report_success","text":"Saves the data associated with a successful job after completion. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. Source code in cedars/app/db.py 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 def report_success ( job ): \"\"\" Saves the data associated with a successful job after completion. This will also automatically check for the completion of all current tasks. If the tasks are completed will then create all required indices and shutdown the PINES server if it is running via a SUPERBIO api. \"\"\" job . meta [ 'progress' ] = 100 job . save_meta () update_db_task_progress ( job . get_id (), 100 )","title":"report_success"},{"location":"query_database/#cedars.app.ops.db.reset_patient_reviewed","text":"Update all patients, notes to be un-reviewed. Source code in cedars/app/db.py 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 def reset_patient_reviewed (): \"\"\" Update all patients, notes to be un-reviewed. \"\"\" mongo . db [ \"PATIENTS\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" , \"comments\" : \"\" }}) mongo . db [ \"NOTES\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" }})","title":"reset_patient_reviewed"},{"location":"query_database/#cedars.app.ops.db.save_query","text":"This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Parameters: query ( str) ) \u2013 The regex query. exclude_negated ( bool) ) \u2013 True if we want to exclude negated tokens. hide_duplicates ( bool) ) \u2013 True if we want to restrict duplicate queries. skip_after_event ( bool) ) \u2013 True if sentences occurring after a recorded clinical event are to be skipped. tag_query ( dict of mapping [str ) \u2013 list]) : Key words to include or exclude in the search. date_min ( str) , default: now () ) \u2013 Smallest date for valid query. date_max ( str) , default: now () ) \u2013 Greatest date for valid query. Returns: Status (bool) : True if the query was saved, False if query same quqery already exists. Source code in cedars/app/db.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def save_query ( query , exclude_negated , hide_duplicates , # pylint: disable=R0913 skip_after_event , tag_query , date_min = datetime . now (), date_max = datetime . now ()): \"\"\" This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Args: query (str) : The regex query. exclude_negated (bool) : True if we want to exclude negated tokens. hide_duplicates (bool) : True if we want to restrict duplicate queries. skip_after_event (bool) : True if sentences occurring after a recorded clinical event are to be skipped. tag_query (dict of mapping [str : list]) : Key words to include or exclude in the search. date_min (str) : Smallest date for valid query. date_max (str) : Greatest date for valid query. Returns: Status (bool) : True if the query was saved, False if query same quqery already exists. \"\"\" info = { \"query\" : query , \"exclude_negated\" : exclude_negated , \"hide_duplicates\" : hide_duplicates , \"skip_after_event\" : skip_after_event , \"tag_query\" : tag_query , \"date_min\" : date_min , \"date_max\" : date_max } collection = mongo . db [ \"QUERY\" ] # only one query is current at a time. # TODO: make a query history and enable multiple queries. info [ \"current\" ] = True if ( query == get_search_query () and skip_after_event == get_search_query ( \"skip_after_event\" ) and tag_query . get ( 'nlp_apply' , False ) == get_search_query ( \"tag_query\" ) . get ( 'nlp_apply' , False )): logger . info ( f \"Query already saved : { query } .\" ) return False collection . update_one ({ \"current\" : True }, { \"$set\" : { \"current\" : False }}) collection . insert_one ( info ) logger . info ( f \"Saved query : { query } .\" ) return True","title":"save_query"},{"location":"query_database/#cedars.app.ops.db.set_patient_lock_status","text":"Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking status ( bool) ) \u2013 True if the patient is being locked, False otherwise. Returns: \u2013 None Source code in cedars/app/db.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 def set_patient_lock_status ( patient_id : str , status ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking status (bool) : True if the patient is being locked, False otherwise. Returns: None \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"locked\" : status }})","title":"set_patient_lock_status"},{"location":"query_database/#cedars.app.ops.db.terminate_project","text":"","title":"terminate_project"},{"location":"query_database/#cedars.app.ops.db.terminate_project--terminate-the-project","text":"Reset the database to the initial state. Source code in cedars/app/db.py 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) # Delete all mongo DB collections mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) mongo . db . drop_collection ( \"TASK\" ) mongo . db . drop_collection ( \"RESULTS\" ) project_id = os . getenv ( \"PROJECT_ID\" , None ) create_project ( project_name = fake . slug (), investigator_name = fake . name (), project_id = project_id )","title":"Terminate the Project"},{"location":"query_database/#cedars.app.ops.db.update_annotation_reviewed","text":"Mark all annotations for a note as reviewed. Parameters: note_id ( str) ) \u2013 The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. Source code in cedars/app/db.py 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def update_annotation_reviewed ( note_id : str ) -> int : \"\"\" Mark all annotations for a note as reviewed. Args: note_id (str) : The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] result = annotations_collection . update_many ({ \"note_id\" : note_id }, { \"$set\" : { \"reviewed\" : True }}) return result . modified_count","title":"update_annotation_reviewed"},{"location":"query_database/#cedars.app.ops.db.update_db_task_progress","text":"Updates the progress of a task and checks if it has completed. This function will also automatically unlock the patient after completion. Source code in cedars/app/db.py 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 def update_db_task_progress ( task_id , progress ): \"\"\" Updates the progress of a task and checks if it has completed. This function will also automatically unlock the patient after completion. \"\"\" task_db = mongo . db [ \"TASK\" ] task = task_db . find_one ({ \"job_id\" : task_id }) completed = False if not task : # this might be the case if we have old messages # in the queue logger . error ( f \"Task { task_id } not found in database.\" ) return if progress >= 100 : completed = True task_db . update_one ({ \"job_id\" : task [ \"job_id\" ]}, { \"$set\" : { \"progress\" : progress , \"complete\" : completed }}) patient_id = ( task_id . split ( \":\" )[ 1 ]) . strip () # TODO: handle failed patients? set_patient_lock_status ( patient_id , False )","title":"update_db_task_progress"},{"location":"query_database/#cedars.app.ops.db.update_event_annotation_id","text":"Updates the ID for the annotation where the event date for a patient was found. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. annotation_id ( str) ) \u2013 ID of the annotation where the event date for this patient was entered. Returns: None Source code in cedars/app/db.py 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 def update_event_annotation_id ( patient_id : str , annotation_id ): \"\"\" Updates the ID for the annotation where the event date for a patient was found. Args: patient_id (str) : Unique ID for the patient. annotation_id (str) : ID of the annotation where the event date for this patient was entered. Returns: None \"\"\" logger . debug ( f \"Updating event_annotation_id on patient # { patient_id } .\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_annotation_id\" : annotation_id }})","title":"update_event_annotation_id"},{"location":"query_database/#cedars.app.ops.db.update_event_date","text":"Enters a new event date for an patient. Parameters: patient_id ( str) ) \u2013 Unique ID for the patient. new_date ( str) ) \u2013 The new value to update the event date of the patient with. Must be in the format YYYY-MM-DD. annotation_id ( str) ) \u2013 ID for the annotation at which the new_date was marked. Returns: None Source code in cedars/app/db.py 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 def update_event_date ( patient_id : str , new_date , annotation_id ): \"\"\" Enters a new event date for an patient. Args: patient_id (str) : Unique ID for the patient. new_date (str) : The new value to update the event date of the patient with. Must be in the format YYYY-MM-DD. annotation_id (str) : ID for the annotation at which the new_date was marked. Returns: None \"\"\" # TODO: UTC dates logger . debug ( f \"Updating date on patient # { patient_id } to { new_date } .\" ) date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( new_date , date_format ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"event_date\" : datetime_obj }}) update_event_annotation_id ( patient_id , annotation_id )","title":"update_event_date"},{"location":"query_database/#cedars.app.ops.db.update_patient_results","text":"Creates the results collection if it does not exist and inserts data for patients that do not have any. Optionally updates the data for all patients including patients which already have results stored. Args update_existing_results (bool) : True if data for patients that already have results must be updated. Returns None Source code in cedars/app/db.py 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 def update_patient_results ( update_existing_results = False ): ''' Creates the results collection if it does not exist and inserts data for patients that do not have any. Optionally updates the data for all patients including patients which already have results stored. Args : - update_existing_results (bool) : True if data for patients that already have results must be updated. Returns : - None ''' if \"RESULTS\" not in mongo . db . list_collection_names (): # Create results collection populate_results () for patient_id in get_all_patient_ids (): if update_existing_results or ( not patient_results_exist ( patient_id )): upsert_patient_results ( patient_id )","title":"update_patient_results"},{"location":"query_database/#cedars.app.ops.db.update_pines_api_status","text":"Updates the is_pines_server_enabled in the INFO collection of the database to reflect the status of the PINES server. Parameters: new_status ( bool) ) \u2013 True if the PINES server is running. Returns: None Source code in cedars/app/db.py 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 def update_pines_api_status ( new_status ): \"\"\" Updates the is_pines_server_enabled in the INFO collection of the database to reflect the status of the PINES server. Args: new_status (bool) : True if the PINES server is running. Returns: None \"\"\" logger . info ( f \"Setting PINES API status to { new_status } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"is_pines_server_enabled\" : new_status }})","title":"update_pines_api_status"},{"location":"query_database/#cedars.app.ops.db.update_pines_api_url","text":"Updates the PINES API url in the INFO collection of the database to reflect the address of the PINES server. Parameters: new_url ( str) ) \u2013 The url of the PINES server's API. Returns: None Source code in cedars/app/db.py 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 def update_pines_api_url ( new_url ): \"\"\" Updates the PINES API url in the INFO collection of the database to reflect the address of the PINES server. Args: new_url (str) : The url of the PINES server's API. Returns: None \"\"\" logger . info ( f \"Setting PINES API url to { new_url } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"pines_url\" : new_url }})","title":"update_pines_api_url"},{"location":"query_database/#cedars.app.ops.db.update_project_name","text":"Updates the project name in the INFO collection of the database. Parameters: new_name ( str) ) \u2013 New name of the project. Returns: None Source code in cedars/app/db.py 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 def update_project_name ( new_name ): \"\"\" Updates the project name in the INFO collection of the database. Args: new_name (str) : New name of the project. Returns: None \"\"\" logger . info ( f \"Updating project name to # { new_name } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"project\" : new_name }})","title":"update_project_name"},{"location":"query_database/#cedars.app.ops.db.upsert_patient_results","text":"Stores the results of a patient who has been reviewed. If this patient already has results stored, the code will update the results for that patient. Args patient_id (str) : ID of the patient who has been reviewed. Returns None Source code in cedars/app/db.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def upsert_patient_results ( patient_id : str ): ''' Stores the results of a patient who has been reviewed. If this patient already has results stored, the code will update the results for that patient. Args : - patient_id (str) : ID of the patient who has been reviewed. Returns : - None ''' num_reviewed_notes = mongo . db [ \"NOTES\" ] . count_documents ({ 'patient_id' : patient_id , 'reviewed' : True }) all_note_details = get_formatted_patient_predictions ( patient_id ) reviewed_sentences = get_patient_annotation_ids ( patient_id , reviewed = True , key = \"sentence\" ) unreviewed_sentences = get_patient_annotation_ids ( patient_id , reviewed = False , key = \"sentence\" ) sentences = reviewed_sentences + unreviewed_sentences event_date = get_event_date ( patient_id ) key_annotation_id = get_event_annotation_id ( patient_id ) event_information = \"\" if event_date and key_annotation_id : key_annotation = get_annotation ( key_annotation_id ) event_information = key_annotation [ \"sentence\" ] key_note_id = key_annotation [ \"note_id\" ] event_information += f \" \\n Note_id : { key_note_id } \" first_note_date = get_first_note_date_for_patient ( patient_id ) last_note_date = get_last_note_date_for_patient ( patient_id ) patient = get_patient_by_id ( patient_id ) comments = patient . get ( \"comments\" , \"\" ) reviewer = get_patient_reviewer ( patient_id ) max_score = None max_score_note_id = \"\" max_score_note_date = None try : res = list ( get_max_prediction_score ( patient_id )) if len ( res ) > 0 : res = res [ 0 ] max_score = res [ \"max_score\" ] max_score_note_id = res [ \"text_id\" ] max_score_note_date = get_note_date ( max_score_note_id ) except Exception : logger . info ( f \"PINES results not available for patient: { patient_id } \" ) patient_results = { 'patient_id' : patient_id , 'total_notes' : get_num_patient_notes ( patient_id ), 'reviewed_notes' : num_reviewed_notes , 'total_sentences' : len ( sentences ), 'reviewed_sentences' : len ( reviewed_sentences ), 'sentences' : \" \\n \" . join ( sentences ), 'event_date' : event_date , 'event_information' : event_information , 'first_note_date' : first_note_date , 'last_note_date' : last_note_date , 'comments' : comments , 'reviewer' : reviewer , 'max_score_note_id' : max_score_note_id , 'max_score_note_date' : max_score_note_date , 'max_score' : max_score , 'predicted_notes' : all_note_details } if patient_results_exist ( patient_id ): # If the patient already has some results, we will override them logger . info ( f \"Results for patient # { patient_id } already exist, updating records.\" ) patient_results . pop ( \"patient_id\" ) mongo . db [ \"RESULTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : patient_results }) else : logger . info ( f \"Inserting results for patient # { patient_id } into the database.\" ) mongo . db [ \"RESULTS\" ] . insert_one ( patient_results )","title":"upsert_patient_results"},{"location":"upload_file_format/","text":"Upload File Format To upload patient data to CEDARS an admin can upload a file on the Upload File page. Below are the details describing the file requirements and upload process. 1. File Upload Process To make use of this software, we will first need to upload some medical records to the database. To do this, you can click on the dropdown menu on the top right of the page. From here you can select the \"Upload Data\" option. This will redirect you to a page where you can select a file with the data from your computer by clicking the \"Choose File\" button. 2. File Type CEDARS can accept tabular data stored in one of the the following file formats : .csv ( Comma Seperated Value ) .csv.gz ( GZIP Compressed CSV ) .xlsx ( Excel ) .json ( Json ) .parquet ( Parquet ) .pickle / .pkl ( Pickle ) 3. Mandatory Columns These are columns that the uploaded file is required for a CEDARS project. Below is the format in which the columns are listed - column_name (data type) : Description of this column Columns : patient_id (string / int) : A unique identifier for the patient associated with a note. If you upload this as an integer, it will be converted to a string in the backend. text_id (string) : A unique identifier for the note taken about this patient. text (string) : The note taken about this patient. text_date (string) : The date this note was taken in the format (YYYY-MM-DD). Note that the values in the text_id column must be unique, but all other columns may contain duplicate values. 4. Optional Columns These are optional columns that are not nessesary for CEDARS, but can be included to provide annotators with more context. Below is the format in which the columns are listed - column_name (data type) : Description of this column Columns : text_sequence (int) : A number stating the order in which note were taken. Example : 1 would indicate that the note for this row is the first note taken for this patient. doc_id (string) : A unique identifier for document which containts this note. text_tag_1 (string) : The first text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_2 (string) : The second text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_3 (string) : The third text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_4 (string) : The fourth text tag for this note, will be shown on the annotations page while the note is being reviewed. 5. Example Table Below is a sample table to help illustrate what the file format should look like. patient_id text_id text text_date doc_id text_sequence text_tag_1 text_tag_2 text_tag_3 text_tag_4 1111111111 UNIQUE0000000001 Mr First is a 60 YO M with a history of metastatic colon CA, diagnosed in 1-2008, initially with stage III disease and s/p hemicolectomy followed by adjuvant chemo, with recurrence in the liver 6 months ago, evaluated today for management of pulmonary embolism. 2010-01-01 DOC0000000001 1 consultation_note HPI Dr Blood Hugo First 1111111111 UNIQUE0000000002 hypercholesterlemia asthma HTN 2010-01-01 DOC0000000001 2 consultation_note PMHX Dr Blood Hugo First 2222222222 UNIQUE0000000019 Pt denies any fevers, NS or recent loss of weight. Review of other systems was otherwise negative. 2016-06-06 DOC0000000004 1 pre_op ROS Dr Internist Cherry Blossom","title":"Upload File Format"},{"location":"upload_file_format/#upload-file-format","text":"To upload patient data to CEDARS an admin can upload a file on the Upload File page. Below are the details describing the file requirements and upload process.","title":"Upload File Format"},{"location":"upload_file_format/#1-file-upload-process","text":"To make use of this software, we will first need to upload some medical records to the database. To do this, you can click on the dropdown menu on the top right of the page. From here you can select the \"Upload Data\" option. This will redirect you to a page where you can select a file with the data from your computer by clicking the \"Choose File\" button.","title":"1. File Upload Process"},{"location":"upload_file_format/#2-file-type","text":"CEDARS can accept tabular data stored in one of the the following file formats : .csv ( Comma Seperated Value ) .csv.gz ( GZIP Compressed CSV ) .xlsx ( Excel ) .json ( Json ) .parquet ( Parquet ) .pickle / .pkl ( Pickle )","title":"2. File Type"},{"location":"upload_file_format/#3-mandatory-columns","text":"These are columns that the uploaded file is required for a CEDARS project. Below is the format in which the columns are listed - column_name (data type) : Description of this column Columns : patient_id (string / int) : A unique identifier for the patient associated with a note. If you upload this as an integer, it will be converted to a string in the backend. text_id (string) : A unique identifier for the note taken about this patient. text (string) : The note taken about this patient. text_date (string) : The date this note was taken in the format (YYYY-MM-DD). Note that the values in the text_id column must be unique, but all other columns may contain duplicate values.","title":"3. Mandatory Columns"},{"location":"upload_file_format/#4-optional-columns","text":"These are optional columns that are not nessesary for CEDARS, but can be included to provide annotators with more context. Below is the format in which the columns are listed - column_name (data type) : Description of this column Columns : text_sequence (int) : A number stating the order in which note were taken. Example : 1 would indicate that the note for this row is the first note taken for this patient. doc_id (string) : A unique identifier for document which containts this note. text_tag_1 (string) : The first text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_2 (string) : The second text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_3 (string) : The third text tag for this note, will be shown on the annotations page while the note is being reviewed. text_tag_4 (string) : The fourth text tag for this note, will be shown on the annotations page while the note is being reviewed.","title":"4. Optional Columns"},{"location":"upload_file_format/#5-example-table","text":"Below is a sample table to help illustrate what the file format should look like. patient_id text_id text text_date doc_id text_sequence text_tag_1 text_tag_2 text_tag_3 text_tag_4 1111111111 UNIQUE0000000001 Mr First is a 60 YO M with a history of metastatic colon CA, diagnosed in 1-2008, initially with stage III disease and s/p hemicolectomy followed by adjuvant chemo, with recurrence in the liver 6 months ago, evaluated today for management of pulmonary embolism. 2010-01-01 DOC0000000001 1 consultation_note HPI Dr Blood Hugo First 1111111111 UNIQUE0000000002 hypercholesterlemia asthma HTN 2010-01-01 DOC0000000001 2 consultation_note PMHX Dr Blood Hugo First 2222222222 UNIQUE0000000019 Pt denies any fevers, NS or recent loss of weight. Review of other systems was otherwise negative. 2016-06-06 DOC0000000004 1 pre_op ROS Dr Internist Cherry Blossom","title":"5. Example Table"}]}