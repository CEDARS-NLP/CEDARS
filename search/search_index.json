{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Background CEDARS (Clinical Event Detection and Recording System) is a computational paradigm for collection and aggregation of time-to-event data in retrospective clinical studies. Developed out of a practical need for a more efficient way to conduct medical research, it aims to systematize and accelerate the review of electronic health record (EHR) corpora to detect and characterize clinical events. Using CEDARS, human abstractors can work more efficently through the use of dedicated graphical user interface (GUI). the system also incorporates a customized data storage scheme and a natural language processing (NLP) pipeline. In its current iteration, CEDARS is available as an open-source Python package under GPL-3 license . The latest package and previous versions can be cloned from GitHub . Full documentation is available here . CEDARS can be used with or without its companion NLP package PINES . Please see the Terms of Use before using CEDARS. CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. General Requirements Python 3.9 or later Docker Basic Concepts Sentences with keywords or concepts of interest are presented to the end user one at a time and in chronological order. The user assesses each sentence, determining whether or not a clinical event is being reported. The whole note or report drawn from the EHR is available for review in the GUI. If no event is declared in the sentence, CEDARS presents the next sentence for the same patient (#1). If an event date is entered, CEDARS moves to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. In order for CEDARS to be sufficiently sensitive and not miss and unacceptable number of clinical events, the keyword/concept search query must be well thought and exhaustive. The performance of CEDARS will vary by medical area, since the extent of medical lexicon will vary substantially between event types. Features Automatic Detection of Key Events Easy interface to upload and query medical data. Project Statistics Secure Login Operational Schema CEDARS is modular and all information for any given annotation project is stored in one MongoDB database. User credentials, original clinical notes, NLP annotations and patient-specific information are stored in dedicated collections. Once clinical notes have been uploaded, they are passed through the NLP pipeline. Currently only UDPipe is supported and integrated with CEDARS. If desired, the annotation pipeline can include negation and medical concept tagging by NegEx and UMLS respectively. Multiple users can load the web GUI and annotate records at the same time. Once accessed, a given patient record is locked for the user. Future Development We are currently documenting the performance of CEDARS with a focus on oncology clinical research. At the present time, we wish to solidify the CEDARS user interface and ensure a smooth experience in multi-user settings. In the longer term, plug-in modules featuring enhanced query generation and adaptive learning will be integrated into the R workflow. Support for other NLP engines and extensive parallel processing are also desirable. Please communicate with package author Simon Mantha, MD, MPH ( smantha@cedars.io ) if you want to discuss new features or using this software for your clinical research application.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#background","text":"CEDARS (Clinical Event Detection and Recording System) is a computational paradigm for collection and aggregation of time-to-event data in retrospective clinical studies. Developed out of a practical need for a more efficient way to conduct medical research, it aims to systematize and accelerate the review of electronic health record (EHR) corpora to detect and characterize clinical events. Using CEDARS, human abstractors can work more efficently through the use of dedicated graphical user interface (GUI). the system also incorporates a customized data storage scheme and a natural language processing (NLP) pipeline. In its current iteration, CEDARS is available as an open-source Python package under GPL-3 license . The latest package and previous versions can be cloned from GitHub . Full documentation is available here . CEDARS can be used with or without its companion NLP package PINES . Please see the Terms of Use before using CEDARS. CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations.","title":"Background"},{"location":"#general-requirements","text":"Python 3.9 or later Docker","title":"General Requirements"},{"location":"#basic-concepts","text":"Sentences with keywords or concepts of interest are presented to the end user one at a time and in chronological order. The user assesses each sentence, determining whether or not a clinical event is being reported. The whole note or report drawn from the EHR is available for review in the GUI. If no event is declared in the sentence, CEDARS presents the next sentence for the same patient (#1). If an event date is entered, CEDARS moves to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. In order for CEDARS to be sufficiently sensitive and not miss and unacceptable number of clinical events, the keyword/concept search query must be well thought and exhaustive. The performance of CEDARS will vary by medical area, since the extent of medical lexicon will vary substantially between event types.","title":"Basic Concepts"},{"location":"#features","text":"Automatic Detection of Key Events Easy interface to upload and query medical data. Project Statistics Secure Login","title":"Features"},{"location":"#operational-schema","text":"CEDARS is modular and all information for any given annotation project is stored in one MongoDB database. User credentials, original clinical notes, NLP annotations and patient-specific information are stored in dedicated collections. Once clinical notes have been uploaded, they are passed through the NLP pipeline. Currently only UDPipe is supported and integrated with CEDARS. If desired, the annotation pipeline can include negation and medical concept tagging by NegEx and UMLS respectively. Multiple users can load the web GUI and annotate records at the same time. Once accessed, a given patient record is locked for the user.","title":"Operational Schema"},{"location":"#future-development","text":"We are currently documenting the performance of CEDARS with a focus on oncology clinical research. At the present time, we wish to solidify the CEDARS user interface and ensure a smooth experience in multi-user settings. In the longer term, plug-in modules featuring enhanced query generation and adaptive learning will be integrated into the R workflow. Support for other NLP engines and extensive parallel processing are also desirable. Please communicate with package author Simon Mantha, MD, MPH ( smantha@cedars.io ) if you want to discuss new features or using this software for your clinical research application.","title":"Future Development"},{"location":"ABOUT/","text":"About CEDARS was created out of a need to more efficiently annotate patient datasets for clinical events. The initial application was for the assessment of a venous thromboembolism endpoint in a cohort of patients with cancer, however early on we decided to develop this software platform as a general purpose tool aimed at a broad array of clinical endpoints. The original implementation was in R programming language but more recently the code base was ported to Python. CEDARS is under development at Memorial Sloan Kettering Cancer Center (MSKCC) . The package authors include: Simon Mantha, MD, MPH : project lead, clinical hematologist by training Rohan Singh, MS : principal data scientist Kayan Irani : collaborator","title":"About"},{"location":"ABOUT/#about","text":"CEDARS was created out of a need to more efficiently annotate patient datasets for clinical events. The initial application was for the assessment of a venous thromboembolism endpoint in a cohort of patients with cancer, however early on we decided to develop this software platform as a general purpose tool aimed at a broad array of clinical endpoints. The original implementation was in R programming language but more recently the code base was ported to Python. CEDARS is under development at Memorial Sloan Kettering Cancer Center (MSKCC) . The package authors include: Simon Mantha, MD, MPH : project lead, clinical hematologist by training Rohan Singh, MS : principal data scientist Kayan Irani : collaborator","title":"About"},{"location":"CEDARS_admin_manual/","text":"CEDARS Administrator Manual CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. All CEDARS installations should be reviewed with institutional information security authorities. Software Installation Detailed Requirements Local Installation Requirement WARNING Local installation is not recommended unless you want to modify the underlying codebase. It is recommended to use the Docker deployment method. In order to run the app locally, you will need a .env file with at least the flask SECRET_KEY , MONGODB and MINIO details and the host IP. Place the .env file under the cedars/cedars directory. For example: SECRET_KEY = \\xcfR\\xd9D\\xaa\\x06\\x84S\\x19\\xc0\\xdcA\\t\\xf7it HOST=0.0.0.0 DB_HOST=localhost # change to DB_HOST=db if running docker container DB_NAME=cedars DB_PORT=27017 MINIO_HOST=localhost MINIO_PORT=9000 MINIO_ACCESS_KEY=ROOTUSER MINIO_SECRET_KEY=CHANGEME123 ENV=dev PINES_API_URL=<> # if using PINES CEDARS is a flask web application and depends on the following software: Python 3.9 or later You can install Python from the official website . If you have multiple python versions installed, you can manage the environments using pyenv Poetry To install poetry, run pipx install poetry or follow the instructions . Mongo 7.0 or later For using Mongo, you have multiple options: You might use your own enterprise Mongo instance You can use a cloud-based service like MongoDB Atlas You can run a local instance of Mongo using Docker You can run a local instance of Mongo using the official installation Minio Similar to Mongo, you have multiple options to install MINIO You might use your own enterprise MINIO instance You can use a cloud-based service like MINIO You can run a local instance of MINIO using Docker You can run a local instance of MINIO using the official installation Docker Requirement TIP This is the easiest way to run CEDARS and encapsulates all dependencies above.\" Install Docker and Docker Compose . System Architecture The CEDARS application runs on a web server and generates an online graphical user interface (GUI) using Flask. All data are stored in a MongoDB instance hosted separately. However, most CEDARS instances are dockerized in order to streamline the project setup process and ensure adequate compatibility of dependencies. Once the instance is running, electronic health record (EHR) documents are imported and processed through the CEDARS natural language processing (NLP) pipeline. Additional document annotation with a PINES model is optional. A CEDARS annotation project can be set up entirely from the GUI, using the administrator panel. The existing annotations can be downloaded at any point from this interface. Annotators can connect to the CEDARS app by accessing a web URL provided by the administrator. CEDARS performs the operations to pull selected documents from the database, process them and present them to the annotators. Data entered by users is processed by CEDARS and saved to the database. Multiple users can work on one CEDARS project at the same time. The application will automatically select individual patient records for each user. Record locking is implemented to prevent collisions and inconsistencies. Installing CEDARS To install CEDARS, please start by cloning the repository and installing the required dependencies. You can then run the app locally or using Docker. Clone the Repo: git clone git@github.com:CEDARS-NLP/CEDARS.git Change directory: cd CEDARS Initialize submodules: git submodule init Download submodules: git submodule update Standalone CEDARS Python Package Installation Make sure all the local requirements above are met. Then, you can install the package using Poetry: $ cd cedars $ poetry install # do not cd into cedars/app $ cd app $ poetry run python -m app.wsgi Docker Deployment The most straightforward way to complete a CEDARS project is via docker containers. This approach allows fast and reliable installation on prems or in the cloud with on-demand access to compute resources, including graphics processing unit (GPU). Inclusion of required dependencies in the containers mitigate the problems associated with version incompatibilities inherent to ad hoc builds. Docker images can be easily installed in air-gapped environment, which is sometimes an institutional requirement. A CEDARS docker deployment will include: CEDARS Flask web server MongoDB database service MINIO object storage service PINES NLP annotation service (optional) Each component runs as a service encapsulated in a docker container. Those three elements a coordinated within a deployment.The PINES service requires a GPU for model training. This is optional for inference (i.e. annotating documents). After cloning as described above, run the following commands: $ cd cedars $ docker-compose up --build -d and navigate to http:// :5001 Project Execution Overview Determining clinical event dates with CEDARS is a simple, sequential process: After generation of a CEDARS instance, EHR documents are uploaded, a keyword search query is generated and automatic NLP annotations are launched, following which manual data entry can begin. If known event dates exist, those can be imported before annotator work starts. Once all patient records have been annotated manually for clinical events, the dataset can be downloaded and used immediately in time-to-event analyses. Alternatively, estimated event dates can be obtained without the human review step if a PINES model of satisfactory accuracy was used to classify documents. The package authors suggest that a random sample of patients be selected for manual review via independent means. If performance metrics are unsatisfactory, the search query can be modified and CEDARS annotations updated through the same process. Setting Up a CEDARS Project and Users The first step after running CEDARS is to set up a new project. This is done by the administrator through the GUI. The following steps are required: 1. At first login, the administrator will be prompted to register a new user. This user will be the administrator of the project. 2. The administrator will then fill in Project Details such as Project Name. 3. The administrator can also create new users who will only work on the Annotation Interface. 4. Administrator will provide the credentials to the annotators. Electronic Health Record Corpus Upload Keyword Search Query Design The CEDARS search query incorporates the following wildcards: \"?\": for one character, for example \"r?d\" would match \"red\" or \"rod\" but not \"reed\" \"*\": for zero to any number of characters, for example \"r*\" would match \"red\", \"rod\", \"reed\", \"rd\", etc. CEDARS also applies the following Boolean operators: \"AND\": both conditions present \"OR\": either present present \"!\": negation, for example \"!red\" would only match sentences without the word \"red\" Lastly, the \"(\" and \")\" operators can be used to further develop logic within a query. Search Query Implementation Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. Spacy Requirements: ! - negation Each dictionary in a list matches one token only A list matches all the dictionaries inside it (and condition) A list of list contains OR conditions [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text Implementation: Split the query by OR Split each expression by AND Split each expression by NOT Split each expression by wildcard Convert each expression to a spacy pattern Combine the patterns Return the combined pattern Source code in cedars/app/nlpprocessor.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def query_to_patterns ( query : str ) -> list : \"\"\" Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. ##### Spacy Requirements: - ! - negation - Each dictionary in a list matches one token only - A list matches all the dictionaries inside it (and condition) - A list of list contains OR conditions - [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match - [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT - [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text ##### Implementation: 1. Split the query by OR 2. Split each expression by AND 3. Split each expression by NOT 4. Split each expression by wildcard 5. Convert each expression to a spacy pattern 6. Combine the patterns 7. Return the combined pattern \"\"\" def get_regex_dict ( token ): # Replace '*' with '.*' and '?' with '.' regex_pattern = '(?i)' + token . replace ( '*' , '.*' ) . replace ( '?' , '.' ) return { \"TEXT\" : { \"REGEX\" : regex_pattern }} def get_lemma_dict ( token ): return { \"LOWER\" : token } def get_negated_dict ( token ): return { \"LOWER\" : token , \"OP\" : \"!\" } or_expressions = query . split ( \" OR \" ) res = [[] for _ in range ( len ( or_expressions ))] for i , expression in enumerate ( or_expressions ): spacy_pattern = [] expression = expression . strip () . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) and_expressions = expression . split ( \" AND \" ) for tok in and_expressions : tok = tok . strip () if not tok : continue if \"*\" in tok or \"?\" in tok : spacy_pattern . append ( get_regex_dict ( tok )) elif \"!\" in tok : spacy_pattern . append ( get_negated_dict ( tok . replace ( \"!\" , \"\" ))) else : spacy_pattern . append ( get_lemma_dict ( tok )) # logger.debug(f\"{expression} -> {spacy_pattern}\") res [ i ] = spacy_pattern return res Natural Language Processing Annotations The process of automatically parsing clinical documents before presentation to an annotator is performed in three steps: 1. NLP annotation via the SpaCy traditional NLP pipeline : In this step, sentence boundaries, lemmas and negation status are characterized. Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. Ex. This is not an apple. In the above sentence, the token apple is negated. Parameters: spacy ( token ) \u2013 This is a token of a single word after spacy Returns: \u2013 (bool) : True if the token is negated in the sentence. Source code in cedars/app/nlpprocessor.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def is_negated ( span ): \"\"\" ##### Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. ``` Ex. This is not an apple. In the above sentence, the token apple is negated. ``` Args: spacy token : This is a token of a single word after spacy runs a model on some text. Returns: (bool) : True if the token is negated in the sentence. \"\"\" neg_words = [ 'no' , 'not' , \"n't\" , \"wouldn't\" , 'never' , 'nobody' , 'nothing' , 'neither' , 'nowhere' , 'noone' , 'no-one' , 'hardly' , 'scarcely' , 'barely' ] for token in span . subtree : parents = list ( token . ancestors ) children = list ( token . children ) for parent in token . ancestors : children . extend ( list ( parent . children )) if ( \"neg\" in [ child . dep_ for child in children ]) or ( \"neg\" in [ par . dep_ for par in parents ]): return True parents_text = [ par . text for par in parents ] children_text = [ child . text for child in children ] for word in neg_words : if word in parents_text or word in children_text : return True return False 2. Keyword query matching : only documents with at least one sentence matching the search query are retained. Sentences from documents without a matched will be marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually. Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. Source code in cedars/app/nlpprocessor.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def process_notes ( self , patient_id = None , processes = 1 , batch_size = 20 ): \"\"\" ##### Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. \"\"\" # nlp_model = spacy.load(model_name) matcher = Matcher ( self . nlp_model . vocab ) assert len ( matcher ) == 0 query = db . get_search_query () # load previosly processed documents # document_processed = load_progress() spacy_patterns = query_to_patterns ( query ) for i , item in enumerate ( spacy_patterns ): matcher . add ( f \"DVT_ { i } \" , [ item ]) # check all documents already processed if patient_id is not None : documents_to_process = db . get_patient_notes ( patient_id ) else : documents_to_process = db . get_documents_to_annotate () document_list = [ document for document in documents_to_process ] document_text = [ document [ \"text\" ] for document in document_list ] logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' ) } to process\" ) logger . info ( f \"sample document: { document_text [ 0 ][: 100 ] } \" ) annotations = self . nlp_model . pipe ( document_text , n_process = processes , batch_size = batch_size ) logger . info ( f \"Starting to process document annotations: { len ( document_text ) } \" ) count = 0 for document , doc in zip ( document_list , annotations ): match_count = 0 for sent_no , sentence_annotation in enumerate ( doc . sents ): sentence_text = sentence_annotation . text matches = matcher ( sentence_annotation ) for match in matches : match_count += 1 token_id , start , end = match token = sentence_annotation [ start : end ] # print(sentence_annotation) has_negation = is_negated ( token ) start_index = sentence_text . find ( token . text , start ) end_index = start_index + len ( token . text ) token_start = token . start_char token_end = token_start + len ( token . text ) annotation = { \"sentence\" : sentence_text , \"token\" : token . text , \"isNegated\" : has_negation , \"start_index\" : start_index , \"end_index\" : end_index , \"note_start_index\" : token_start , \"note_end_index\" : token_end , \"sentence_number\" : sent_no } annotation [ 'note_id' ] = document [ \"text_id\" ] annotation [ \"text_date\" ] = document [ \"text_date\" ] annotation [ \"patient_id\" ] = document [ \"patient_id\" ] annotation [ \"event_date\" ] = None annotation [ \"comments\" ] = [] annotation [ \"reviewed\" ] = False db . insert_one_annotation ( annotation ) if match_count == 0 : db . mark_note_reviewed ( document [ \"text_id\" ], reviewed_by = \"CEDARS\" ) count += 1 if ( count + 1 ) % 10 == 0 : logger . info ( f \"Processed { count + 1 } / { len ( document_list ) } documents\" ) 3. Transformer model labelling (optional): individual documents are labelled for their probability ( p ) of occurring at or after a clinical event. This last step is facultative and offers the possibility of further narrowing the scope of material to be reviewed manually, further improving efficiency. Documents with a p inferior to the predetermined threshold and their associated sentences are marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually. PINES predictions Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" url = f ' { os . getenv ( \"PINES_API_URL\" ) } /predict' data = { 'text' : note } try : response = requests . post ( url , json = data , timeout = 20 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score logger . debug ( f \"Got prediction for note: { note } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { note } \" ) raise e Save PINES predictions Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) Event Pre-Loading Sometimes a cohort of patients will already have been assessed with other methods and CEDARS is used as a redundant method to pick up any previously missed events. In this use case, a list of known clinical events with their dates will exist. This information can be loaded on CEDARS as a \"starting point\", so as to avoid re-discovering already documented events. Manual Assessment for Clinical Events The process by which human abstractors annotate patient records for events is described in the End User Manual . This step can be skipped altogether if a PINES model was used to classify documents. An estimated event date will be generated by PINES. Transformer models often exhibit sufficient performance to be used without individual record review, but an audit step as detailed below is strongly advised to confirm satisfactory sensitivity, specifcity and event time estimation. Dataset Download Once there are no patient records left to review, event data can be downloaded from the database via the GUI Detailed information is provided including clinical event dates, individual annotator contribution and review times. If a PINES model was used but no manual annotations were applied, estimated event dates can be used in a time-to-event analysis instead of manual entry. Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes Source code in cedars/app/ops.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 @bp . route ( '/download_annotations' ) @auth . admin_required def download_file ( filename = 'annotations.csv' ): \"\"\" ##### Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes \"\"\" logger . info ( \"Downloading annotations\" ) patients = db . get_all_patients () data = [] for patient in patients : patient_id = patient [ \"patient_id\" ] notes = db . get_all_notes ( patient_id ) reviewed_notes = db . get_patient_notes ( patient_id , reviewed = True ) reviewed_sentences = db . get_patient_annotation_ids ( patient_id , reviewed = True , key = \"sentence\" ) unreviewed_sentences = db . get_patient_annotation_ids ( patient_id , reviewed = False , key = \"sentence\" ) sentences = reviewed_sentences + unreviewed_sentences total_sentences = len ( sentences ) event_date = db . get_event_date ( patient_id ) first_note_date = db . get_first_note_date_for_patient ( patient_id ) last_note_date = db . get_last_note_date_for_patient ( patient_id ) data . append ([ patient_id , len ( notes ), len ( reviewed_notes ), total_sentences , len ( reviewed_sentences ), reviewed_sentences , event_date , first_note_date , last_note_date ]) df = pd . DataFrame ( data , columns = [ \"patient_id\" , \"total_notes\" , \"reviewed_notes\" , \"total_sentences\" , \"reviewed_sentences\" , \"sentences\" , \"event_date\" , \"first_note_date\" , \"last_note_date\" ]) data_bytes = df . to_csv () . encode ( 'utf-8' ) csv_buffer = BytesIO ( data_bytes ) client . put_object ( \"cedars\" , f \"annotated_files/ { filename } \" , data = csv_buffer , length = len ( data_bytes ), content_type = \"application/csv\" ) file_path = os . path . join ( current_app . config [ 'UPLOAD_FOLDER' ], filename ) client . fget_object ( \"cedars\" , filename , file_path ) logger . info ( f \"File saved to { file_path } \" ) return send_file ( file_path , as_attachment = True ) Audit CEDARS is by definition semi-automated, and depending on the specific use case and search query some events might be missed. This problem should be quantified by means of a systematic, old-fashion review of randomly selected patients. Typically, at least 200 patients would be selected and their corpora reviewed manually for events. Alternatively, a different method (e.g. billing codes) could be used. This audit dataset should be overlapped with the CEDARS event table to estimate sensitivity of the search query in the cohort at large. If this parameter falls below the previously established minimum acceptable value, the search query scope should be broadened, followed by a database reset, uploading of previously identified events and a new human annotation pass, followed by a repeat audit. Project Termination Once all events have been tallied and the audit results are satisfactory, if desired the CEDARS project database can be deleted from the MongoDB database. This is an irreversible operation. In future, there will be way to archive CEDARS projects, but this feature is not yet available. Terminate the Project Reset the database to the initial state. Source code in cedars/app/db.py 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) create_project ( project_name = fake . slug (), investigator_name = fake . name ())","title":"Administrator Manual"},{"location":"CEDARS_admin_manual/#cedars-administrator-manual","text":"CEDARS is provided as-is with no guarantee whatsoever and users agree to be held responsible for compliance with their local government/institutional regulations. All CEDARS installations should be reviewed with institutional information security authorities.","title":"CEDARS Administrator Manual"},{"location":"CEDARS_admin_manual/#software-installation","text":"","title":"Software Installation"},{"location":"CEDARS_admin_manual/#detailed-requirements","text":"","title":"Detailed Requirements"},{"location":"CEDARS_admin_manual/#local-installation-requirement","text":"WARNING Local installation is not recommended unless you want to modify the underlying codebase. It is recommended to use the Docker deployment method. In order to run the app locally, you will need a .env file with at least the flask SECRET_KEY , MONGODB and MINIO details and the host IP. Place the .env file under the cedars/cedars directory. For example: SECRET_KEY = \\xcfR\\xd9D\\xaa\\x06\\x84S\\x19\\xc0\\xdcA\\t\\xf7it HOST=0.0.0.0 DB_HOST=localhost # change to DB_HOST=db if running docker container DB_NAME=cedars DB_PORT=27017 MINIO_HOST=localhost MINIO_PORT=9000 MINIO_ACCESS_KEY=ROOTUSER MINIO_SECRET_KEY=CHANGEME123 ENV=dev PINES_API_URL=<> # if using PINES CEDARS is a flask web application and depends on the following software: Python 3.9 or later You can install Python from the official website . If you have multiple python versions installed, you can manage the environments using pyenv Poetry To install poetry, run pipx install poetry or follow the instructions . Mongo 7.0 or later For using Mongo, you have multiple options: You might use your own enterprise Mongo instance You can use a cloud-based service like MongoDB Atlas You can run a local instance of Mongo using Docker You can run a local instance of Mongo using the official installation Minio Similar to Mongo, you have multiple options to install MINIO You might use your own enterprise MINIO instance You can use a cloud-based service like MINIO You can run a local instance of MINIO using Docker You can run a local instance of MINIO using the official installation","title":"Local Installation Requirement"},{"location":"CEDARS_admin_manual/#docker-requirement","text":"TIP This is the easiest way to run CEDARS and encapsulates all dependencies above.\" Install Docker and Docker Compose .","title":"Docker Requirement"},{"location":"CEDARS_admin_manual/#system-architecture","text":"The CEDARS application runs on a web server and generates an online graphical user interface (GUI) using Flask. All data are stored in a MongoDB instance hosted separately. However, most CEDARS instances are dockerized in order to streamline the project setup process and ensure adequate compatibility of dependencies. Once the instance is running, electronic health record (EHR) documents are imported and processed through the CEDARS natural language processing (NLP) pipeline. Additional document annotation with a PINES model is optional. A CEDARS annotation project can be set up entirely from the GUI, using the administrator panel. The existing annotations can be downloaded at any point from this interface. Annotators can connect to the CEDARS app by accessing a web URL provided by the administrator. CEDARS performs the operations to pull selected documents from the database, process them and present them to the annotators. Data entered by users is processed by CEDARS and saved to the database. Multiple users can work on one CEDARS project at the same time. The application will automatically select individual patient records for each user. Record locking is implemented to prevent collisions and inconsistencies.","title":"System Architecture"},{"location":"CEDARS_admin_manual/#installing-cedars","text":"To install CEDARS, please start by cloning the repository and installing the required dependencies. You can then run the app locally or using Docker. Clone the Repo: git clone git@github.com:CEDARS-NLP/CEDARS.git Change directory: cd CEDARS Initialize submodules: git submodule init Download submodules: git submodule update","title":"Installing CEDARS"},{"location":"CEDARS_admin_manual/#standalone-cedars-python-package-installation","text":"Make sure all the local requirements above are met. Then, you can install the package using Poetry: $ cd cedars $ poetry install # do not cd into cedars/app $ cd app $ poetry run python -m app.wsgi","title":"Standalone CEDARS Python Package Installation"},{"location":"CEDARS_admin_manual/#docker-deployment","text":"The most straightforward way to complete a CEDARS project is via docker containers. This approach allows fast and reliable installation on prems or in the cloud with on-demand access to compute resources, including graphics processing unit (GPU). Inclusion of required dependencies in the containers mitigate the problems associated with version incompatibilities inherent to ad hoc builds. Docker images can be easily installed in air-gapped environment, which is sometimes an institutional requirement. A CEDARS docker deployment will include: CEDARS Flask web server MongoDB database service MINIO object storage service PINES NLP annotation service (optional) Each component runs as a service encapsulated in a docker container. Those three elements a coordinated within a deployment.The PINES service requires a GPU for model training. This is optional for inference (i.e. annotating documents). After cloning as described above, run the following commands: $ cd cedars $ docker-compose up --build -d and navigate to http:// :5001","title":"Docker Deployment"},{"location":"CEDARS_admin_manual/#project-execution","text":"","title":"Project Execution"},{"location":"CEDARS_admin_manual/#overview","text":"Determining clinical event dates with CEDARS is a simple, sequential process: After generation of a CEDARS instance, EHR documents are uploaded, a keyword search query is generated and automatic NLP annotations are launched, following which manual data entry can begin. If known event dates exist, those can be imported before annotator work starts. Once all patient records have been annotated manually for clinical events, the dataset can be downloaded and used immediately in time-to-event analyses. Alternatively, estimated event dates can be obtained without the human review step if a PINES model of satisfactory accuracy was used to classify documents. The package authors suggest that a random sample of patients be selected for manual review via independent means. If performance metrics are unsatisfactory, the search query can be modified and CEDARS annotations updated through the same process.","title":"Overview"},{"location":"CEDARS_admin_manual/#setting-up-a-cedars-project-and-users","text":"The first step after running CEDARS is to set up a new project. This is done by the administrator through the GUI. The following steps are required: 1. At first login, the administrator will be prompted to register a new user. This user will be the administrator of the project. 2. The administrator will then fill in Project Details such as Project Name. 3. The administrator can also create new users who will only work on the Annotation Interface. 4. Administrator will provide the credentials to the annotators.","title":"Setting Up a CEDARS Project and Users"},{"location":"CEDARS_admin_manual/#electronic-health-record-corpus-upload","text":"","title":"Electronic Health Record Corpus Upload"},{"location":"CEDARS_admin_manual/#keyword-search-query-design","text":"The CEDARS search query incorporates the following wildcards: \"?\": for one character, for example \"r?d\" would match \"red\" or \"rod\" but not \"reed\" \"*\": for zero to any number of characters, for example \"r*\" would match \"red\", \"rod\", \"reed\", \"rd\", etc. CEDARS also applies the following Boolean operators: \"AND\": both conditions present \"OR\": either present present \"!\": negation, for example \"!red\" would only match sentences without the word \"red\" Lastly, the \"(\" and \")\" operators can be used to further develop logic within a query.","title":"Keyword Search Query Design"},{"location":"CEDARS_admin_manual/#search-query-implementation","text":"Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards.","title":"Search Query Implementation"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.query_to_patterns--spacy-requirements","text":"! - negation Each dictionary in a list matches one token only A list matches all the dictionaries inside it (and condition) A list of list contains OR conditions [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text","title":"Spacy Requirements:"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.query_to_patterns--implementation","text":"Split the query by OR Split each expression by AND Split each expression by NOT Split each expression by wildcard Convert each expression to a spacy pattern Combine the patterns Return the combined pattern Source code in cedars/app/nlpprocessor.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def query_to_patterns ( query : str ) -> list : \"\"\" Expected query will be a set of keywords separated by OR keyword. Each expression separated by OR can have expressions combined by AND or NOT and the keywords can also contain wildcards. ##### Spacy Requirements: - ! - negation - Each dictionary in a list matches one token only - A list matches all the dictionaries inside it (and condition) - A list of list contains OR conditions - [{\"TEXT\": {\"REGEX\": \"abc*\"}}] represents one token with regex match - [{\"LOWER\": \"dvt\"}] matches case-insenstitive DVT - [{\"LEMMA\": \"embolus\"}] matches the lemmatized version of embolus as well in text ##### Implementation: 1. Split the query by OR 2. Split each expression by AND 3. Split each expression by NOT 4. Split each expression by wildcard 5. Convert each expression to a spacy pattern 6. Combine the patterns 7. Return the combined pattern \"\"\" def get_regex_dict ( token ): # Replace '*' with '.*' and '?' with '.' regex_pattern = '(?i)' + token . replace ( '*' , '.*' ) . replace ( '?' , '.' ) return { \"TEXT\" : { \"REGEX\" : regex_pattern }} def get_lemma_dict ( token ): return { \"LOWER\" : token } def get_negated_dict ( token ): return { \"LOWER\" : token , \"OP\" : \"!\" } or_expressions = query . split ( \" OR \" ) res = [[] for _ in range ( len ( or_expressions ))] for i , expression in enumerate ( or_expressions ): spacy_pattern = [] expression = expression . strip () . replace ( \"(\" , \"\" ) . replace ( \")\" , \"\" ) and_expressions = expression . split ( \" AND \" ) for tok in and_expressions : tok = tok . strip () if not tok : continue if \"*\" in tok or \"?\" in tok : spacy_pattern . append ( get_regex_dict ( tok )) elif \"!\" in tok : spacy_pattern . append ( get_negated_dict ( tok . replace ( \"!\" , \"\" ))) else : spacy_pattern . append ( get_lemma_dict ( tok )) # logger.debug(f\"{expression} -> {spacy_pattern}\") res [ i ] = spacy_pattern return res","title":"Implementation:"},{"location":"CEDARS_admin_manual/#natural-language-processing-annotations","text":"The process of automatically parsing clinical documents before presentation to an annotator is performed in three steps: 1. NLP annotation via the SpaCy traditional NLP pipeline : In this step, sentence boundaries, lemmas and negation status are characterized.","title":"Natural Language Processing Annotations"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.is_negated--negation-detection","text":"This function takes a spacy token and determines if it has been negated in the sentence. Ex. This is not an apple. In the above sentence, the token apple is negated. Parameters: spacy ( token ) \u2013 This is a token of a single word after spacy Returns: \u2013 (bool) : True if the token is negated in the sentence. Source code in cedars/app/nlpprocessor.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def is_negated ( span ): \"\"\" ##### Negation Detection This function takes a spacy token and determines if it has been negated in the sentence. ``` Ex. This is not an apple. In the above sentence, the token apple is negated. ``` Args: spacy token : This is a token of a single word after spacy runs a model on some text. Returns: (bool) : True if the token is negated in the sentence. \"\"\" neg_words = [ 'no' , 'not' , \"n't\" , \"wouldn't\" , 'never' , 'nobody' , 'nothing' , 'neither' , 'nowhere' , 'noone' , 'no-one' , 'hardly' , 'scarcely' , 'barely' ] for token in span . subtree : parents = list ( token . ancestors ) children = list ( token . children ) for parent in token . ancestors : children . extend ( list ( parent . children )) if ( \"neg\" in [ child . dep_ for child in children ]) or ( \"neg\" in [ par . dep_ for par in parents ]): return True parents_text = [ par . text for par in parents ] children_text = [ child . text for child in children ] for word in neg_words : if word in parents_text or word in children_text : return True return False 2. Keyword query matching : only documents with at least one sentence matching the search query are retained. Sentences from documents without a matched will be marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually.","title":"Negation Detection"},{"location":"CEDARS_admin_manual/#cedars.app.nlpprocessor.NlpProcessor.process_notes--process-query-matching","text":"This function takes a medical note and a regex query as input and annotates the relevant sections of the text. Source code in cedars/app/nlpprocessor.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def process_notes ( self , patient_id = None , processes = 1 , batch_size = 20 ): \"\"\" ##### Process Query Matching This function takes a medical note and a regex query as input and annotates the relevant sections of the text. \"\"\" # nlp_model = spacy.load(model_name) matcher = Matcher ( self . nlp_model . vocab ) assert len ( matcher ) == 0 query = db . get_search_query () # load previosly processed documents # document_processed = load_progress() spacy_patterns = query_to_patterns ( query ) for i , item in enumerate ( spacy_patterns ): matcher . add ( f \"DVT_ { i } \" , [ item ]) # check all documents already processed if patient_id is not None : documents_to_process = db . get_patient_notes ( patient_id ) else : documents_to_process = db . get_documents_to_annotate () document_list = [ document for document in documents_to_process ] document_text = [ document [ \"text\" ] for document in document_list ] logger . info ( f \"Found { len ( document_list ) } / { db . get_total_counts ( 'NOTES' ) } to process\" ) logger . info ( f \"sample document: { document_text [ 0 ][: 100 ] } \" ) annotations = self . nlp_model . pipe ( document_text , n_process = processes , batch_size = batch_size ) logger . info ( f \"Starting to process document annotations: { len ( document_text ) } \" ) count = 0 for document , doc in zip ( document_list , annotations ): match_count = 0 for sent_no , sentence_annotation in enumerate ( doc . sents ): sentence_text = sentence_annotation . text matches = matcher ( sentence_annotation ) for match in matches : match_count += 1 token_id , start , end = match token = sentence_annotation [ start : end ] # print(sentence_annotation) has_negation = is_negated ( token ) start_index = sentence_text . find ( token . text , start ) end_index = start_index + len ( token . text ) token_start = token . start_char token_end = token_start + len ( token . text ) annotation = { \"sentence\" : sentence_text , \"token\" : token . text , \"isNegated\" : has_negation , \"start_index\" : start_index , \"end_index\" : end_index , \"note_start_index\" : token_start , \"note_end_index\" : token_end , \"sentence_number\" : sent_no } annotation [ 'note_id' ] = document [ \"text_id\" ] annotation [ \"text_date\" ] = document [ \"text_date\" ] annotation [ \"patient_id\" ] = document [ \"patient_id\" ] annotation [ \"event_date\" ] = None annotation [ \"comments\" ] = [] annotation [ \"reviewed\" ] = False db . insert_one_annotation ( annotation ) if match_count == 0 : db . mark_note_reviewed ( document [ \"text_id\" ], reviewed_by = \"CEDARS\" ) count += 1 if ( count + 1 ) % 10 == 0 : logger . info ( f \"Processed { count + 1 } / { len ( document_list ) } documents\" ) 3. Transformer model labelling (optional): individual documents are labelled for their probability ( p ) of occurring at or after a clinical event. This last step is facultative and offers the possibility of further narrowing the scope of material to be reviewed manually, further improving efficiency. Documents with a p inferior to the predetermined threshold and their associated sentences are marked as reviewed. Patients with no remaining sentences/documents will be considered not to have sustained the event of interest and will not be reviewed manually.","title":"Process Query Matching"},{"location":"CEDARS_admin_manual/#cedars.app.db.get_prediction--pines-predictions","text":"Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" url = f ' { os . getenv ( \"PINES_API_URL\" ) } /predict' data = { 'text' : note } try : response = requests . post ( url , json = data , timeout = 20 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score logger . debug ( f \"Got prediction for note: { note } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { note } \" ) raise e","title":"PINES predictions"},{"location":"CEDARS_admin_manual/#cedars.app.db.predict_and_save--save-pines-predictions","text":"Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) })","title":"Save PINES predictions"},{"location":"CEDARS_admin_manual/#event-pre-loading","text":"Sometimes a cohort of patients will already have been assessed with other methods and CEDARS is used as a redundant method to pick up any previously missed events. In this use case, a list of known clinical events with their dates will exist. This information can be loaded on CEDARS as a \"starting point\", so as to avoid re-discovering already documented events.","title":"Event Pre-Loading"},{"location":"CEDARS_admin_manual/#manual-assessment-for-clinical-events","text":"The process by which human abstractors annotate patient records for events is described in the End User Manual . This step can be skipped altogether if a PINES model was used to classify documents. An estimated event date will be generated by PINES. Transformer models often exhibit sufficient performance to be used without individual record review, but an audit step as detailed below is strongly advised to confirm satisfactory sensitivity, specifcity and event time estimation.","title":"Manual Assessment for Clinical Events"},{"location":"CEDARS_admin_manual/#dataset-download","text":"Once there are no patient records left to review, event data can be downloaded from the database via the GUI Detailed information is provided including clinical event dates, individual annotator contribution and review times. If a PINES model was used but no manual annotations were applied, estimated event dates can be used in a time-to-event analysis instead of manual entry.","title":"Dataset Download"},{"location":"CEDARS_admin_manual/#cedars.app.ops.download_file--download-completed-annotations","text":"This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes Source code in cedars/app/ops.py 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 @bp . route ( '/download_annotations' ) @auth . admin_required def download_file ( filename = 'annotations.csv' ): \"\"\" ##### Download Completed Annotations This generates a CSV file with the following specifications: 1. Find all patients in the PATIENTS database, these patients become a single row in the CSV file. 2. For each patient - a. list the number of total notes in the database b. list the number of reviewed notes c. list the number of total sentences from annotations d. list the number of reviewed sentences e. list all sentences as a list of strings f. add event date from the annotations for each patient g. add the first and last note date for each patient 3. Convert all columns to proper datatypes \"\"\" logger . info ( \"Downloading annotations\" ) patients = db . get_all_patients () data = [] for patient in patients : patient_id = patient [ \"patient_id\" ] notes = db . get_all_notes ( patient_id ) reviewed_notes = db . get_patient_notes ( patient_id , reviewed = True ) reviewed_sentences = db . get_patient_annotation_ids ( patient_id , reviewed = True , key = \"sentence\" ) unreviewed_sentences = db . get_patient_annotation_ids ( patient_id , reviewed = False , key = \"sentence\" ) sentences = reviewed_sentences + unreviewed_sentences total_sentences = len ( sentences ) event_date = db . get_event_date ( patient_id ) first_note_date = db . get_first_note_date_for_patient ( patient_id ) last_note_date = db . get_last_note_date_for_patient ( patient_id ) data . append ([ patient_id , len ( notes ), len ( reviewed_notes ), total_sentences , len ( reviewed_sentences ), reviewed_sentences , event_date , first_note_date , last_note_date ]) df = pd . DataFrame ( data , columns = [ \"patient_id\" , \"total_notes\" , \"reviewed_notes\" , \"total_sentences\" , \"reviewed_sentences\" , \"sentences\" , \"event_date\" , \"first_note_date\" , \"last_note_date\" ]) data_bytes = df . to_csv () . encode ( 'utf-8' ) csv_buffer = BytesIO ( data_bytes ) client . put_object ( \"cedars\" , f \"annotated_files/ { filename } \" , data = csv_buffer , length = len ( data_bytes ), content_type = \"application/csv\" ) file_path = os . path . join ( current_app . config [ 'UPLOAD_FOLDER' ], filename ) client . fget_object ( \"cedars\" , filename , file_path ) logger . info ( f \"File saved to { file_path } \" ) return send_file ( file_path , as_attachment = True )","title":"Download Completed Annotations"},{"location":"CEDARS_admin_manual/#audit","text":"CEDARS is by definition semi-automated, and depending on the specific use case and search query some events might be missed. This problem should be quantified by means of a systematic, old-fashion review of randomly selected patients. Typically, at least 200 patients would be selected and their corpora reviewed manually for events. Alternatively, a different method (e.g. billing codes) could be used. This audit dataset should be overlapped with the CEDARS event table to estimate sensitivity of the search query in the cohort at large. If this parameter falls below the previously established minimum acceptable value, the search query scope should be broadened, followed by a database reset, uploading of previously identified events and a new human annotation pass, followed by a repeat audit.","title":"Audit"},{"location":"CEDARS_admin_manual/#project-termination","text":"Once all events have been tallied and the audit results are satisfactory, if desired the CEDARS project database can be deleted from the MongoDB database. This is an irreversible operation. In future, there will be way to archive CEDARS projects, but this feature is not yet available.","title":"Project Termination"},{"location":"CEDARS_admin_manual/#cedars.app.db.terminate_project--terminate-the-project","text":"Reset the database to the initial state. Source code in cedars/app/db.py 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) create_project ( project_name = fake . slug (), investigator_name = fake . name ())","title":"Terminate the Project"},{"location":"CEDARS_annotator_manual/","text":"CEDARS Annotator Manual Introduction This short manual is intended for data abstractors who will enter information about clinical events detected by CEDARS. CEDARS is a data pipepline set up to optimally present you with sentences drawn from a patient's medical record and potentially indicating the presence of a clinical event. Sentence detection is automatic and based on the words used, but often those sentences do not actually represent a true event. For example, the following sentence does not signal an actual new thrombotic episode: \"The patient was ruled-out for deep vein thrombosis last night.\" If sentence detection is based only on reporting sentences with the words \"deep vein thrombosis\", such a negative finding will be reported. In this case, you would not report an event and move on to the next sentence. Event detection approaches used by your CEDARS system administrator will vary, and some queries will be more selective than others, but generally the system will be set up to detect as many events as possible, at the cost of having a certain number of false positive findings. The intent here is for CEDARS to minimize the number of missed events, even if this approach results in you having to review a greater number of sentences. Sentences are presented in chronological order. Once you have identified and dated a clinical event, CEDARS might be set up by bypass all following sentences for this patient and move on to the next patient. This approach will be used when your system administrator only aims at capturing the first instance of an event of interest. Also, once you have evaluated all sentences of interest for a given patient, CEDARS will move on to the next patient seamlessly. This sequence of events is illustrated below: If you adjudicate a sentence as reporting no event, CEDARS will present the next sentence for the same patient (#1). On the other end, if you enter an event date, CEDARS will move to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed. Login Go to your CEDARS URL and use the credentials provided by the administrator. Find Clinical Events As soon as you are logged in, CEDARS will start looking for the next available patient with information to review. It might take a few moments before the first sentence is presented to you. The following is an example from a simulated cohort: Keywords or concepts are highlighted in red to help you locate them in the text. Evaluating a Sentence Only one sentence to review will be presented at any given time. It can be found at the beginning of the section titled \"Selected sentence:\". Your first task is to determine whether or not the sentence refers to an actual clinical event of interest, i.e. if the sentence is a true positive. Typically you will be able to make up your mind just by reading the sentence itself. If the sentence is ambiguous and you would like to obtain more context, you can review the note or report from which the sentence was drawn, situated at the bottom of the screen under the section \"Selected note:\". Also, completely at the bottom of the screen you will find a list of tags with associated data. The information presented here will vary, but would typically include the patient's name, the type of note, the author etc. For your reference, the date of entry for the note from which the sentence was drawn is indicated below the sentence, along with sentence position (first, second, third in line for review, etc) and patient ID. Annotating a Negative Sentence In many cases, the sentence you are looking at will be a false positive, i.e. it does not represent the kind of event you were tasked to report. In this case, simply click on the button \"ADJUDICATE SENTENCE\". This will mark the sentence as such and move to the next one in line. Move Between Sentences Within a Patient's Record Often the sentence and note presented to you will hint at a possible event but remain ambiguous, or an event will be obvious but the timing unclear. In such cases, you can move from sentence to sentence by using the \"<<< PREVIOUS\" and \"NEXT >>>\" buttons. You will go from sentence to sentence, following the timeline of electronic record notes/reports. Note that using previous/next will not annotate sentences or otherwise enter information in the CEDARS database. Entering Information About a Patient Entering an Event Date Any known event date will be displayed at the beginning of section titled \"Event date:\". Most of the time this field will be empty, since generally speaking CEDARS projects aim to determine event dates for a cohort for which no prior information exists. However, CEDARS can also be used to verify known event dates, in which case the interface might display an event date for a patient you have not yet assessed. Your CEDARS system administrator will discuss this aspect with you before starting the project. Once you have determined a clinical event did indeed occur, the next step is to assess its timing. As noted above, you might have to travel between sentences or consult complete notes to confirm the date. Once you are ready to enter this information, click on the data entry field under the \"ENTER NEW DATE\" button. You will be prompted with a calendar. Once the date displayed is correct, press on button \"ENTER NEW DATE\". Given the nature of clinical narratives, not all events will be precisely dated. For example, a clinician might refer to an event only with the month and year, not the day. Such information can still be entered by using simple approximation guidelines. In CEDARS, if only the year of an event is known, enter July 1st of that year (e.g. \"2020-07-01\"). If only they year and month are known, enter the 15th day of that month/year (e.g. \"2020-11-15\" if the event was in November of 2020). When approximating a date, it is good practice to document this detail in a comment (see below). Deleting an Event Date It is possible to replace an erroneous date by entering a new one in the date entry field. If there was actually no event, the previously entered date can be deleted by clicking on button \"DELETE OLD DATE\". Entering Comments About a Patient At any point you can enter comments about a patient in the data entry field under \"New comments:\", however those will be saved only if you 1) adjudicate the sentence or 2) enter an event date. Search for a Specific Patient If you want to go back to a specific patient later on, take note of the patient ID number. After logon, CEDARS will automatically present you with the next available patient to review, so if you have already annotated all sentences for a given patient, the only way to find that record again is to do a search. In this case, simply enter the patient ID number under in the box under \"Search for patient\" and click button \"SEARCH\". If you click \"SEARCH\" on an empty field, CEDARS will bring up the next available patient for you to review. Record Locking Only one end user at a time can review or enter information about any given patient in the CEDARS database. If someone else is already looking at a specific patient record, you will be locked from accessing it.","title":"Annotator Manual"},{"location":"CEDARS_annotator_manual/#cedars-annotator-manual","text":"","title":"CEDARS Annotator Manual"},{"location":"CEDARS_annotator_manual/#introduction","text":"This short manual is intended for data abstractors who will enter information about clinical events detected by CEDARS. CEDARS is a data pipepline set up to optimally present you with sentences drawn from a patient's medical record and potentially indicating the presence of a clinical event. Sentence detection is automatic and based on the words used, but often those sentences do not actually represent a true event. For example, the following sentence does not signal an actual new thrombotic episode: \"The patient was ruled-out for deep vein thrombosis last night.\" If sentence detection is based only on reporting sentences with the words \"deep vein thrombosis\", such a negative finding will be reported. In this case, you would not report an event and move on to the next sentence. Event detection approaches used by your CEDARS system administrator will vary, and some queries will be more selective than others, but generally the system will be set up to detect as many events as possible, at the cost of having a certain number of false positive findings. The intent here is for CEDARS to minimize the number of missed events, even if this approach results in you having to review a greater number of sentences. Sentences are presented in chronological order. Once you have identified and dated a clinical event, CEDARS might be set up by bypass all following sentences for this patient and move on to the next patient. This approach will be used when your system administrator only aims at capturing the first instance of an event of interest. Also, once you have evaluated all sentences of interest for a given patient, CEDARS will move on to the next patient seamlessly. This sequence of events is illustrated below: If you adjudicate a sentence as reporting no event, CEDARS will present the next sentence for the same patient (#1). On the other end, if you enter an event date, CEDARS will move to the next unreviewed sentence before the event date. If there are no sentences left to review before the event, the GUI moves to the next patient (#2) and the process is repeated with the following record (#3 and #4), until all selected sentences have been reviewed.","title":"Introduction"},{"location":"CEDARS_annotator_manual/#login","text":"Go to your CEDARS URL and use the credentials provided by the administrator.","title":"Login"},{"location":"CEDARS_annotator_manual/#find-clinical-events","text":"As soon as you are logged in, CEDARS will start looking for the next available patient with information to review. It might take a few moments before the first sentence is presented to you. The following is an example from a simulated cohort: Keywords or concepts are highlighted in red to help you locate them in the text.","title":"Find Clinical Events"},{"location":"CEDARS_annotator_manual/#evaluating-a-sentence","text":"Only one sentence to review will be presented at any given time. It can be found at the beginning of the section titled \"Selected sentence:\". Your first task is to determine whether or not the sentence refers to an actual clinical event of interest, i.e. if the sentence is a true positive. Typically you will be able to make up your mind just by reading the sentence itself. If the sentence is ambiguous and you would like to obtain more context, you can review the note or report from which the sentence was drawn, situated at the bottom of the screen under the section \"Selected note:\". Also, completely at the bottom of the screen you will find a list of tags with associated data. The information presented here will vary, but would typically include the patient's name, the type of note, the author etc. For your reference, the date of entry for the note from which the sentence was drawn is indicated below the sentence, along with sentence position (first, second, third in line for review, etc) and patient ID.","title":"Evaluating a Sentence"},{"location":"CEDARS_annotator_manual/#annotating-a-negative-sentence","text":"In many cases, the sentence you are looking at will be a false positive, i.e. it does not represent the kind of event you were tasked to report. In this case, simply click on the button \"ADJUDICATE SENTENCE\". This will mark the sentence as such and move to the next one in line.","title":"Annotating a Negative Sentence"},{"location":"CEDARS_annotator_manual/#move-between-sentences-within-a-patients-record","text":"Often the sentence and note presented to you will hint at a possible event but remain ambiguous, or an event will be obvious but the timing unclear. In such cases, you can move from sentence to sentence by using the \"<<< PREVIOUS\" and \"NEXT >>>\" buttons. You will go from sentence to sentence, following the timeline of electronic record notes/reports. Note that using previous/next will not annotate sentences or otherwise enter information in the CEDARS database.","title":"Move Between Sentences Within a Patient's Record"},{"location":"CEDARS_annotator_manual/#entering-information-about-a-patient","text":"","title":"Entering Information About a Patient"},{"location":"CEDARS_annotator_manual/#entering-an-event-date","text":"Any known event date will be displayed at the beginning of section titled \"Event date:\". Most of the time this field will be empty, since generally speaking CEDARS projects aim to determine event dates for a cohort for which no prior information exists. However, CEDARS can also be used to verify known event dates, in which case the interface might display an event date for a patient you have not yet assessed. Your CEDARS system administrator will discuss this aspect with you before starting the project. Once you have determined a clinical event did indeed occur, the next step is to assess its timing. As noted above, you might have to travel between sentences or consult complete notes to confirm the date. Once you are ready to enter this information, click on the data entry field under the \"ENTER NEW DATE\" button. You will be prompted with a calendar. Once the date displayed is correct, press on button \"ENTER NEW DATE\". Given the nature of clinical narratives, not all events will be precisely dated. For example, a clinician might refer to an event only with the month and year, not the day. Such information can still be entered by using simple approximation guidelines. In CEDARS, if only the year of an event is known, enter July 1st of that year (e.g. \"2020-07-01\"). If only they year and month are known, enter the 15th day of that month/year (e.g. \"2020-11-15\" if the event was in November of 2020). When approximating a date, it is good practice to document this detail in a comment (see below).","title":"Entering an Event Date"},{"location":"CEDARS_annotator_manual/#deleting-an-event-date","text":"It is possible to replace an erroneous date by entering a new one in the date entry field. If there was actually no event, the previously entered date can be deleted by clicking on button \"DELETE OLD DATE\".","title":"Deleting an Event Date"},{"location":"CEDARS_annotator_manual/#entering-comments-about-a-patient","text":"At any point you can enter comments about a patient in the data entry field under \"New comments:\", however those will be saved only if you 1) adjudicate the sentence or 2) enter an event date.","title":"Entering Comments About a Patient"},{"location":"CEDARS_annotator_manual/#search-for-a-specific-patient","text":"If you want to go back to a specific patient later on, take note of the patient ID number. After logon, CEDARS will automatically present you with the next available patient to review, so if you have already annotated all sentences for a given patient, the only way to find that record again is to do a search. In this case, simply enter the patient ID number under in the box under \"Search for patient\" and click button \"SEARCH\". If you click \"SEARCH\" on an empty field, CEDARS will bring up the next available patient for you to review.","title":"Search for a Specific Patient"},{"location":"CEDARS_annotator_manual/#record-locking","text":"Only one end user at a time can review or enter information about any given patient in the CEDARS database. If someone else is already looking at a specific patient record, you will be locked from accessing it.","title":"Record Locking"},{"location":"TERMS_OF_USE/","text":"Terms of Use CEDARS (Clinical Event Detection And Recording System) PLEASE READ THIS DOCUMENT CAREFULLY BEFORE YOU ACCESS OR USE CEDARS. BY ACCESSING ANY PORTION OF CEDARS, YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS SET FORTH BELOW. IF YOU DO NOT WISH TO BE BOUND BY THESE TERMS AND CONDITIONS, PLEASE DO NOT ACCESS CEDARS. CEDARS is developed and maintained by Memorial Sloan Kettering Cancer Center (\u201cMSK,\u201d \u201cwe\u201d, or \u201cus\u201d) to assist in clinical event detection. MSK may, from time to time, update the software and other content on https://github.com/CEDARS-NLP/CEDARS (\u201cContent\u201d). MSK makes no warranties or representations, and hereby disclaims any warranties, express or implied, with respect to any of the Content, including as to the present accuracy, completeness, timeliness, adequacy, or usefulness of any of the Content. The entire risk as to the quality and performance of the Content is with you. By using this Content, you agree that MSK will not be liable for any losses or damages arising from your use of or reliance on the Content, or other websites or information to which this Content may be linked, including any general, special, incidental or consequential damages arising out of the use or inability to use the Content including, but not limited to, loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the Content to operate with any other software, programs, source code, etc. By making any use of the Content or submitting any information or data along with such to us, you authorize MSK to copy, modify, display, distribute, perform, use, publish, and otherwise exploit the same for any and all purposes, all without compensation to you, for as long as we decide (collectively, the \"Use Rights\"). In addition, you authorize MSK to grant any third party some or all of the Use Rights. By way of example, and not limitation, the Use Rights include the right for us to publish any data or information submitted in whole or in part for as long as we choose. By providing any data or information, you represent and warrant that (i) you own all rights in and to the information or data (including any related intellectual property rights) or have sufficient authority and right to provide the content and to grant the Use Rights; (ii) your submission of the information or data and grant to us of Use Rights do not violate or conflict with the rights of other persons, or breach your obligations to other persons; and (iii) the information or data does not include or contain any personally identifiable information (PII) or protected health information (PHI). DO NOT submit personally identifiable information (PII) or protected health information (PHI) in connection with any information or data or otherwise. You may use CEDARS, the underlying content, and any output therefrom for personal or academic research and noncommercial purposes only, including teaching and research at universities, colleges and other educational institutions. You may not use it for any other purpose. You may not publish the Content in any capacity, including in scientific or academic journals or literature, or the results of such research, without MSK\u2019s express written permission. You may not otherwise redistribute or share the Content with any third party, in part or in whole, for any purpose, without the express written permission of MSK. You may not sell, resell, rent, lease or exchange the Content or any derivative works in any form for commercial purposes, for anything of value, or for any profit whatsoever, including any sort of monetary compensation. Any use of the Content for commercial purposes, including but not restricted to, running business operations, licensing, leasing or selling the Content, distributing the Content for use with commercial products, consulting activities, design of commercial hardware or software products, or a distributing to a commercial entity participating in research projects, requires MSK\u2019s express written permission and provision of an appropriate license. Without limiting the generality of the foregoing, you may not use any part of CEDARS, the underlying Content or the output for any other purpose, including: a) use or incorporation into a commercial product or towards the performance of a commercial service; b) research use in a commercial setting; c) diagnosis, treatment or use for patient care or the provision of medical services; or d) generation of reports in a medical, laboratory, hospital or other patient care setting. You may not copy, transfer, reproduce, modify, sell, sublicense, distribute or create derivative works of CEDARS or the underlying Content for any commercial purpose without the express permission of MSK. Any attempt otherwise to copy, transfer, modify, sublicense or distribute the Content is void, and will automatically terminate your rights under these Terms of Use. The output of CEDARS and the underlying Content is not a substitute for professional medical help, judgment, or advice. Use of CEDARS does not create a physician-patient relationship or in any way make a person a patient of MSK. A physician or other qualified health provider should always be consulted for any health problem or medical condition. Neither these Terms or Use nor the availability of CEDARS should be understood to create an obligation or expectation that MSK will continue to make CEDARS available. MSK may discontinue or restrict the availability of CEDARS at any time. MSK may also modify these Terms or Use at any time. Any use of the Content is subject to MSK\u2019s intellectual property rights, including any granted, pending or filed provisional patent applications, and any other patent, copyright, trademark, trade secret or other intellectual property rights. MSK respects the intellectual property rights of others, just as it expects others to respect its intellectual property. If you believe that any content (including data or information uploaded by you) to the Content or other activity taking place on the website where it is hosted constitutes infringement of a work protected by copyright, please notify us as follows: e-mail Simon Mantha at manthas@mskcc.org Your notice must comply with the Digital Millennium Copyright Act (17 U.S.C. \u00a7512) (the \"DMCA\"). Upon receipt of a compliant notice, we will respond and proceed in accordance with the DMCA. By using CEDARS, you consent to the jurisdiction and venue of the state and federal courts located in New York City, New York, USA, for any claims related to or arising from your use of CEDARS or your violation of these Terms of Use, and agree that you will not bring any claims against MSK that relate to or arise from the foregoing except in those courts. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of these Terms of Use, they do not excuse you from the conditions of these Terms of Use. If any provision of these Terms of Use is held to be invalid or unenforceable, then such provision shall be struck and the remaining provisions shall be enforced. Headings are for reference purposes only and in no way define, limit, construe, or describe the scope or extent of such section. MSK\u2019s failure to act with respect to a breach by you or others does not waive its right to act with respect to subsequent or similar breaches. This agreement and the terms and conditions contained herein set forth the entire understanding and agreement between MSK and you with respect to the subject matter hereof and supersede any prior or contemporaneous understanding, whether written or oral. Inquiries about the Content should be directed to manthas@mskcc.org. If you are interested in using CEDARS for purposes beyond those permitted by these Terms of Use, please contact manthas@mskcc.org to inquire concerning the availability of a license.","title":"Terms of Use"},{"location":"TERMS_OF_USE/#terms-of-use-cedars-clinical-event-detection-and-recording-system","text":"PLEASE READ THIS DOCUMENT CAREFULLY BEFORE YOU ACCESS OR USE CEDARS. BY ACCESSING ANY PORTION OF CEDARS, YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS SET FORTH BELOW. IF YOU DO NOT WISH TO BE BOUND BY THESE TERMS AND CONDITIONS, PLEASE DO NOT ACCESS CEDARS. CEDARS is developed and maintained by Memorial Sloan Kettering Cancer Center (\u201cMSK,\u201d \u201cwe\u201d, or \u201cus\u201d) to assist in clinical event detection. MSK may, from time to time, update the software and other content on https://github.com/CEDARS-NLP/CEDARS (\u201cContent\u201d). MSK makes no warranties or representations, and hereby disclaims any warranties, express or implied, with respect to any of the Content, including as to the present accuracy, completeness, timeliness, adequacy, or usefulness of any of the Content. The entire risk as to the quality and performance of the Content is with you. By using this Content, you agree that MSK will not be liable for any losses or damages arising from your use of or reliance on the Content, or other websites or information to which this Content may be linked, including any general, special, incidental or consequential damages arising out of the use or inability to use the Content including, but not limited to, loss of data or data being rendered inaccurate or losses sustained by you or third parties or a failure of the Content to operate with any other software, programs, source code, etc. By making any use of the Content or submitting any information or data along with such to us, you authorize MSK to copy, modify, display, distribute, perform, use, publish, and otherwise exploit the same for any and all purposes, all without compensation to you, for as long as we decide (collectively, the \"Use Rights\"). In addition, you authorize MSK to grant any third party some or all of the Use Rights. By way of example, and not limitation, the Use Rights include the right for us to publish any data or information submitted in whole or in part for as long as we choose. By providing any data or information, you represent and warrant that (i) you own all rights in and to the information or data (including any related intellectual property rights) or have sufficient authority and right to provide the content and to grant the Use Rights; (ii) your submission of the information or data and grant to us of Use Rights do not violate or conflict with the rights of other persons, or breach your obligations to other persons; and (iii) the information or data does not include or contain any personally identifiable information (PII) or protected health information (PHI). DO NOT submit personally identifiable information (PII) or protected health information (PHI) in connection with any information or data or otherwise. You may use CEDARS, the underlying content, and any output therefrom for personal or academic research and noncommercial purposes only, including teaching and research at universities, colleges and other educational institutions. You may not use it for any other purpose. You may not publish the Content in any capacity, including in scientific or academic journals or literature, or the results of such research, without MSK\u2019s express written permission. You may not otherwise redistribute or share the Content with any third party, in part or in whole, for any purpose, without the express written permission of MSK. You may not sell, resell, rent, lease or exchange the Content or any derivative works in any form for commercial purposes, for anything of value, or for any profit whatsoever, including any sort of monetary compensation. Any use of the Content for commercial purposes, including but not restricted to, running business operations, licensing, leasing or selling the Content, distributing the Content for use with commercial products, consulting activities, design of commercial hardware or software products, or a distributing to a commercial entity participating in research projects, requires MSK\u2019s express written permission and provision of an appropriate license. Without limiting the generality of the foregoing, you may not use any part of CEDARS, the underlying Content or the output for any other purpose, including: a) use or incorporation into a commercial product or towards the performance of a commercial service; b) research use in a commercial setting; c) diagnosis, treatment or use for patient care or the provision of medical services; or d) generation of reports in a medical, laboratory, hospital or other patient care setting. You may not copy, transfer, reproduce, modify, sell, sublicense, distribute or create derivative works of CEDARS or the underlying Content for any commercial purpose without the express permission of MSK. Any attempt otherwise to copy, transfer, modify, sublicense or distribute the Content is void, and will automatically terminate your rights under these Terms of Use. The output of CEDARS and the underlying Content is not a substitute for professional medical help, judgment, or advice. Use of CEDARS does not create a physician-patient relationship or in any way make a person a patient of MSK. A physician or other qualified health provider should always be consulted for any health problem or medical condition. Neither these Terms or Use nor the availability of CEDARS should be understood to create an obligation or expectation that MSK will continue to make CEDARS available. MSK may discontinue or restrict the availability of CEDARS at any time. MSK may also modify these Terms or Use at any time. Any use of the Content is subject to MSK\u2019s intellectual property rights, including any granted, pending or filed provisional patent applications, and any other patent, copyright, trademark, trade secret or other intellectual property rights. MSK respects the intellectual property rights of others, just as it expects others to respect its intellectual property. If you believe that any content (including data or information uploaded by you) to the Content or other activity taking place on the website where it is hosted constitutes infringement of a work protected by copyright, please notify us as follows: e-mail Simon Mantha at manthas@mskcc.org Your notice must comply with the Digital Millennium Copyright Act (17 U.S.C. \u00a7512) (the \"DMCA\"). Upon receipt of a compliant notice, we will respond and proceed in accordance with the DMCA. By using CEDARS, you consent to the jurisdiction and venue of the state and federal courts located in New York City, New York, USA, for any claims related to or arising from your use of CEDARS or your violation of these Terms of Use, and agree that you will not bring any claims against MSK that relate to or arise from the foregoing except in those courts. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of these Terms of Use, they do not excuse you from the conditions of these Terms of Use. If any provision of these Terms of Use is held to be invalid or unenforceable, then such provision shall be struck and the remaining provisions shall be enforced. Headings are for reference purposes only and in no way define, limit, construe, or describe the scope or extent of such section. MSK\u2019s failure to act with respect to a breach by you or others does not waive its right to act with respect to subsequent or similar breaches. This agreement and the terms and conditions contained herein set forth the entire understanding and agreement between MSK and you with respect to the subject matter hereof and supersede any prior or contemporaneous understanding, whether written or oral. Inquiries about the Content should be directed to manthas@mskcc.org. If you are interested in using CEDARS for purposes beyond those permitted by these Terms of Use, please contact manthas@mskcc.org to inquire concerning the availability of a license.","title":"Terms of Use CEDARS (Clinical Event Detection And Recording System)"},{"location":"basic_concepts/","text":"Basic Concepts CEDARS uses a system where keywords are searched for using lemmas in the search query. This query must be in a regex format. After a query is entered all events that match the search query will be displayed to the user in the Adjudications page. However, unless it is otherwise specified all events that contain negations will not be shown in the Adjudications page. Lemmas A lemma is defined as the canonical, dictionary or citation form of a word. For example, the words bleeding, bled and bleed all have the lemma bleed. This allows us to search for a reference to an event regardless of tense or grammar. To learn more about lemmas you may read this article . Regex Patterns A regular expression (regex) pattern is a sequence of characters or words meant to match a pattern in text. For example, the pattern \"bleed|cut\" will search for both the words bleed and cut within a sentence. If either of them are found we can say that the pattern has been matched. To learn more you can learn more here . Negations A negation is the absence or opposite of a positive. For example, in the sentence \"He had no bleeding.\" the lemma for bleed is present, but a researcher looking for instances of bleeding will not be interested in this sentence. This is because the word \"bleeding\" has been negated and so must be excluded from the events.","title":"Basic Concepts"},{"location":"basic_concepts/#basic-concepts","text":"CEDARS uses a system where keywords are searched for using lemmas in the search query. This query must be in a regex format. After a query is entered all events that match the search query will be displayed to the user in the Adjudications page. However, unless it is otherwise specified all events that contain negations will not be shown in the Adjudications page.","title":"Basic Concepts"},{"location":"basic_concepts/#lemmas","text":"A lemma is defined as the canonical, dictionary or citation form of a word. For example, the words bleeding, bled and bleed all have the lemma bleed. This allows us to search for a reference to an event regardless of tense or grammar. To learn more about lemmas you may read this article .","title":"Lemmas"},{"location":"basic_concepts/#regex-patterns","text":"A regular expression (regex) pattern is a sequence of characters or words meant to match a pattern in text. For example, the pattern \"bleed|cut\" will search for both the words bleed and cut within a sentence. If either of them are found we can say that the pattern has been matched. To learn more you can learn more here .","title":"Regex Patterns"},{"location":"basic_concepts/#negations","text":"A negation is the absence or opposite of a positive. For example, in the sentence \"He had no bleeding.\" the lemma for bleed is present, but a researcher looking for instances of bleeding will not be interested in this sentence. This is because the word \"bleeding\" has been negated and so must be excluded from the events.","title":"Negations"},{"location":"download_annotations/","text":"Downloading Results Once you have reviewed the generated annotations and marked event dates, you can navigate to the dropdown on the top right. Here you can click the \"Download Annotations\" option. This will return a file with tabular data in .csv format. The table will have the following columns: sentence (the sentence in which the lemma was found) token (the word found in that sentence) lemma (the lemma of the word found) isNegated (will be TRUE if there is a negation on the word, otherwise it will be FALSE) start_index (the character index at which the word begins in the sentence) end_index (the character index at which the word ends in the sentence) patient_id (the ID of the patient for which that note was written) event_date (the date at which the event took place) comments (a list of all comments made by the researcher while working on the project) reviewed (will be TRUE if that record had been adjudicated by a researcher)","title":"Downloading Results"},{"location":"download_annotations/#downloading-results","text":"Once you have reviewed the generated annotations and marked event dates, you can navigate to the dropdown on the top right. Here you can click the \"Download Annotations\" option. This will return a file with tabular data in .csv format. The table will have the following columns: sentence (the sentence in which the lemma was found) token (the word found in that sentence) lemma (the lemma of the word found) isNegated (will be TRUE if there is a negation on the word, otherwise it will be FALSE) start_index (the character index at which the word begins in the sentence) end_index (the character index at which the word ends in the sentence) patient_id (the ID of the patient for which that note was written) event_date (the date at which the event took place) comments (a list of all comments made by the researcher while working on the project) reviewed (will be TRUE if that record had been adjudicated by a researcher)","title":"Downloading Results"},{"location":"getting_started/","text":"Getting Started Installation To install CEDARS on your computer you will need to complete the following steps: Download and install Docker Desktop on your computer. Download the CEDARS docker folder . Open the docker application on your computer. Go to the Containers tab in docker. Click the start button under Actions for the CEDARS project. Navigate to the \"http://localhost:5001\" URL in your browser. CEDARS will now be running on this webpage. First Usage The first time that a CEDARS project has been opened, you will see a page prompting you to enter an admin username and password. After this the project will load the interface as normal. Continued Usage After the installation has been complete, CEDARS will continue to run on the same URL until docker is shut down. To start the application again, follow steps 3. - 7. from the Installation section. Note that all data and progress in the project will be saved even after docker shuts down.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"To install CEDARS on your computer you will need to complete the following steps: Download and install Docker Desktop on your computer. Download the CEDARS docker folder . Open the docker application on your computer. Go to the Containers tab in docker. Click the start button under Actions for the CEDARS project. Navigate to the \"http://localhost:5001\" URL in your browser. CEDARS will now be running on this webpage.","title":"Installation"},{"location":"getting_started/#first-usage","text":"The first time that a CEDARS project has been opened, you will see a page prompting you to enter an admin username and password. After this the project will load the interface as normal.","title":"First Usage"},{"location":"getting_started/#continued-usage","text":"After the installation has been complete, CEDARS will continue to run on the same URL until docker is shut down. To start the application again, follow steps 3. - 7. from the Installation section. Note that all data and progress in the project will be saved even after docker shuts down.","title":"Continued Usage"},{"location":"query_database/","text":"Querying the Database To search for medical events using CEDARS you will need to write a regex query. For more information regarding these queries, you can refer to the Basic Concepts section of the documentation. After you enter a query, click submit and the NLP algorithm will run on the database and save instances of the event when it is found. After the database has been searched, you will be redirected to the Adjudications page where you can view the search results. Important Note Keep in mind that entering a new query will erase all records of the prior query and so you are advised to download a copy of the results of prior queries before entering a new one. Reference This file contatins an abstract class for CEDARS to interact with mongodb. add_comment ( annotation_id , comment ) Stores a new comment for a patient. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. comment ( str) ) \u2013 Text of the comment on this annotation. Returns: None Source code in cedars/app/db.py 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def add_comment ( annotation_id , comment ): \"\"\" Stores a new comment for a patient. Args: annotation_id (str) : Unique ID for the annotation. comment (str) : Text of the comment on this annotation. Returns: None \"\"\" if len ( comment ) == 0 : logger . info ( \"No comment entered.\" ) return logger . debug ( f \"Adding comment to annotation # { annotation_id } \" ) patient_id = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )})[ \"patient_id\" ] patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) comments = patient [ \"comments\" ] comments . append ( comment ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"comments\" : comments } }) add_project_user ( username , password , is_admin = False ) Adds a new user to the project database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The user's password is_admin ( bool) , default: False ) \u2013 True if the new user is the project admin (used when initializing the project) Returns: None Source code in cedars/app/db.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def add_project_user ( username , password , is_admin = False ): \"\"\" Adds a new user to the project database. Args: username (str) : The name of the new user password (str) : The user's password is_admin (bool) : True if the new user is the project admin (used when initializing the project) Returns: None \"\"\" password_hash = generate_password_hash ( password ) data = { \"user\" : username , \"password\" : password_hash , \"admin\" : is_admin } mongo . db [ \"USERS\" ] . insert_one ( data . copy ()) add_user ( username , password , is_admin = False ) This function is used to add a new user to the database. All this data is kept in the USERS collection. Parameters: username ( str) ) \u2013 The name of this user. password ( str) ) \u2013 The password this user will need to login to the system. Returns: None Source code in cedars/app/db.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def add_user ( username , password , is_admin = False ): \"\"\" This function is used to add a new user to the database. All this data is kept in the USERS collection. Args: username (str) : The name of this user. password (str) : The password this user will need to login to the system. Returns: None \"\"\" info = { \"user\" : username , \"password\" : password , \"is_admin\" : is_admin , \"date_created\" : datetime . now () } mongo . db [ \"USERS\" ] . insert_one ( info ) logger . info ( f \"Added user { username } to database.\" ) check_password ( username , password ) Checks if the password matches the password of that user from the database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The password entered by the user. Returns: \u2013 (bool) : True if the password matches the password of that user from the database. Source code in cedars/app/db.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 def check_password ( username , password ): \"\"\" Checks if the password matches the password of that user from the database. Args: username (str) : The name of the new user password (str) : The password entered by the user. Returns: (bool) : True if the password matches the password of that user from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return \"password\" in user and check_password_hash ( user [ \"password\" ], password ) create_info_col ( project_name , investigator_name , cedars_version ) This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def create_info_col ( project_name , investigator_name , cedars_version ): \"\"\" This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" collection = mongo . db [ \"INFO\" ] info = { \"creation_time\" : datetime . now (), \"project\" : project_name , \"investigator\" : investigator_name , \"CEDARS_version\" : cedars_version } collection . insert_one ( info ) logger . info ( \"Created INFO collection.\" ) create_project ( project_name , investigator_name , cedars_version = '0.1.0' ) This function creates all the collections in the mongodb database for CEDARS. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) , default: '0.1.0' ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def create_project ( project_name , investigator_name , cedars_version = \"0.1.0\" ): \"\"\" This function creates all the collections in the mongodb database for CEDARS. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" if mongo . db [ \"INFO\" ] . find_one () is not None : logger . info ( \"Database already created.\" ) return create_info_col ( project_name , investigator_name , cedars_version ) populate_annotations () populate_notes () populate_users () populate_query () logger . info ( \"Database creation successful!\" ) delete_annotation_date ( annotation_id ) Deletes the event date for an annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 692 693 694 695 696 697 698 699 700 701 702 703 def delete_annotation_date ( annotation_id ): \"\"\" Deletes the event date for an annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Deleting date on annotation # { ObjectId ( annotation_id ) } .\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"event_date\" : None } }) drop_database ( name ) Clean Database Source code in cedars/app/db.py 816 817 818 def drop_database ( name ): \"\"\"Clean Database\"\"\" mongo . cx . drop_database ( name ) empty_annotations () Deletes all annotations from the database Source code in cedars/app/db.py 805 806 807 808 809 810 811 812 813 def empty_annotations (): \"\"\" Deletes all annotations from the database \"\"\" logger . info ( \"Deleting all data in annotations collection.\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . delete_many ({}) mongo . db [ \"PINES\" ] . delete_many ({}) get_all_annotations () Returns a list of all annotations from the database. Returns: Annotations (list) : This is a list of all annotations from the database. Source code in cedars/app/db.py 498 499 500 501 502 503 504 505 506 507 508 509 def get_all_annotations (): \"\"\" Returns a list of all annotations from the database. Args: None Returns: Annotations (list) : This is a list of all annotations from the database. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find () return list ( annotations ) get_all_annotations_for_note ( note_id ) This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 290 291 292 293 294 295 296 297 298 299 300 def get_all_annotations_for_note ( note_id ): \"\"\" This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ),( \"setence_number\" , 1 )]) return list ( annotations ) get_all_notes ( patient_id ) Returns all notes for that patient. Source code in cedars/app/db.py 596 597 598 599 600 601 def get_all_notes ( patient_id ): \"\"\" Returns all notes for that patient. \"\"\" notes = mongo . db [ \"NOTES\" ] . find ({ \"patient_id\" : patient_id }) return list ( notes ) get_all_patients () Returns all the patients in this project Returns: patients (list) : List of all patients in this project Source code in cedars/app/db.py 553 554 555 556 557 558 559 560 561 562 563 564 def get_all_patients (): \"\"\" Returns all the patients in this project Args: None Returns: patients (list) : List of all patients in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find () return list ( patients ) get_annotated_notes_for_patient ( patient_id ) For a given patient, list all note_ids which have matching keyword annotations Parameters: patient_id ( int) ) \u2013 The patient_id for which we want to retrieve the annotated notes Returns: list [ str ] \u2013 notes (list[str]) : List of note_ids for the patient which have matching keyword annotations Source code in cedars/app/db.py 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def get_annotated_notes_for_patient ( patient_id : int ) -> list [ str ]: \"\"\" For a given patient, list all note_ids which have matching keyword annotations Args: patient_id (int) : The patient_id for which we want to retrieve the annotated notes Returns: notes (list[str]) : List of note_ids for the patient which have matching keyword annotations \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) notes = set () for annotation in annotations : notes . add ( annotation [ \"note_id\" ]) return list ( notes ) get_annotation ( annotation_id ) Retrives annotation from mongodb. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def get_annotation ( annotation_id ): \"\"\" Retrives annotation from mongodb. Args: annotation_id (str) : Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id ) }) return annotation get_annotation_date ( annotation_id ) Retrives the event date for an annotation. Source code in cedars/app/db.py 438 439 440 441 442 443 444 445 446 def get_annotation_date ( annotation_id ): \"\"\" Retrives the event date for an annotation. \"\"\" logger . debug ( f \"Retriving date on annotation # { ObjectId ( annotation_id ) } .\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) if \"event_date\" in annotation . keys (): return annotation [ \"event_date\" ] return None get_annotation_note ( annotation_id ) Retrives note linked to a paticular annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def get_annotation_note ( annotation_id ): \"\"\" Retrives note linked to a paticular annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving annotation # { annotation_id } from database.\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one_or_404 ({ \"_id\" : ObjectId ( annotation_id ) }) note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : annotation [ \"note_id\" ] }) return note get_curr_stats () Returns basic statistics for the project Source code in cedars/app/db.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 def get_curr_stats (): \"\"\" Returns basic statistics for the project \"\"\" stats = {} # Aggregation pipeline to count unique patients pipeline_unique_patients = [ { \"$group\" : { \"_id\" : \"$patient_id\" }} ] unique_patients = list ( mongo . db . PATIENTS . aggregate ( pipeline_unique_patients )) stats [ \"number_of_patients\" ] = len ( unique_patients ) pipeline_annotated_patients = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] annotated_patients = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_annotated_patients )) stats [ \"number_of_annotated_patients\" ] = len ( annotated_patients ) # Aggregation pipeline to count reviewed annotations pipeline_reviewed = [ { \"$match\" : { \"isNegated\" : False , \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] reviewed_annotations = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_reviewed )) stats [ \"number_of_reviewed\" ] = len ( reviewed_annotations ) # pipeline for notes and reviewed by user for notes with reviewed_by field pipeline_notes = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$reviewed_by\" , \"count\" : { \"$sum\" : 1 }}} ] reviewed_notes = list ( mongo . db . NOTES . aggregate ( pipeline_notes )) stats [ \"user_review_stats\" ] = { doc [ \"_id\" ]: doc [ \"count\" ] for doc in reviewed_notes } # Aggregation pipeline for lemma distribution pipeline_lemma_dist = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$token\" , \"count\" : { \"$sum\" : 1 }}}, { \"$sort\" : { \"count\" : - 1 }}, { \"$project\" : { \"token\" : \"$_id\" , \"_id\" : 0 , \"count\" : 1 }} ] lemma_dist_results = mongo . db . ANNOTATIONS . aggregate ( pipeline_lemma_dist ) stats [ 'lemma_dist' ] = { doc [ 'token' ]: doc [ 'count' ] for doc in lemma_dist_results } return stats get_curr_version () Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 525 526 527 528 529 530 531 532 533 534 535 536 537 def get_curr_version (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () return proj_info [ \"CEDARS_version\" ] get_documents_to_annotate () Retrives all documents that have not been annotated. Source code in cedars/app/db.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def get_documents_to_annotate (): \"\"\" Retrives all documents that have not been annotated. \"\"\" logger . debug ( \"Retriving all annotated documents from database.\" ) documents_to_annotate = mongo . db [ \"NOTES\" ] . aggregate ( [{ \"$lookup\" : { \"from\" : \"ANNOTATIONS\" , \"localField\" : \"text_id\" , \"foreignField\" : \"text_id\" , \"as\" : \"annotations\" } }, { \"$match\" : { \"annotations\" : { \"$eq\" : []} } }]) return documents_to_annotate get_event_date ( patient_id ) Find the event date from the annotations for a patient. Source code in cedars/app/db.py 449 450 451 452 453 454 455 456 457 458 459 460 def get_event_date ( patient_id ): \"\"\" Find the event date from the annotations for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id , \"event_date\" : { \"$ne\" : None }}) . sort ([( \"event_date\" , 1 )]) annotations = list ( annotations ) if len ( annotations ) > 0 : return annotations [ 0 ][ \"event_date\" ] return None get_first_note_date_for_patient ( patient_id ) Retrives the date of the first note for a patient. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. Source code in cedars/app/db.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get_first_note_date_for_patient ( patient_id ): \"\"\" Retrives the date of the first note for a patient. Args: patient_id (int) : Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. \"\"\" logger . debug ( f \"Retriving first note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , 1 )]) if not note : return None return note [ \"text_date\" ] get_info () This function returns the info collection in the mongodb database. Source code in cedars/app/db.py 284 285 286 287 288 def get_info (): \"\"\" This function returns the info collection in the mongodb database. \"\"\" return mongo . db . INFO . find_one_or_404 () get_last_note_date_for_patient ( patient_id ) Retrives the date of the last note for a patient. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. Source code in cedars/app/db.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def get_last_note_date_for_patient ( patient_id ): \"\"\" Retrives the date of the last note for a patient. Args: patient_id (int) : Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. \"\"\" logger . debug ( f \"Retriving last note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , - 1 )]) if not note : return None return note [ \"text_date\" ] get_note_prediction_from_db ( note_id , pines_collection_name = 'PINES' ) Retrieve the prediction score for a given from the database Parameters: pines_collection_name ( str , default: 'PINES' ) \u2013 The name of the collection in the database note_id ( str ) \u2013 The note_id for which we want to retrieve the prediction Returns: float ( Optional [ float ] ) \u2013 The prediction score for the note Source code in cedars/app/db.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 def get_note_prediction_from_db ( note_id : str , pines_collection_name : str = \"PINES\" ) -> Optional [ float ]: \"\"\" Retrieve the prediction score for a given from the database Args: pines_collection_name (str): The name of the collection in the database note_id (str): The note_id for which we want to retrieve the prediction Returns: float: The prediction score for the note \"\"\" pines_collection = mongo . db [ pines_collection_name ] query = { \"text_id\" : note_id } pines_pred = pines_collection . find_one ( query ) if pines_pred : logger . debug ( f \"Found prediction in db for : { note_id } : { pines_pred . get ( 'predicted_score' ) } \" ) return round ( pines_pred . get ( \"predicted_score\" ), 2 ) logger . debug ( f \"Prediction not found in db for : { note_id } \" ) return None get_patient () Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Returns: patient_id (int) : Unique ID for a patient. Source code in cedars/app/db.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def get_patient (): \"\"\" Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Args: None Returns: patient_id (int) : Unique ID for a patient. \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"reviewed\" : False , \"locked\" : False }) if patient is not None and \"patient_id\" in patient . keys (): logger . debug ( f \"Retriving patient # { patient [ 'patient_id' ] } from database.\" , ) return patient [ \"patient_id\" ] logger . info ( \"Failed to retrive any further un-reviewed patients from the database.\" ) return None get_patient_annotation_ids ( p_id , reviewed = False , key = '_id' ) Retrives all annotation IDs for annotations linked to a patient. Parameters: p_id ( int) ) \u2013 Unique ID for a patient. reviewed ( bool) , default: False ) \u2013 True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. Source code in cedars/app/db.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def get_patient_annotation_ids ( p_id , reviewed = False , key = \"_id\" ): \"\"\" Retrives all annotation IDs for annotations linked to a patient. Args: p_id (int) : Unique ID for a patient. reviewed (bool) : True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. \"\"\" logger . debug ( f \"Retriving annotations for patient # { p_id } from database.\" ) annotation_ids = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : p_id , \"reviewed\" : reviewed , \"isNegated\" : False }) . sort ([( \"note_id\" , 1 ), ( 'text_date' , 1 ), ( \"sentence_number\" , 1 )]) return [ str ( id [ key ]) for id in annotation_ids ] get_patient_by_id ( patient_id ) Retrives a single patient from mongodb. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def get_patient_by_id ( patient_id ): \"\"\" Retrives a single patient from mongodb. Args: patient_id (int) : Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving patient # { patient_id } from database.\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient get_patient_ids () Returns all the patient IDs in this project Returns: patient_ids (list) : List of all patient IDs in this project Source code in cedars/app/db.py 566 567 568 569 570 571 572 573 574 575 576 577 def get_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patient_ids (list) : List of all patient IDs in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find () return [ patient [ \"patient_id\" ] for patient in patients ] get_patient_lock_status ( patient_id ) Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Source code in cedars/app/db.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 def get_patient_lock_status ( patient_id ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Raises: None \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"locked\" ] get_patient_notes ( patient_id , reviewed = False ) Returns all notes for that patient. Parameters: patient_id ( int) ) \u2013 ID for the patient Returns: notes (list) : A list of all notes for that patient Source code in cedars/app/db.py 603 604 605 606 607 608 609 610 611 612 613 614 def get_patient_notes ( patient_id , reviewed = False ): \"\"\" Returns all notes for that patient. Args: patient_id (int) : ID for the patient Returns: notes (list) : A list of all notes for that patient \"\"\" mongodb_search_query = { \"patient_id\" : patient_id , \"reviewed\" : reviewed } notes = list ( mongo . db [ \"NOTES\" ] . find ( mongodb_search_query )) return notes get_patients_to_annotate () Retrieves a patient that have not been reviewed Returns: patient_to_annotate: A single patient that needs to manually reviewed Source code in cedars/app/db.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def get_patients_to_annotate (): \"\"\" Retrieves a patient that have not been reviewed Args: None Returns: patient_to_annotate: A single patient that needs to manually reviewed \"\"\" logger . debug ( \"Retriving all un-reviewed patients from database.\" ) patients_to_annotate = mongo . db [ \"PATIENTS\" ] . find ({ \"reviewed\" : False , \"locked\" : False }) # check is this patient has any unreviewed annotations for patient in patients_to_annotate : patient_id = patient [ \"patient_id\" ] annotations = get_patient_annotation_ids ( patient_id ) if len ( annotations ) > 0 : return patient_id else : continue return None get_prediction ( note ) PINES predictions Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" url = f ' { os . getenv ( \"PINES_API_URL\" ) } /predict' data = { 'text' : note } try : response = requests . post ( url , json = data , timeout = 20 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score logger . debug ( f \"Got prediction for note: { note } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { note } \" ) raise e get_proj_name () Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 511 512 513 514 515 516 517 518 519 520 521 522 523 def get_proj_name (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one_or_404 () proj_name = proj_info [ \"project\" ] return proj_name get_project_users () Returns all the usernames for approved users (including the admin) for this project Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project Source code in cedars/app/db.py 539 540 541 542 543 544 545 546 547 548 549 550 551 def get_project_users (): \"\"\" Returns all the usernames for approved users (including the admin) for this project Args: None Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project \"\"\" users = mongo . db [ \"USERS\" ] . find ({}) return [ user [ \"user\" ] for user in users ] get_search_query () This function is used to get the current search query from the database. All this data is kept in the QUERY collection. Source code in cedars/app/db.py 272 273 274 275 276 277 278 279 280 281 282 def get_search_query (): \"\"\" This function is used to get the current search query from the database. All this data is kept in the QUERY collection. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : return query [ \"query\" ] return \"\" get_total_counts ( collection_name ) Returns the total number of documents in a collection. Parameters: collection_name ( str) ) \u2013 The name of the collection to search. Returns: count (int) : The number of documents in the collection. Source code in cedars/app/db.py 616 617 618 619 620 621 622 623 624 625 def get_total_counts ( collection_name : str ) -> int : \"\"\" Returns the total number of documents in a collection. Args: collection_name (str) : The name of the collection to search. Returns: count (int) : The number of documents in the collection. \"\"\" return mongo . db [ collection_name ] . count_documents ({}) get_user ( username ) This function is used to get a user from the database. Parameters: username ( str) ) \u2013 The name of the user to get. Returns: user (dict) : The user object from the database. Source code in cedars/app/db.py 260 261 262 263 264 265 266 267 268 269 270 def get_user ( username ): \"\"\" This function is used to get a user from the database. Args: username (str) : The name of the user to get. Returns: user (dict) : The user object from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return user insert_one_annotation ( annotation ) Adds an annotation to the database. Parameters: annotation ( dict) ) \u2013 The annotation we are inserting Returns: None Source code in cedars/app/db.py 246 247 248 249 250 251 252 253 254 255 256 257 def insert_one_annotation ( annotation ): \"\"\" Adds an annotation to the database. Args: annotation (dict) : The annotation we are inserting Returns: None \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] annotations_collection . insert_one ( annotation ) is_admin_user ( username ) check if the user is admin Source code in cedars/app/db.py 837 838 839 840 841 842 843 844 def is_admin_user ( username ): \"\"\"check if the user is admin\"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ 'user' : username }) if user is not None and user [ \"is_admin\" ]: return True return False mark_annotation_reviewed ( annotation_id ) Updates the annotation in the database to mark it as reviewed. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 661 662 663 664 665 666 667 668 669 670 671 672 def mark_annotation_reviewed ( annotation_id ): \"\"\" Updates the annotation in the database to mark it as reviewed. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Marking annotation # { annotation_id } as reviewed.\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"reviewed\" : True } }) mark_note_reviewed ( note_id , reviewed_by ) Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 722 723 724 725 726 727 728 729 def mark_note_reviewed ( note_id , reviewed_by : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" logger . debug ( f \"Marking note # { note_id } as reviewed.\" ) mongo . db [ \"NOTES\" ] . update_one ({ \"text_id\" : note_id }, { \"$set\" : { \"reviewed\" : True , \"reviewed_by\" : reviewed_by } }) mark_patient_reviewed ( patient_id , reviewed_by , is_reviewed = True ) Updates the patient's status to reviewed in the database. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. reviewed_by ( str) ) \u2013 The name of the user who reviewed the patient. is_reviewed ( bool) , default: True ) \u2013 True if patient's annotations have been reviewed. Returns: None Source code in cedars/app/db.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 def mark_patient_reviewed ( patient_id , reviewed_by : str , is_reviewed = True ): \"\"\" Updates the patient's status to reviewed in the database. Args: patient_id (int) : Unique ID for a patient. reviewed_by (str) : The name of the user who reviewed the patient. is_reviewed (bool) : True if patient's annotations have been reviewed. Returns: None \"\"\" logger . debug ( f \"Marking patient # { patient_id } as reviewed.\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"reviewed\" : is_reviewed , \"reviewed_by\" : reviewed_by } }) populate_annotations () This function creates the annotations and patients collections in the mongodb database. The annotations collection is used to store the NLP annotations generated by our NLP model. The patients collection is used to store the patient ids as well as their current status. Source code in cedars/app/db.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def populate_annotations (): \"\"\" This function creates the annotations and patients collections in the mongodb database. The annotations collection is used to store the NLP annotations generated by our NLP model. The patients collection is used to store the patient ids as well as their current status. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . create_index ( \"patient_id\" , unique = False ) annotations . create_index ( \"note_id\" , unique = False ) annotations . create_index ( \"text_id\" , unique = False ) annotations . create_index ( \"sentence_number\" , unique = False ) annotations . create_index ( \"start_index\" , unique = False ) logger . info ( \"Created ANNOTATIONS collection.\" ) # This statement is used to create a collection. patients = mongo . db [ \"PATIENTS\" ] logger . info ( f \"Created { patients . name } collection.\" ) populate_notes () This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. Source code in cedars/app/db.py 88 89 90 91 92 93 94 95 96 97 98 99 def populate_notes (): \"\"\" This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. \"\"\" notes = mongo . db [ \"NOTES\" ] notes . create_index ( \"patient_id\" , unique = False ) notes . create_index ( \"doc_id\" , unique = False ) notes . create_index ( \"text_id\" , unique = True ) logger . info ( \"Created NOTES collection.\" ) populate_patients () This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. Source code in cedars/app/db.py 101 102 103 104 105 106 107 108 109 110 def populate_patients (): \"\"\" This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. \"\"\" notes = mongo . db [ \"Patients\" ] notes . create_index ( \"patient_id\" , unique = True ) logger . info ( \"Created Patients collection.\" ) populate_query () This function creates the query collection in the mongodb database. The query collection is used to store the regex queries that researchrs are using. Source code in cedars/app/db.py 122 123 124 125 126 127 128 129 130 def populate_query (): \"\"\" This function creates the query collection in the mongodb database. The query collection is used to store the regex queries that researchrs are using. \"\"\" # Pylint disabled for pointless statement. # This statement is used to create a collection. query = mongo . db [ \"QUERY\" ] logger . info ( \"Created %s collection.\" , query . name ) populate_users () This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. Source code in cedars/app/db.py 112 113 114 115 116 117 118 119 120 def populate_users (): \"\"\" This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. \"\"\" users = mongo . db [ \"USERS\" ] users . create_index ( \"user\" , unique = True ) logger . info ( \"Created USERS collection.\" ) predict_and_save ( text_ids = None , note_collection_name = 'NOTES' , pines_collection_name = 'PINES' , force_update = False ) Save PINES predictions Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) }) remove_all_locked () Sets the locked status of all patients to False. This is done when the server is shutting down. Source code in cedars/app/db.py 780 781 782 783 784 785 786 787 def remove_all_locked (): \"\"\" Sets the locked status of all patients to False. This is done when the server is shutting down. \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_many ({}, { \"$set\" : { \"locked\" : False } }) reset_patient_reviewed () Update all patients, notes to be un-reviewed. Source code in cedars/app/db.py 730 731 732 733 734 735 736 737 738 def reset_patient_reviewed (): \"\"\" Update all patients, notes to be un-reviewed. \"\"\" mongo . db [ \"PATIENTS\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" , \"comments\" : [] } }) mongo . db [ \"NOTES\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False } }) save_query ( query , exclude_negated , hide_duplicates , skip_after_event , tag_query , date_min = None , date_max = None ) This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Parameters: query ( str) ) \u2013 The regex query. exclude_negated ( bool) ) \u2013 True if we want to exclude negated tokens. hide_duplicates ( bool) ) \u2013 True if we want to restrict duplicate queries. skip_after_event ( bool) ) \u2013 True if sentences occurring after a recorded clinical event are to be skipped. tag_query ( dict of mapping [str ) \u2013 list]) : Key words to include or exclude in the search. date_min ( str) , default: None ) \u2013 Smallest date for valid query. date_max ( str) , default: None ) \u2013 Greatest date for valid query. Returns: None Source code in cedars/app/db.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def save_query ( query , exclude_negated , hide_duplicates , #pylint: disable=R0913 skip_after_event , tag_query , date_min = None , date_max = None ): \"\"\" This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Args: query (str) : The regex query. exclude_negated (bool) : True if we want to exclude negated tokens. hide_duplicates (bool) : True if we want to restrict duplicate queries. skip_after_event (bool) : True if sentences occurring after a recorded clinical event are to be skipped. tag_query (dict of mapping [str : list]) : Key words to include or exclude in the search. date_min (str) : Smallest date for valid query. date_max (str) : Greatest date for valid query. Returns: None \"\"\" info = { \"query\" : query , \"exclude_negated\" : exclude_negated , \"hide_duplicates\" : hide_duplicates , \"skip_after_event\" : skip_after_event , \"tag_query\" : tag_query , \"date_min\" : date_min , \"date_max\" : date_max } collection = mongo . db [ \"QUERY\" ] # only one query is current at a time. # TODO: make a query history and enable multiple queries. info [ \"current\" ] = True collection . update_one ({ \"current\" : True }, { \"$set\" : { \"current\" : False }}) collection . insert_one ( info ) logger . info ( f \"Saved query : { query } .\" ) set_patient_lock_status ( patient_id , status ) Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking status ( bool) ) \u2013 True if the patient is being locked, False otherwise. Returns: \u2013 None Source code in cedars/app/db.py 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 def set_patient_lock_status ( patient_id , status ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking status (bool) : True if the patient is being locked, False otherwise. Returns: None \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"locked\" : status } }) terminate_project () Terminate the Project Reset the database to the initial state. Source code in cedars/app/db.py 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) create_project ( project_name = fake . slug (), investigator_name = fake . name ()) update_annotation_date ( annotation_id , new_date ) Enters a new event date for an annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. new_date ( str) ) \u2013 The new value to update the event date of an annotation with. Must be in the format YYYY-MM-DD . Returns: None Source code in cedars/app/db.py 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def update_annotation_date ( annotation_id , new_date ): \"\"\" Enters a new event date for an annotation. Args: annotation_id (str) : Unique ID for the annotation. new_date (str) : The new value to update the event date of an annotation with. Must be in the format YYYY-MM-DD . Returns: None \"\"\" # TODO: UTC dates logger . debug ( f \"Updating date on annotation # { annotation_id } to { new_date } .\" ) date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( new_date , date_format ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"event_date\" : datetime_obj } }) update_annotation_reviewed ( note_id ) Mark all annotations for a note as reviewed. Parameters: note_id ( str) ) \u2013 The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. Source code in cedars/app/db.py 790 791 792 793 794 795 796 797 798 799 800 801 802 def update_annotation_reviewed ( note_id : str ) -> int : \"\"\" Mark all annotations for a note as reviewed. Args: note_id (str) : The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] result = annotations_collection . update_many ({ \"note_id\" : note_id }, { \"$set\" : { \"reviewed\" : True }}) return result . modified_count update_project_name ( new_name ) Updates the project name in the INFO collection of the database. Parameters: new_name ( str) ) \u2013 New name of the project. Returns: None Source code in cedars/app/db.py 649 650 651 652 653 654 655 656 657 658 659 def update_project_name ( new_name ): \"\"\" Updates the project name in the INFO collection of the database. Args: new_name (str) : New name of the project. Returns: None \"\"\" logger . info ( f \"Updating project name to # { new_name } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"project\" : new_name } }) upload_notes ( documents ) This function is used to take a dataframe of patient records and save it to the mongodb database. Parameters: documents ( pandas dataframe) ) \u2013 Dataframe with all the records of a paticular patient. Returns: None Source code in cedars/app/db.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def upload_notes ( documents ): \"\"\" This function is used to take a dataframe of patient records and save it to the mongodb database. Args: documents (pandas dataframe) : Dataframe with all the records of a paticular patient. Returns: None \"\"\" notes_collection = mongo . db [ \"NOTES\" ] patient_ids = set () for i in range ( len ( documents )): note_info = documents . iloc [ i ] . to_dict () date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( note_info [ \"text_date\" ], date_format ) note_info [ \"text_date\" ] = datetime_obj note_info [ \"reviewed\" ] = False # text_id should be unique notes_collection . insert_one ( note_info ) patient_ids . add ( note_info [ \"patient_id\" ]) if i + 1 % 10 == 0 : logger . info ( f \"Uploaded { i } / { len ( documents ) } notes\" ) patients_collection = mongo . db [ \"PATIENTS\" ] for p_id in patient_ids : patient_info = { \"patient_id\" : p_id , \"reviewed\" : False , \"locked\" : False , \"updated\" : False , \"admin_locked\" : False } if not patients_collection . find_one ({ \"patient_id\" : p_id }): patients_collection . insert_one ( patient_info )","title":"Querying the Database"},{"location":"query_database/#querying-the-database","text":"To search for medical events using CEDARS you will need to write a regex query. For more information regarding these queries, you can refer to the Basic Concepts section of the documentation. After you enter a query, click submit and the NLP algorithm will run on the database and save instances of the event when it is found. After the database has been searched, you will be redirected to the Adjudications page where you can view the search results.","title":"Querying the Database"},{"location":"query_database/#important-note","text":"Keep in mind that entering a new query will erase all records of the prior query and so you are advised to download a copy of the results of prior queries before entering a new one.","title":"Important Note"},{"location":"query_database/#reference","text":"This file contatins an abstract class for CEDARS to interact with mongodb.","title":"Reference"},{"location":"query_database/#cedars.app.ops.db.add_comment","text":"Stores a new comment for a patient. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. comment ( str) ) \u2013 Text of the comment on this annotation. Returns: None Source code in cedars/app/db.py 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def add_comment ( annotation_id , comment ): \"\"\" Stores a new comment for a patient. Args: annotation_id (str) : Unique ID for the annotation. comment (str) : Text of the comment on this annotation. Returns: None \"\"\" if len ( comment ) == 0 : logger . info ( \"No comment entered.\" ) return logger . debug ( f \"Adding comment to annotation # { annotation_id } \" ) patient_id = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )})[ \"patient_id\" ] patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) comments = patient [ \"comments\" ] comments . append ( comment ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"comments\" : comments } })","title":"add_comment"},{"location":"query_database/#cedars.app.ops.db.add_project_user","text":"Adds a new user to the project database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The user's password is_admin ( bool) , default: False ) \u2013 True if the new user is the project admin (used when initializing the project) Returns: None Source code in cedars/app/db.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def add_project_user ( username , password , is_admin = False ): \"\"\" Adds a new user to the project database. Args: username (str) : The name of the new user password (str) : The user's password is_admin (bool) : True if the new user is the project admin (used when initializing the project) Returns: None \"\"\" password_hash = generate_password_hash ( password ) data = { \"user\" : username , \"password\" : password_hash , \"admin\" : is_admin } mongo . db [ \"USERS\" ] . insert_one ( data . copy ())","title":"add_project_user"},{"location":"query_database/#cedars.app.ops.db.add_user","text":"This function is used to add a new user to the database. All this data is kept in the USERS collection. Parameters: username ( str) ) \u2013 The name of this user. password ( str) ) \u2013 The password this user will need to login to the system. Returns: None Source code in cedars/app/db.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def add_user ( username , password , is_admin = False ): \"\"\" This function is used to add a new user to the database. All this data is kept in the USERS collection. Args: username (str) : The name of this user. password (str) : The password this user will need to login to the system. Returns: None \"\"\" info = { \"user\" : username , \"password\" : password , \"is_admin\" : is_admin , \"date_created\" : datetime . now () } mongo . db [ \"USERS\" ] . insert_one ( info ) logger . info ( f \"Added user { username } to database.\" )","title":"add_user"},{"location":"query_database/#cedars.app.ops.db.check_password","text":"Checks if the password matches the password of that user from the database. Parameters: username ( str) ) \u2013 The name of the new user password ( str) ) \u2013 The password entered by the user. Returns: \u2013 (bool) : True if the password matches the password of that user from the database. Source code in cedars/app/db.py 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 def check_password ( username , password ): \"\"\" Checks if the password matches the password of that user from the database. Args: username (str) : The name of the new user password (str) : The password entered by the user. Returns: (bool) : True if the password matches the password of that user from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return \"password\" in user and check_password_hash ( user [ \"password\" ], password )","title":"check_password"},{"location":"query_database/#cedars.app.ops.db.create_info_col","text":"This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def create_info_col ( project_name , investigator_name , cedars_version ): \"\"\" This function creates the info collection in the mongodb database. The info collection is used to store meta-data regarding the current project. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" collection = mongo . db [ \"INFO\" ] info = { \"creation_time\" : datetime . now (), \"project\" : project_name , \"investigator\" : investigator_name , \"CEDARS_version\" : cedars_version } collection . insert_one ( info ) logger . info ( \"Created INFO collection.\" )","title":"create_info_col"},{"location":"query_database/#cedars.app.ops.db.create_project","text":"This function creates all the collections in the mongodb database for CEDARS. Parameters: project_name ( str) ) \u2013 Name of the research project investigator_name ( str) ) \u2013 Name of the investigator on this project cedars_version ( str) , default: '0.1.0' ) \u2013 Version of CEDARS used for this project Returns: None Source code in cedars/app/db.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def create_project ( project_name , investigator_name , cedars_version = \"0.1.0\" ): \"\"\" This function creates all the collections in the mongodb database for CEDARS. Args: project_name (str) : Name of the research project investigator_name (str) : Name of the investigator on this project cedars_version (str) : Version of CEDARS used for this project Returns: None \"\"\" if mongo . db [ \"INFO\" ] . find_one () is not None : logger . info ( \"Database already created.\" ) return create_info_col ( project_name , investigator_name , cedars_version ) populate_annotations () populate_notes () populate_users () populate_query () logger . info ( \"Database creation successful!\" )","title":"create_project"},{"location":"query_database/#cedars.app.ops.db.delete_annotation_date","text":"Deletes the event date for an annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 692 693 694 695 696 697 698 699 700 701 702 703 def delete_annotation_date ( annotation_id ): \"\"\" Deletes the event date for an annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Deleting date on annotation # { ObjectId ( annotation_id ) } .\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"event_date\" : None } })","title":"delete_annotation_date"},{"location":"query_database/#cedars.app.ops.db.drop_database","text":"Clean Database Source code in cedars/app/db.py 816 817 818 def drop_database ( name ): \"\"\"Clean Database\"\"\" mongo . cx . drop_database ( name )","title":"drop_database"},{"location":"query_database/#cedars.app.ops.db.empty_annotations","text":"Deletes all annotations from the database Source code in cedars/app/db.py 805 806 807 808 809 810 811 812 813 def empty_annotations (): \"\"\" Deletes all annotations from the database \"\"\" logger . info ( \"Deleting all data in annotations collection.\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . delete_many ({}) mongo . db [ \"PINES\" ] . delete_many ({})","title":"empty_annotations"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations","text":"Returns a list of all annotations from the database. Returns: Annotations (list) : This is a list of all annotations from the database. Source code in cedars/app/db.py 498 499 500 501 502 503 504 505 506 507 508 509 def get_all_annotations (): \"\"\" Returns a list of all annotations from the database. Args: None Returns: Annotations (list) : This is a list of all annotations from the database. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find () return list ( annotations )","title":"get_all_annotations"},{"location":"query_database/#cedars.app.ops.db.get_all_annotations_for_note","text":"This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) Source code in cedars/app/db.py 290 291 292 293 294 295 296 297 298 299 300 def get_all_annotations_for_note ( note_id ): \"\"\" This function is used to get all the annotations for a particular note after removing negated annotations. Order of annotations - text_date (ascending) note_start_index (ascending) \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"note_id\" : note_id , \"isNegated\" : False }) . sort ([( \"text_date\" , 1 ),( \"setence_number\" , 1 )]) return list ( annotations )","title":"get_all_annotations_for_note"},{"location":"query_database/#cedars.app.ops.db.get_all_notes","text":"Returns all notes for that patient. Source code in cedars/app/db.py 596 597 598 599 600 601 def get_all_notes ( patient_id ): \"\"\" Returns all notes for that patient. \"\"\" notes = mongo . db [ \"NOTES\" ] . find ({ \"patient_id\" : patient_id }) return list ( notes )","title":"get_all_notes"},{"location":"query_database/#cedars.app.ops.db.get_all_patients","text":"Returns all the patients in this project Returns: patients (list) : List of all patients in this project Source code in cedars/app/db.py 553 554 555 556 557 558 559 560 561 562 563 564 def get_all_patients (): \"\"\" Returns all the patients in this project Args: None Returns: patients (list) : List of all patients in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find () return list ( patients )","title":"get_all_patients"},{"location":"query_database/#cedars.app.ops.db.get_annotated_notes_for_patient","text":"For a given patient, list all note_ids which have matching keyword annotations Parameters: patient_id ( int) ) \u2013 The patient_id for which we want to retrieve the annotated notes Returns: list [ str ] \u2013 notes (list[str]) : List of note_ids for the patient which have matching keyword annotations Source code in cedars/app/db.py 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def get_annotated_notes_for_patient ( patient_id : int ) -> list [ str ]: \"\"\" For a given patient, list all note_ids which have matching keyword annotations Args: patient_id (int) : The patient_id for which we want to retrieve the annotated notes Returns: notes (list[str]) : List of note_ids for the patient which have matching keyword annotations \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id }) notes = set () for annotation in annotations : notes . add ( annotation [ \"note_id\" ]) return list ( notes )","title":"get_annotated_notes_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_annotation","text":"Retrives annotation from mongodb. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def get_annotation ( annotation_id ): \"\"\" Retrives annotation from mongodb. Args: annotation_id (str) : Unique ID for the annotation. Returns: annotation (dict) : Dictionary for an annotation from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id ) }) return annotation","title":"get_annotation"},{"location":"query_database/#cedars.app.ops.db.get_annotation_date","text":"Retrives the event date for an annotation. Source code in cedars/app/db.py 438 439 440 441 442 443 444 445 446 def get_annotation_date ( annotation_id ): \"\"\" Retrives the event date for an annotation. \"\"\" logger . debug ( f \"Retriving date on annotation # { ObjectId ( annotation_id ) } .\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one ({ \"_id\" : ObjectId ( annotation_id )}) if \"event_date\" in annotation . keys (): return annotation [ \"event_date\" ] return None","title":"get_annotation_date"},{"location":"query_database/#cedars.app.ops.db.get_annotation_note","text":"Retrives note linked to a paticular annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 def get_annotation_note ( annotation_id ): \"\"\" Retrives note linked to a paticular annotation. Args: annotation_id (str) : Unique ID for the annotation. Returns: note (dict) : Dictionary for a note from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving annotation # { annotation_id } from database.\" ) annotation = mongo . db [ \"ANNOTATIONS\" ] . find_one_or_404 ({ \"_id\" : ObjectId ( annotation_id ) }) note = mongo . db [ \"NOTES\" ] . find_one ({ \"text_id\" : annotation [ \"note_id\" ] }) return note","title":"get_annotation_note"},{"location":"query_database/#cedars.app.ops.db.get_curr_stats","text":"Returns basic statistics for the project Source code in cedars/app/db.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 def get_curr_stats (): \"\"\" Returns basic statistics for the project \"\"\" stats = {} # Aggregation pipeline to count unique patients pipeline_unique_patients = [ { \"$group\" : { \"_id\" : \"$patient_id\" }} ] unique_patients = list ( mongo . db . PATIENTS . aggregate ( pipeline_unique_patients )) stats [ \"number_of_patients\" ] = len ( unique_patients ) pipeline_annotated_patients = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] annotated_patients = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_annotated_patients )) stats [ \"number_of_annotated_patients\" ] = len ( annotated_patients ) # Aggregation pipeline to count reviewed annotations pipeline_reviewed = [ { \"$match\" : { \"isNegated\" : False , \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$patient_id\" }} ] reviewed_annotations = list ( mongo . db . ANNOTATIONS . aggregate ( pipeline_reviewed )) stats [ \"number_of_reviewed\" ] = len ( reviewed_annotations ) # pipeline for notes and reviewed by user for notes with reviewed_by field pipeline_notes = [ { \"$match\" : { \"reviewed\" : True }}, { \"$group\" : { \"_id\" : \"$reviewed_by\" , \"count\" : { \"$sum\" : 1 }}} ] reviewed_notes = list ( mongo . db . NOTES . aggregate ( pipeline_notes )) stats [ \"user_review_stats\" ] = { doc [ \"_id\" ]: doc [ \"count\" ] for doc in reviewed_notes } # Aggregation pipeline for lemma distribution pipeline_lemma_dist = [ { \"$match\" : { \"isNegated\" : False }}, { \"$group\" : { \"_id\" : \"$token\" , \"count\" : { \"$sum\" : 1 }}}, { \"$sort\" : { \"count\" : - 1 }}, { \"$project\" : { \"token\" : \"$_id\" , \"_id\" : 0 , \"count\" : 1 }} ] lemma_dist_results = mongo . db . ANNOTATIONS . aggregate ( pipeline_lemma_dist ) stats [ 'lemma_dist' ] = { doc [ 'token' ]: doc [ 'count' ] for doc in lemma_dist_results } return stats","title":"get_curr_stats"},{"location":"query_database/#cedars.app.ops.db.get_curr_version","text":"Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 525 526 527 528 529 530 531 532 533 534 535 536 537 def get_curr_version (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one () return proj_info [ \"CEDARS_version\" ]","title":"get_curr_version"},{"location":"query_database/#cedars.app.ops.db.get_documents_to_annotate","text":"Retrives all documents that have not been annotated. Source code in cedars/app/db.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 def get_documents_to_annotate (): \"\"\" Retrives all documents that have not been annotated. \"\"\" logger . debug ( \"Retriving all annotated documents from database.\" ) documents_to_annotate = mongo . db [ \"NOTES\" ] . aggregate ( [{ \"$lookup\" : { \"from\" : \"ANNOTATIONS\" , \"localField\" : \"text_id\" , \"foreignField\" : \"text_id\" , \"as\" : \"annotations\" } }, { \"$match\" : { \"annotations\" : { \"$eq\" : []} } }]) return documents_to_annotate","title":"get_documents_to_annotate"},{"location":"query_database/#cedars.app.ops.db.get_event_date","text":"Find the event date from the annotations for a patient. Source code in cedars/app/db.py 449 450 451 452 453 454 455 456 457 458 459 460 def get_event_date ( patient_id ): \"\"\" Find the event date from the annotations for a patient. \"\"\" logger . debug ( f \"Retriving event date for patient # { patient_id } .\" ) annotations = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : patient_id , \"event_date\" : { \"$ne\" : None }}) . sort ([( \"event_date\" , 1 )]) annotations = list ( annotations ) if len ( annotations ) > 0 : return annotations [ 0 ][ \"event_date\" ] return None","title":"get_event_date"},{"location":"query_database/#cedars.app.ops.db.get_first_note_date_for_patient","text":"Retrives the date of the first note for a patient. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. Source code in cedars/app/db.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def get_first_note_date_for_patient ( patient_id ): \"\"\" Retrives the date of the first note for a patient. Args: patient_id (int) : Unique ID for a patient. Returns: note_date (datetime) : The date of the first note for the patient. \"\"\" logger . debug ( f \"Retriving first note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , 1 )]) if not note : return None return note [ \"text_date\" ]","title":"get_first_note_date_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_info","text":"This function returns the info collection in the mongodb database. Source code in cedars/app/db.py 284 285 286 287 288 def get_info (): \"\"\" This function returns the info collection in the mongodb database. \"\"\" return mongo . db . INFO . find_one_or_404 ()","title":"get_info"},{"location":"query_database/#cedars.app.ops.db.get_last_note_date_for_patient","text":"Retrives the date of the last note for a patient. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. Source code in cedars/app/db.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 def get_last_note_date_for_patient ( patient_id ): \"\"\" Retrives the date of the last note for a patient. Args: patient_id (int) : Unique ID for a patient. Returns: note_date (datetime) : The date of the last note for the patient. \"\"\" logger . debug ( f \"Retriving last note date for patient # { patient_id } .\" ) note = mongo . db [ \"NOTES\" ] . find_one ({ \"patient_id\" : patient_id }, sort = [( \"text_date\" , - 1 )]) if not note : return None return note [ \"text_date\" ]","title":"get_last_note_date_for_patient"},{"location":"query_database/#cedars.app.ops.db.get_note_prediction_from_db","text":"Retrieve the prediction score for a given from the database Parameters: pines_collection_name ( str , default: 'PINES' ) \u2013 The name of the collection in the database note_id ( str ) \u2013 The note_id for which we want to retrieve the prediction Returns: float ( Optional [ float ] ) \u2013 The prediction score for the note Source code in cedars/app/db.py 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 def get_note_prediction_from_db ( note_id : str , pines_collection_name : str = \"PINES\" ) -> Optional [ float ]: \"\"\" Retrieve the prediction score for a given from the database Args: pines_collection_name (str): The name of the collection in the database note_id (str): The note_id for which we want to retrieve the prediction Returns: float: The prediction score for the note \"\"\" pines_collection = mongo . db [ pines_collection_name ] query = { \"text_id\" : note_id } pines_pred = pines_collection . find_one ( query ) if pines_pred : logger . debug ( f \"Found prediction in db for : { note_id } : { pines_pred . get ( 'predicted_score' ) } \" ) return round ( pines_pred . get ( \"predicted_score\" ), 2 ) logger . debug ( f \"Prediction not found in db for : { note_id } \" ) return None","title":"get_note_prediction_from_db"},{"location":"query_database/#cedars.app.ops.db.get_patient","text":"Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Returns: patient_id (int) : Unique ID for a patient. Source code in cedars/app/db.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def get_patient (): \"\"\" Retrives a single patient ID who has not yet been reviewed and is not currently locked. The chosen patient is simply the first one in the database that has not yet been reviewed. Args: None Returns: patient_id (int) : Unique ID for a patient. \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"reviewed\" : False , \"locked\" : False }) if patient is not None and \"patient_id\" in patient . keys (): logger . debug ( f \"Retriving patient # { patient [ 'patient_id' ] } from database.\" , ) return patient [ \"patient_id\" ] logger . info ( \"Failed to retrive any further un-reviewed patients from the database.\" ) return None","title":"get_patient"},{"location":"query_database/#cedars.app.ops.db.get_patient_annotation_ids","text":"Retrives all annotation IDs for annotations linked to a patient. Parameters: p_id ( int) ) \u2013 Unique ID for a patient. reviewed ( bool) , default: False ) \u2013 True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. Source code in cedars/app/db.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def get_patient_annotation_ids ( p_id , reviewed = False , key = \"_id\" ): \"\"\" Retrives all annotation IDs for annotations linked to a patient. Args: p_id (int) : Unique ID for a patient. reviewed (bool) : True if we want to get reviewed annotations. Returns: annotations (list) : A list of all annotation IDs linked to that patient. \"\"\" logger . debug ( f \"Retriving annotations for patient # { p_id } from database.\" ) annotation_ids = mongo . db [ \"ANNOTATIONS\" ] . find ({ \"patient_id\" : p_id , \"reviewed\" : reviewed , \"isNegated\" : False }) . sort ([( \"note_id\" , 1 ), ( 'text_date' , 1 ), ( \"sentence_number\" , 1 )]) return [ str ( id [ key ]) for id in annotation_ids ]","title":"get_patient_annotation_ids"},{"location":"query_database/#cedars.app.ops.db.get_patient_by_id","text":"Retrives a single patient from mongodb. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. Source code in cedars/app/db.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def get_patient_by_id ( patient_id ): \"\"\" Retrives a single patient from mongodb. Args: patient_id (int) : Unique ID for a patient. Returns: patient (dict) : Dictionary for a patient from mongodb. The keys are the attribute names. The values are the values of the attribute in that record. \"\"\" logger . debug ( f \"Retriving patient # { patient_id } from database.\" ) patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient","title":"get_patient_by_id"},{"location":"query_database/#cedars.app.ops.db.get_patient_ids","text":"Returns all the patient IDs in this project Returns: patient_ids (list) : List of all patient IDs in this project Source code in cedars/app/db.py 566 567 568 569 570 571 572 573 574 575 576 577 def get_patient_ids (): \"\"\" Returns all the patient IDs in this project Args: None Returns: patient_ids (list) : List of all patient IDs in this project \"\"\" patients = mongo . db [ \"PATIENTS\" ] . find () return [ patient [ \"patient_id\" ] for patient in patients ]","title":"get_patient_ids"},{"location":"query_database/#cedars.app.ops.db.get_patient_lock_status","text":"Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Source code in cedars/app/db.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 def get_patient_lock_status ( patient_id ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking Returns: status (bool) : True if the patient is locked, False otherwise. If no such patient is found, we return None. Raises: None \"\"\" patient = mongo . db [ \"PATIENTS\" ] . find_one ({ \"patient_id\" : patient_id }) return patient [ \"locked\" ]","title":"get_patient_lock_status"},{"location":"query_database/#cedars.app.ops.db.get_patient_notes","text":"Returns all notes for that patient. Parameters: patient_id ( int) ) \u2013 ID for the patient Returns: notes (list) : A list of all notes for that patient Source code in cedars/app/db.py 603 604 605 606 607 608 609 610 611 612 613 614 def get_patient_notes ( patient_id , reviewed = False ): \"\"\" Returns all notes for that patient. Args: patient_id (int) : ID for the patient Returns: notes (list) : A list of all notes for that patient \"\"\" mongodb_search_query = { \"patient_id\" : patient_id , \"reviewed\" : reviewed } notes = list ( mongo . db [ \"NOTES\" ] . find ( mongodb_search_query )) return notes","title":"get_patient_notes"},{"location":"query_database/#cedars.app.ops.db.get_patients_to_annotate","text":"Retrieves a patient that have not been reviewed Returns: patient_to_annotate: A single patient that needs to manually reviewed Source code in cedars/app/db.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def get_patients_to_annotate (): \"\"\" Retrieves a patient that have not been reviewed Args: None Returns: patient_to_annotate: A single patient that needs to manually reviewed \"\"\" logger . debug ( \"Retriving all un-reviewed patients from database.\" ) patients_to_annotate = mongo . db [ \"PATIENTS\" ] . find ({ \"reviewed\" : False , \"locked\" : False }) # check is this patient has any unreviewed annotations for patient in patients_to_annotate : patient_id = patient [ \"patient_id\" ] annotations = get_patient_annotation_ids ( patient_id ) if len ( annotations ) > 0 : return patient_id else : continue return None","title":"get_patients_to_annotate"},{"location":"query_database/#cedars.app.ops.db.get_prediction","text":"","title":"get_prediction"},{"location":"query_database/#cedars.app.ops.db.get_prediction--pines-predictions","text":"Get prediction from endpoint. Text goes in the POST request. Source code in cedars/app/db.py 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 def get_prediction ( note : str ) -> float : \"\"\" ##### PINES predictions Get prediction from endpoint. Text goes in the POST request. \"\"\" url = f ' { os . getenv ( \"PINES_API_URL\" ) } /predict' data = { 'text' : note } try : response = requests . post ( url , json = data , timeout = 20 ) response . raise_for_status () res = response . json ()[ \"prediction\" ] score = res . get ( \"score\" ) label = res . get ( \"label\" ) if isinstance ( label , str ): score = 1 - score if \"0\" in label else score else : score = 1 - score if label == 0 else score logger . debug ( f \"Got prediction for note: { note } with score: { score } and label: { label } \" ) return score except requests . exceptions . RequestException as e : logger . error ( f \"Failed to get prediction for note: { note } \" ) raise e","title":"PINES predictions"},{"location":"query_database/#cedars.app.ops.db.get_proj_name","text":"Returns the name of the current project. Returns: proj_name (str) : The name of the current CEDARS project. Source code in cedars/app/db.py 511 512 513 514 515 516 517 518 519 520 521 522 523 def get_proj_name (): \"\"\" Returns the name of the current project. Args: None Returns: proj_name (str) : The name of the current CEDARS project. \"\"\" proj_info = mongo . db [ \"INFO\" ] . find_one_or_404 () proj_name = proj_info [ \"project\" ] return proj_name","title":"get_proj_name"},{"location":"query_database/#cedars.app.ops.db.get_project_users","text":"Returns all the usernames for approved users (including the admin) for this project Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project Source code in cedars/app/db.py 539 540 541 542 543 544 545 546 547 548 549 550 551 def get_project_users (): \"\"\" Returns all the usernames for approved users (including the admin) for this project Args: None Returns: usernames (list) : List of all usernames for approved users (including the admin) for this project \"\"\" users = mongo . db [ \"USERS\" ] . find ({}) return [ user [ \"user\" ] for user in users ]","title":"get_project_users"},{"location":"query_database/#cedars.app.ops.db.get_search_query","text":"This function is used to get the current search query from the database. All this data is kept in the QUERY collection. Source code in cedars/app/db.py 272 273 274 275 276 277 278 279 280 281 282 def get_search_query (): \"\"\" This function is used to get the current search query from the database. All this data is kept in the QUERY collection. \"\"\" query = mongo . db [ \"QUERY\" ] . find_one ({ \"current\" : True }) if query : return query [ \"query\" ] return \"\"","title":"get_search_query"},{"location":"query_database/#cedars.app.ops.db.get_total_counts","text":"Returns the total number of documents in a collection. Parameters: collection_name ( str) ) \u2013 The name of the collection to search. Returns: count (int) : The number of documents in the collection. Source code in cedars/app/db.py 616 617 618 619 620 621 622 623 624 625 def get_total_counts ( collection_name : str ) -> int : \"\"\" Returns the total number of documents in a collection. Args: collection_name (str) : The name of the collection to search. Returns: count (int) : The number of documents in the collection. \"\"\" return mongo . db [ collection_name ] . count_documents ({})","title":"get_total_counts"},{"location":"query_database/#cedars.app.ops.db.get_user","text":"This function is used to get a user from the database. Parameters: username ( str) ) \u2013 The name of the user to get. Returns: user (dict) : The user object from the database. Source code in cedars/app/db.py 260 261 262 263 264 265 266 267 268 269 270 def get_user ( username ): \"\"\" This function is used to get a user from the database. Args: username (str) : The name of the user to get. Returns: user (dict) : The user object from the database. \"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ \"user\" : username }) return user","title":"get_user"},{"location":"query_database/#cedars.app.ops.db.insert_one_annotation","text":"Adds an annotation to the database. Parameters: annotation ( dict) ) \u2013 The annotation we are inserting Returns: None Source code in cedars/app/db.py 246 247 248 249 250 251 252 253 254 255 256 257 def insert_one_annotation ( annotation ): \"\"\" Adds an annotation to the database. Args: annotation (dict) : The annotation we are inserting Returns: None \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] annotations_collection . insert_one ( annotation )","title":"insert_one_annotation"},{"location":"query_database/#cedars.app.ops.db.is_admin_user","text":"check if the user is admin Source code in cedars/app/db.py 837 838 839 840 841 842 843 844 def is_admin_user ( username ): \"\"\"check if the user is admin\"\"\" user = mongo . db [ \"USERS\" ] . find_one ({ 'user' : username }) if user is not None and user [ \"is_admin\" ]: return True return False","title":"is_admin_user"},{"location":"query_database/#cedars.app.ops.db.mark_annotation_reviewed","text":"Updates the annotation in the database to mark it as reviewed. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. Returns: None Source code in cedars/app/db.py 661 662 663 664 665 666 667 668 669 670 671 672 def mark_annotation_reviewed ( annotation_id ): \"\"\" Updates the annotation in the database to mark it as reviewed. Args: annotation_id (str) : Unique ID for the annotation. Returns: None \"\"\" logger . debug ( f \"Marking annotation # { annotation_id } as reviewed.\" ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"reviewed\" : True } })","title":"mark_annotation_reviewed"},{"location":"query_database/#cedars.app.ops.db.mark_note_reviewed","text":"Updates the note's status to reviewed in the database. Source code in cedars/app/db.py 722 723 724 725 726 727 728 729 def mark_note_reviewed ( note_id , reviewed_by : str ): \"\"\" Updates the note's status to reviewed in the database. \"\"\" logger . debug ( f \"Marking note # { note_id } as reviewed.\" ) mongo . db [ \"NOTES\" ] . update_one ({ \"text_id\" : note_id }, { \"$set\" : { \"reviewed\" : True , \"reviewed_by\" : reviewed_by } })","title":"mark_note_reviewed"},{"location":"query_database/#cedars.app.ops.db.mark_patient_reviewed","text":"Updates the patient's status to reviewed in the database. Parameters: patient_id ( int) ) \u2013 Unique ID for a patient. reviewed_by ( str) ) \u2013 The name of the user who reviewed the patient. is_reviewed ( bool) , default: True ) \u2013 True if patient's annotations have been reviewed. Returns: None Source code in cedars/app/db.py 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 def mark_patient_reviewed ( patient_id , reviewed_by : str , is_reviewed = True ): \"\"\" Updates the patient's status to reviewed in the database. Args: patient_id (int) : Unique ID for a patient. reviewed_by (str) : The name of the user who reviewed the patient. is_reviewed (bool) : True if patient's annotations have been reviewed. Returns: None \"\"\" logger . debug ( f \"Marking patient # { patient_id } as reviewed.\" ) mongo . db [ \"PATIENTS\" ] . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"reviewed\" : is_reviewed , \"reviewed_by\" : reviewed_by } })","title":"mark_patient_reviewed"},{"location":"query_database/#cedars.app.ops.db.populate_annotations","text":"This function creates the annotations and patients collections in the mongodb database. The annotations collection is used to store the NLP annotations generated by our NLP model. The patients collection is used to store the patient ids as well as their current status. Source code in cedars/app/db.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def populate_annotations (): \"\"\" This function creates the annotations and patients collections in the mongodb database. The annotations collection is used to store the NLP annotations generated by our NLP model. The patients collection is used to store the patient ids as well as their current status. \"\"\" annotations = mongo . db [ \"ANNOTATIONS\" ] annotations . create_index ( \"patient_id\" , unique = False ) annotations . create_index ( \"note_id\" , unique = False ) annotations . create_index ( \"text_id\" , unique = False ) annotations . create_index ( \"sentence_number\" , unique = False ) annotations . create_index ( \"start_index\" , unique = False ) logger . info ( \"Created ANNOTATIONS collection.\" ) # This statement is used to create a collection. patients = mongo . db [ \"PATIENTS\" ] logger . info ( f \"Created { patients . name } collection.\" )","title":"populate_annotations"},{"location":"query_database/#cedars.app.ops.db.populate_notes","text":"This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. Source code in cedars/app/db.py 88 89 90 91 92 93 94 95 96 97 98 99 def populate_notes (): \"\"\" This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. \"\"\" notes = mongo . db [ \"NOTES\" ] notes . create_index ( \"patient_id\" , unique = False ) notes . create_index ( \"doc_id\" , unique = False ) notes . create_index ( \"text_id\" , unique = True ) logger . info ( \"Created NOTES collection.\" )","title":"populate_notes"},{"location":"query_database/#cedars.app.ops.db.populate_patients","text":"This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. Source code in cedars/app/db.py 101 102 103 104 105 106 107 108 109 110 def populate_patients (): \"\"\" This function creates the notes collection in the mongodb database. The notes collection is used to store the patient's medical records. \"\"\" notes = mongo . db [ \"Patients\" ] notes . create_index ( \"patient_id\" , unique = True ) logger . info ( \"Created Patients collection.\" )","title":"populate_patients"},{"location":"query_database/#cedars.app.ops.db.populate_query","text":"This function creates the query collection in the mongodb database. The query collection is used to store the regex queries that researchrs are using. Source code in cedars/app/db.py 122 123 124 125 126 127 128 129 130 def populate_query (): \"\"\" This function creates the query collection in the mongodb database. The query collection is used to store the regex queries that researchrs are using. \"\"\" # Pylint disabled for pointless statement. # This statement is used to create a collection. query = mongo . db [ \"QUERY\" ] logger . info ( \"Created %s collection.\" , query . name )","title":"populate_query"},{"location":"query_database/#cedars.app.ops.db.populate_users","text":"This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. Source code in cedars/app/db.py 112 113 114 115 116 117 118 119 120 def populate_users (): \"\"\" This function creates the users collection in the mongodb database. The users collection is used to store the credentials of users of the CEDARS system. \"\"\" users = mongo . db [ \"USERS\" ] users . create_index ( \"user\" , unique = True ) logger . info ( \"Created USERS collection.\" )","title":"populate_users"},{"location":"query_database/#cedars.app.ops.db.predict_and_save","text":"","title":"predict_and_save"},{"location":"query_database/#cedars.app.ops.db.predict_and_save--save-pines-predictions","text":"Predict and save the predictions for the given text_ids. Source code in cedars/app/db.py 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 def predict_and_save ( text_ids : Optional [ list [ str ]] = None , note_collection_name : str = \"NOTES\" , pines_collection_name : str = \"PINES\" , force_update : bool = False ) -> None : \"\"\" ##### Save PINES predictions Predict and save the predictions for the given text_ids. \"\"\" notes_collection = mongo . db [ note_collection_name ] pines_collection = mongo . db [ pines_collection_name ] query = {} if text_ids is not None : query = { \"text_id\" : { \"$in\" : text_ids }} cedars_notes = notes_collection . find ( query ) for note in cedars_notes : note_id = note . get ( \"text_id\" ) if force_update or get_note_prediction_from_db ( note_id , pines_collection_name ) is None : logger . info ( f \"Predicting for note: { note_id } \" ) prediction = get_prediction ( note . get ( \"text\" )) pines_collection . insert_one ({ \"text_id\" : note_id , \"text\" : note . get ( \"text\" ), \"patient_id\" : note . get ( \"patient_id\" ), \"predicted_score\" : prediction , \"report_type\" : note . get ( \"text_tag_3\" ), \"document_type\" : note . get ( \"text_tag_1\" ) })","title":"Save PINES predictions"},{"location":"query_database/#cedars.app.ops.db.remove_all_locked","text":"Sets the locked status of all patients to False. This is done when the server is shutting down. Source code in cedars/app/db.py 780 781 782 783 784 785 786 787 def remove_all_locked (): \"\"\" Sets the locked status of all patients to False. This is done when the server is shutting down. \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_many ({}, { \"$set\" : { \"locked\" : False } })","title":"remove_all_locked"},{"location":"query_database/#cedars.app.ops.db.reset_patient_reviewed","text":"Update all patients, notes to be un-reviewed. Source code in cedars/app/db.py 730 731 732 733 734 735 736 737 738 def reset_patient_reviewed (): \"\"\" Update all patients, notes to be un-reviewed. \"\"\" mongo . db [ \"PATIENTS\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False , \"reviewed_by\" : \"\" , \"comments\" : [] } }) mongo . db [ \"NOTES\" ] . update_many ({}, { \"$set\" : { \"reviewed\" : False } })","title":"reset_patient_reviewed"},{"location":"query_database/#cedars.app.ops.db.save_query","text":"This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Parameters: query ( str) ) \u2013 The regex query. exclude_negated ( bool) ) \u2013 True if we want to exclude negated tokens. hide_duplicates ( bool) ) \u2013 True if we want to restrict duplicate queries. skip_after_event ( bool) ) \u2013 True if sentences occurring after a recorded clinical event are to be skipped. tag_query ( dict of mapping [str ) \u2013 list]) : Key words to include or exclude in the search. date_min ( str) , default: None ) \u2013 Smallest date for valid query. date_max ( str) , default: None ) \u2013 Greatest date for valid query. Returns: None Source code in cedars/app/db.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def save_query ( query , exclude_negated , hide_duplicates , #pylint: disable=R0913 skip_after_event , tag_query , date_min = None , date_max = None ): \"\"\" This function is used to save a regex query to the database. All this data is kept in the QUERY collection. Args: query (str) : The regex query. exclude_negated (bool) : True if we want to exclude negated tokens. hide_duplicates (bool) : True if we want to restrict duplicate queries. skip_after_event (bool) : True if sentences occurring after a recorded clinical event are to be skipped. tag_query (dict of mapping [str : list]) : Key words to include or exclude in the search. date_min (str) : Smallest date for valid query. date_max (str) : Greatest date for valid query. Returns: None \"\"\" info = { \"query\" : query , \"exclude_negated\" : exclude_negated , \"hide_duplicates\" : hide_duplicates , \"skip_after_event\" : skip_after_event , \"tag_query\" : tag_query , \"date_min\" : date_min , \"date_max\" : date_max } collection = mongo . db [ \"QUERY\" ] # only one query is current at a time. # TODO: make a query history and enable multiple queries. info [ \"current\" ] = True collection . update_one ({ \"current\" : True }, { \"$set\" : { \"current\" : False }}) collection . insert_one ( info ) logger . info ( f \"Saved query : { query } .\" )","title":"save_query"},{"location":"query_database/#cedars.app.ops.db.set_patient_lock_status","text":"Updates the status of the patient to be locked or unlocked. Parameters: patient_id ( int) ) \u2013 ID for the patient we are locking / unlocking status ( bool) ) \u2013 True if the patient is being locked, False otherwise. Returns: \u2013 None Source code in cedars/app/db.py 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 def set_patient_lock_status ( patient_id , status ): \"\"\" Updates the status of the patient to be locked or unlocked. Args: patient_id (int) : ID for the patient we are locking / unlocking status (bool) : True if the patient is being locked, False otherwise. Returns: None \"\"\" patients_collection = mongo . db [ \"PATIENTS\" ] patients_collection . update_one ({ \"patient_id\" : patient_id }, { \"$set\" : { \"locked\" : status } })","title":"set_patient_lock_status"},{"location":"query_database/#cedars.app.ops.db.terminate_project","text":"","title":"terminate_project"},{"location":"query_database/#cedars.app.ops.db.terminate_project--terminate-the-project","text":"Reset the database to the initial state. Source code in cedars/app/db.py 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 def terminate_project (): \"\"\" ##### Terminate the Project Reset the database to the initial state. \"\"\" logger . info ( \"Terminating project.\" ) mongo . db . drop_collection ( \"ANNOTATIONS\" ) mongo . db . drop_collection ( \"NOTES\" ) mongo . db . drop_collection ( \"PATIENTS\" ) mongo . db . drop_collection ( \"USERS\" ) mongo . db . drop_collection ( \"QUERY\" ) mongo . db . drop_collection ( \"PINES\" ) create_project ( project_name = fake . slug (), investigator_name = fake . name ())","title":"Terminate the Project"},{"location":"query_database/#cedars.app.ops.db.update_annotation_date","text":"Enters a new event date for an annotation. Parameters: annotation_id ( str) ) \u2013 Unique ID for the annotation. new_date ( str) ) \u2013 The new value to update the event date of an annotation with. Must be in the format YYYY-MM-DD . Returns: None Source code in cedars/app/db.py 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 def update_annotation_date ( annotation_id , new_date ): \"\"\" Enters a new event date for an annotation. Args: annotation_id (str) : Unique ID for the annotation. new_date (str) : The new value to update the event date of an annotation with. Must be in the format YYYY-MM-DD . Returns: None \"\"\" # TODO: UTC dates logger . debug ( f \"Updating date on annotation # { annotation_id } to { new_date } .\" ) date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( new_date , date_format ) mongo . db [ \"ANNOTATIONS\" ] . update_one ({ \"_id\" : ObjectId ( annotation_id )}, { \"$set\" : { \"event_date\" : datetime_obj } })","title":"update_annotation_date"},{"location":"query_database/#cedars.app.ops.db.update_annotation_reviewed","text":"Mark all annotations for a note as reviewed. Parameters: note_id ( str) ) \u2013 The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. Source code in cedars/app/db.py 790 791 792 793 794 795 796 797 798 799 800 801 802 def update_annotation_reviewed ( note_id : str ) -> int : \"\"\" Mark all annotations for a note as reviewed. Args: note_id (str) : The note_id for which we want to mark all annotations as reviewed. Returns: count (int) : The number of annotations that were marked as reviewed. \"\"\" annotations_collection = mongo . db [ \"ANNOTATIONS\" ] result = annotations_collection . update_many ({ \"note_id\" : note_id }, { \"$set\" : { \"reviewed\" : True }}) return result . modified_count","title":"update_annotation_reviewed"},{"location":"query_database/#cedars.app.ops.db.update_project_name","text":"Updates the project name in the INFO collection of the database. Parameters: new_name ( str) ) \u2013 New name of the project. Returns: None Source code in cedars/app/db.py 649 650 651 652 653 654 655 656 657 658 659 def update_project_name ( new_name ): \"\"\" Updates the project name in the INFO collection of the database. Args: new_name (str) : New name of the project. Returns: None \"\"\" logger . info ( f \"Updating project name to # { new_name } \" ) mongo . db [ \"INFO\" ] . update_one ({}, { \"$set\" : { \"project\" : new_name } })","title":"update_project_name"},{"location":"query_database/#cedars.app.ops.db.upload_notes","text":"This function is used to take a dataframe of patient records and save it to the mongodb database. Parameters: documents ( pandas dataframe) ) \u2013 Dataframe with all the records of a paticular patient. Returns: None Source code in cedars/app/db.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 def upload_notes ( documents ): \"\"\" This function is used to take a dataframe of patient records and save it to the mongodb database. Args: documents (pandas dataframe) : Dataframe with all the records of a paticular patient. Returns: None \"\"\" notes_collection = mongo . db [ \"NOTES\" ] patient_ids = set () for i in range ( len ( documents )): note_info = documents . iloc [ i ] . to_dict () date_format = '%Y-%m- %d ' datetime_obj = datetime . strptime ( note_info [ \"text_date\" ], date_format ) note_info [ \"text_date\" ] = datetime_obj note_info [ \"reviewed\" ] = False # text_id should be unique notes_collection . insert_one ( note_info ) patient_ids . add ( note_info [ \"patient_id\" ]) if i + 1 % 10 == 0 : logger . info ( f \"Uploaded { i } / { len ( documents ) } notes\" ) patients_collection = mongo . db [ \"PATIENTS\" ] for p_id in patient_ids : patient_info = { \"patient_id\" : p_id , \"reviewed\" : False , \"locked\" : False , \"updated\" : False , \"admin_locked\" : False } if not patients_collection . find_one ({ \"patient_id\" : p_id }): patients_collection . insert_one ( patient_info )","title":"upload_notes"},{"location":"upload_data/","text":"Uploading EMR Records To make use of this software, we will first need to upload some medical records to the database. To do this, you can click on the dropdown menu on the top right of the page. From here you can select the \"Upload Data\" option. This will redirect you to a page where you can select a file with the data from your computer by clicking the \"Choose File\" button. The allowed file formats for this data are: CSV (.csv) Excel (.xlsx) Json (.json) Parquet (.parquet) Pickle (.pickle or .pkl) XML (.xml) The file with the data should contain tabular data with at least the following columns: 1. patient_id (A unique ID for the patient) 2. text_id (A unique ID for the medical note) 3. text (The medical note written by a doctor) 4. text_date (The date at which this note was recorded) Reference The data/notes is uploaded to MongoDB using the following functions: Upload Data This is a flask function for the backend logic to upload a file to the database. Source code in cedars/app/ops.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @bp . route ( \"/upload_data\" , methods = [ \"GET\" , \"POST\" ]) @auth . admin_required def upload_data (): \"\"\" This is a flask function for the backend logic to upload a file to the database. \"\"\" filename = None if request . method == \"POST\" : filename = None minio_file = request . form . get ( \"miniofile\" ) if minio_file != \"None\" : logger . info ( f \"Using minio file: { minio_file } \" ) filename = minio_file else : if 'data_file' not in request . files : flash ( 'No file part' ) return redirect ( request . url ) file = request . files [ 'data_file' ] if file . filename == '' : flash ( 'No selected file' ) return redirect ( request . url ) if file and not allowed_data_file ( file . filename ): flash ( \"Invalid file type. Please upload a .csv, .xlsx, .json, .parquet, .pickle, .pkl, or .xml file.\" ) return redirect ( request . url ) filename = f \"uploaded_files/ { secure_filename ( file . filename ) } \" size = os . fstat ( file . fileno ()) . st_size try : client . put_object ( \"cedars\" , filename , file , size ) logger . info ( f \"File - { file . filename } uploaded successfully.\" ) flash ( f \" { filename } uploaded successfully.\" ) except Exception as e : filename = None flash ( f \"Failed to upload file: { str ( e ) } \" ) return redirect ( request . url ) if filename : try : EMR_to_mongodb ( filename ) flash ( f \"Data from { filename } uploaded to the database.\" ) return redirect ( url_for ( 'ops.upload_query' )) except Exception as e : flash ( f \"Failed to upload data: { str ( e ) } \" ) return redirect ( request . url ) try : files = [( obj . object_name , obj . size ) for obj in client . list_objects ( \"cedars\" , prefix = \"uploaded_files/\" )] except Exception as e : flash ( f \"Error listing files: { e } \" ) files = [] return render_template ( \"ops/upload_file.html\" , files = files , ** db . get_info ()) Upload EMR data to MongoDB This function is used to open a csv file and load it's contents into the mongodb database. Parameters: filename ( str) ) \u2013 The path to the file to load data from. Returns: None Source code in cedars/app/ops.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def EMR_to_mongodb ( filepath ): #pylint: disable=C0103 \"\"\" This function is used to open a csv file and load it's contents into the mongodb database. Args: filename (str) : The path to the file to load data from. For valid file extensions refer to the allowed_data_file function above. Returns: None \"\"\" data_frame = load_pandas_dataframe ( filepath ) if data_frame is None : return logger . info ( f \"columns in dataframe: \\n { data_frame . columns } \" ) logger . debug ( data_frame . head ()) id_list = data_frame [ \"patient_id\" ] . unique () logger . info ( \"Starting document migration to mongodb database.\" ) for i , p_id in enumerate ( id_list ): documents = data_frame [ data_frame [ \"patient_id\" ] == p_id ] db . upload_notes ( documents ) logger . info ( f \"Documents uploaded for patient # { i + 1 } \" ) logger . info ( \"Completed document migration to mongodb database.\" )","title":"Uploading EMR Records"},{"location":"upload_data/#uploading-emr-records","text":"To make use of this software, we will first need to upload some medical records to the database. To do this, you can click on the dropdown menu on the top right of the page. From here you can select the \"Upload Data\" option. This will redirect you to a page where you can select a file with the data from your computer by clicking the \"Choose File\" button. The allowed file formats for this data are: CSV (.csv) Excel (.xlsx) Json (.json) Parquet (.parquet) Pickle (.pickle or .pkl) XML (.xml) The file with the data should contain tabular data with at least the following columns: 1. patient_id (A unique ID for the patient) 2. text_id (A unique ID for the medical note) 3. text (The medical note written by a doctor) 4. text_date (The date at which this note was recorded)","title":"Uploading EMR Records"},{"location":"upload_data/#reference","text":"The data/notes is uploaded to MongoDB using the following functions:","title":"Reference"},{"location":"upload_data/#upload-data","text":"This is a flask function for the backend logic to upload a file to the database. Source code in cedars/app/ops.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 @bp . route ( \"/upload_data\" , methods = [ \"GET\" , \"POST\" ]) @auth . admin_required def upload_data (): \"\"\" This is a flask function for the backend logic to upload a file to the database. \"\"\" filename = None if request . method == \"POST\" : filename = None minio_file = request . form . get ( \"miniofile\" ) if minio_file != \"None\" : logger . info ( f \"Using minio file: { minio_file } \" ) filename = minio_file else : if 'data_file' not in request . files : flash ( 'No file part' ) return redirect ( request . url ) file = request . files [ 'data_file' ] if file . filename == '' : flash ( 'No selected file' ) return redirect ( request . url ) if file and not allowed_data_file ( file . filename ): flash ( \"Invalid file type. Please upload a .csv, .xlsx, .json, .parquet, .pickle, .pkl, or .xml file.\" ) return redirect ( request . url ) filename = f \"uploaded_files/ { secure_filename ( file . filename ) } \" size = os . fstat ( file . fileno ()) . st_size try : client . put_object ( \"cedars\" , filename , file , size ) logger . info ( f \"File - { file . filename } uploaded successfully.\" ) flash ( f \" { filename } uploaded successfully.\" ) except Exception as e : filename = None flash ( f \"Failed to upload file: { str ( e ) } \" ) return redirect ( request . url ) if filename : try : EMR_to_mongodb ( filename ) flash ( f \"Data from { filename } uploaded to the database.\" ) return redirect ( url_for ( 'ops.upload_query' )) except Exception as e : flash ( f \"Failed to upload data: { str ( e ) } \" ) return redirect ( request . url ) try : files = [( obj . object_name , obj . size ) for obj in client . list_objects ( \"cedars\" , prefix = \"uploaded_files/\" )] except Exception as e : flash ( f \"Error listing files: { e } \" ) files = [] return render_template ( \"ops/upload_file.html\" , files = files , ** db . get_info ())","title":"Upload Data"},{"location":"upload_data/#upload-emr-data-to-mongodb","text":"This function is used to open a csv file and load it's contents into the mongodb database. Parameters: filename ( str) ) \u2013 The path to the file to load data from. Returns: None Source code in cedars/app/ops.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def EMR_to_mongodb ( filepath ): #pylint: disable=C0103 \"\"\" This function is used to open a csv file and load it's contents into the mongodb database. Args: filename (str) : The path to the file to load data from. For valid file extensions refer to the allowed_data_file function above. Returns: None \"\"\" data_frame = load_pandas_dataframe ( filepath ) if data_frame is None : return logger . info ( f \"columns in dataframe: \\n { data_frame . columns } \" ) logger . debug ( data_frame . head ()) id_list = data_frame [ \"patient_id\" ] . unique () logger . info ( \"Starting document migration to mongodb database.\" ) for i , p_id in enumerate ( id_list ): documents = data_frame [ data_frame [ \"patient_id\" ] == p_id ] db . upload_notes ( documents ) logger . info ( f \"Documents uploaded for patient # { i + 1 } \" ) logger . info ( \"Completed document migration to mongodb database.\" )","title":"Upload EMR data to MongoDB"}]}