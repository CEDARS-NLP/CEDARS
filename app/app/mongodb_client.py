"""
Loading Libraries
"""
import pymongo
import pandas as pd
from datetime import datetime
from NLP_processor import NLP_processor


class DatabaseConnector:
   def __init__(self, db_name, model_name, db_url = "mongodb://localhost:27017/"):
      """
      This function loads and stores the database and nlp processer for future use.
      ------
      ARGS
      db_name (str) :- Name of the mongodb database
      model_name (str) :- Name of the spacy model to load. In this instance, we are only using sci-spacy models.
      db_url (str) :- URL for the mongodb server.
      ----
      Return type
      None
      """
      myclient = pymongo.MongoClient(db_url)

      self.database_connector = myclient[db_name] # create / open database

      self.nlp_processor = NLP_processor(model_name)

   def create_project(self, project_name, investigator_name, cedars_version):
      """
      This function creates all the collections in the mongodb database that CEDARS will require for it's operations.
      ------
      ARGS
      project_name (str) :- Name of the research project
      investigator_name (str) :- Name of the investigator on this project
      cedars_version (str) :- Version of CEDARS used for this project
      ----
      Return type
      None
      """
      self.create_info_col(project_name, investigator_name, cedars_version)

      self.populate_annotations()
      self.populate_notes()
      self.populate_users()
      self.populate_query()

      print("Database creation successful!")
   
   def create_info_col(self, project_name, investigator_name, cedars_version):
      """
      This function creates the info collection in the mongodb database.
      The info collection is used to store meta-data regarding the current project.
      ------
      ARGS
      project_name (str) :- Name of the research project
      investigator_name (str) :- Name of the investigator on this project
      cedars_version (str) :- Version of CEDARS used for this project
      ----
      Return type
      None
      """
      collection = self.database_connector["INFO"]
      info = {"creation_time" : datetime.now(), "project" : project_name,
              "investigator" : investigator_name, "CEDARS_version" : cedars_version}
     
      collection.insert_one(info)


   def populate_annotations(self):
      """
      This function creates the annotations and patients collections in the mongodb database.
      The annotations collection is used to store the NLP annotations generated by our NLP model.
      The patients collection is used to store the patient ids as well as their current status.
      ------
      ARGS
      None
      ----
      Return type
      None
      """
      annotations = self.database_connector["ANNOTATIONS"]

      index_columns = ["patient_id", "note_id", "text_id", "sentence_number", "start_index"]

      annotations.create_index("patient_id", unique = False)
      annotations.create_index("note_id", unique = False)
      annotations.create_index("text_id", unique = False)
      annotations.create_index("sentence_number", unique = False)
      annotations.create_index("start_index", unique = False)

      # annotations.create_index(index_columns, unique = True, name = "annotations_index")

      patients = self.database_connector["PATIENTS"]
      # To force mongodb to create an empty collection with only the default index, we create and drop a dummy ID
      patients.create_index("id", unique = True)
      patients.drop_index("id_1")

   def populate_notes(self):
      """
      This function creates the notes collection in the mongodb database.
      The notes collection is used to store the patient's medical records.
      ------
      ARGS
      None
      ----
      Return type
      None
      """
      notes = self.database_connector["NOTES"]

      notes.create_index("patient_id", unique = False)
      notes.create_index("doc_id", unique = False)
      notes.create_index("text_id", unique = True)

   def populate_users(self):
      """
      This function creates the users collection in the mongodb database.
      The users collection is used to store the credentials of users logging into the CEDARS system.
      ------
      ARGS
      None
      ----
      Return type
      None
      """
      users = self.database_connector["USERS"]

      users.create_index("user", unique = True)

   def populate_query(self):
      """
      This function creates the query collection in the mongodb database.
      The query collection is used to store the regex queries that researchrs are using.
      ------
      ARGS
      None
      ----
      Return type
      None
      """
      query_col = self.database_connector["QUERY"]
      # To force mongodb to create an empty collection with only the default index, we create and drop a dummy ID
      query_col.create_index("id", unique = True)
      query_col.drop_index("id_1")

   def add_end_user(self, username, password):
      """
      This function is used to add a new user to the database. All this data is kept in the USERS collection.
      ------
      ARGS
      username (str) :- The name of this user.
      password (str) :- The password this user will need to login to the system.
      ----
      Return type
      None
      """
      info = {"user" : username, "password" : password, "date_created" : datetime.now()}

      collection = self.database_connector["USERS"]
      collection.insert_one(info)

   def save_query(self, query, exclude_negated, hide_duplicates, skip_after_event, tag_query, date_min = None, date_max = None):
      """
      This function is used to save a regex query to the database. All this data is kept in the QUERY collection.
      ------
      ARGS
      query (str) :- The regex query.
      exclude_negated (bool) :- True if we want to exclude negated tokens.
      hide_duplicates (bool) :- True if we want to restrict duplicate queries.
      skip_after_event (bool) :- True if sentences occurring after a recorded clinical event are to be skipped.
      tag_query (dict of mapping [str : list]) :- Key words to include or exclude in the search.
      date_min (str) :- Smallest date for valid query.
      date_max (str) :- Greatest date for valid query.
      ----
      Return type
      None
      """
      info = {"query" : query,
            "exclude_negated" : exclude_negated,
            "hide_duplicates" : hide_duplicates,
            "skip_after_event" : skip_after_event,
            "tag_query" : tag_query,
            "date_min" : date_min,
            "date_max" : date_max}
     
      collection = self.database_connector["QUERY"]
      collection.insert_one(info)

   def EMR_to_mongodb(self, csv_name):
      """
      This function is used to open a csv file and load it's contents into the mongodb database.
      ------
      ARGS
      csv_name (str) :- The name of the csv file to load data from.
      ----
      Return type
      None
      """
      df = pd.read_csv(csv_name)

      id_list = df["patient_id"].unique()

      for i, p_id in enumerate(id_list):
         documents = df[df["patient_id"] == p_id]

         self.upload_notes(documents)

         print(f"Documents uploaded for patient #{i + 1}")

   def upload_notes(self, documents):
      """
      This function is used to take a dataframe of all a patient's records and save it to the mongodb database.
      ------
      ARGS
      documents (pandas dataframe) :- Dataframe with all the records of a paticular patient.
      ----
      Return type
      None
      """
      notes_collection = self.database_connector["NOTES"]
      patient_ids = set()
      for i in range(len(documents)):
         note_info = documents.iloc[i].to_dict()
         notes_collection.insert_one(note_info)

         patient_ids.add(note_info["patient_id"])

      patients_collection = self.database_connector["PATIENTS"]
      for p_id in patient_ids:
         patient_info = {"patient_id": p_id,
                           "reviewed": False,
                           "locked": False,
                           "updated": False,
                           "admin_locked": False}
         
         patients_collection.insert_one(patient_info)


   
   def automatic_NLP_processor(self, query, patient_id = None):
      """
      This function is used to perform and save NLP annotations on one or all patients saved in the database.
      If patient_id == None we will do this for all patients in the database.
      ------
      ARGS
      query (str) :- Regex query of all what terms the researcher is looking for.
      patient_id (int) :- The ID of a patient we want to perform these annotations for.
      ----
      Return type
      None
      """
      if patient_id != None:
         patient_ids = set([patient_id])
      else:
         patients = self.database_connector["PATIENTS"].find()

         patient_ids = set([patient["patient_id"] for patient in patients])

      for p_id in patient_ids:
         print(f"Annotating patient #{p_id}.")
         self.annotate_single(query, p_id)
     
   
   def annotate_single(self, query, patient_id):
      """
      This function is used to perform and save NLP annotations on a single patient saved in the database.
      The patient information in the PATIENTS collection is also appropriately updated during this process.
      ------
      ARGS
      query (str) :- Regex query of all what terms the researcher is looking for.
      patient_id (int) :- The ID of a patient we want to perform these annotations for.
      ----
      Return type
      None
      """
      patients_collection = self.database_connector["PATIENTS"]
      patients_collection.update_one({"patient_id" : patient_id}, { "$set": { "locked": True } })

      annotations_collection = self.database_connector["ANNOTATIONS"]
      mongodb_search_query = { "patient_id": patient_id }

      for note in self.database_connector["NOTES"].find(mongodb_search_query):    
         note["note_id"] = note["_id"]
         del note["_id"]

         instances = self.nlp_processor.process_note(note["text"], query)

         for inst in instances:
            annotation = note.copy()
            annotation.update(inst)

            annotations_collection.insert_one(annotation)
         
      patients_collection.update_one({"patient_id" : patient_id}, { "$set": { "locked": False } })
      patients_collection.update_one({"patient_id" : patient_id}, { "$set": { "reviewed": True } })
