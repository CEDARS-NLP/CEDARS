"""
This file contatins an abstract class for CEDARS to interact with mongodb.
"""

from datetime import datetime
import logging
import pymongo
from werkzeug.security import check_password_hash, generate_password_hash
import pandas as pd

# Pylint disabled as the class has more than 20 public methods.
class DatabaseConnector(object): #pylint: disable=R0904
    """
    Abstract class to connect to a mongodb database.
    We define and use this as a singleton class in order to access it from different flask blueprints.
    """


    def __new__(self, db_name = None, project_name = None, investigator_name = None, 
                 cedars_version = None, db_url = "db"):
        """
        This function loads and stores the database and nlp processer for future use.

        Args:
        db_name (str) : Name of the mongodb database
        db_url (str) : URL for the mongodb server.
        
        Returns:
            None

        Raises:
            None
        """
        if not hasattr(self, 'instance'):
            self.instance = super(DatabaseConnector, self).__new__(self)
            client = pymongo.MongoClient(db_url)

            db_names = client.list_database_names()
            if db_name not in db_names:
                self.database_connector = client[db_name] # create / open database
                self.create_project(self, project_name, investigator_name, cedars_version)


            self.database_connector = client[db_name] # create / open database
        return self.instance

    

    def create_project(self, project_name, investigator_name, cedars_version):
        """
        This function creates all the collections in the mongodb database for CEDARS.
        
        Args:
            project_name (str) : Name of the research project
            investigator_name (str) : Name of the investigator on this project
            cedars_version (str) : Version of CEDARS used for this project

        Returns:
            None

        Raises:
            None
        """
        self.create_info_col(self, project_name, investigator_name, cedars_version)

        self.populate_annotations(self)
        self.populate_notes(self)
        self.populate_users(self)
        self.populate_query(self)

        logging.info("Database creation successful!")

    def create_info_col(self, project_name, investigator_name, cedars_version):
        """
        This function creates the info collection in the mongodb database.
        The info collection is used to store meta-data regarding the current project.
        
        Args:
            project_name (str) : Name of the research project
            investigator_name (str) : Name of the investigator on this project
            cedars_version (str) : Version of CEDARS used for this project

        Returns:
            None

        Raises:
            None
        """
        collection = self.database_connector["INFO"]
        info = {"creation_time" : datetime.now(), "project" : project_name,
                "investigator" : investigator_name, "CEDARS_version" : cedars_version}

        collection.insert_one(info)
        logging.info("Created INFO collection.")


    def populate_annotations(self):
        """
        This function creates the annotations and patients collections in the mongodb database.
        The annotations collection is used to store the NLP annotations generated by our NLP model.
        The patients collection is used to store the patient ids as well as their current status.
        
        Args:
            None
        
        Returns:
            None

        Raises:
            None
        """
        annotations = self.database_connector["ANNOTATIONS"]


        annotations.create_index("patient_id", unique = False)
        annotations.create_index("note_id", unique = False)
        annotations.create_index("text_id", unique = False)
        annotations.create_index("sentence_number", unique = False)
        annotations.create_index("start_index", unique = False)

        logging.info("Created ANNOTATIONS collection.")

        # This statement is used to create a collection.
        patients = self.database_connector["PATIENTS"]
        logging.info("Created %s collection.", patients.name)

    def populate_notes(self):
        """
        This function creates the notes collection in the mongodb database.
        The notes collection is used to store the patient's medical records.
        
        Args:
            None

        Returns:
            None

        Raises:
            None
        """
        notes = self.database_connector["NOTES"]

        notes.create_index("patient_id", unique = False)
        notes.create_index("doc_id", unique = False)
        notes.create_index("text_id", unique = True)

        logging.info("Created NOTES collection.")

    def populate_users(self):
        """
        This function creates the users collection in the mongodb database.
        The users collection is used to store the credentials of users of the CEDARS system.
        
        Args:
            None
        
        Returns:
            None

        Raises:
            None
        """
        users = self.database_connector["USERS"]

        users.create_index("user", unique = True)
        logging.info("Created USERS collection.")

    def populate_query(self):
        """
        This function creates the query collection in the mongodb database.
        The query collection is used to store the regex queries that researchrs are using.
        
        Args:
            None

        Returns:
            None

        Raises:
            None
        """
        # Pylint disabled for pointless statement.
        # This statement is used to create a collection.
        query = self.database_connector["QUERY"]
        logging.info("Created %s collection.", query.name)

    def add_end_user(self, username, password):
        """
        This function is used to add a new user to the database.
        All this data is kept in the USERS collection.
        
        Args:
            username (str) : The name of this user.
            password (str) : The password this user will need to login to the system.

        Returns:
            None

        Raises:
            None
        """
        info = {"user" : username, "password" : password, "date_created" : datetime.now()}

        collection = self.database_connector["USERS"]
        collection.insert_one(info)
        logging.info("Added user %s to database.", username)

    # Pylint disabled due to too many arguments
    def save_query(self, query, exclude_negated, hide_duplicates, #pylint: disable=R0913
                   skip_after_event, tag_query, date_min = None, date_max = None):

        """
        This function is used to save a regex query to the database.
        All this data is kept in the QUERY collection.
        
        Args:
            query (str) : The regex query.
            exclude_negated (bool) : True if we want to exclude negated tokens.
            hide_duplicates (bool) : True if we want to restrict duplicate queries.
            skip_after_event (bool) : True if sentences occurring
                                        after a recorded clinical event are to be skipped.
            tag_query (dict of mapping [str : list]) : 
                                        Key words to include or exclude in the search.
            date_min (str) : Smallest date for valid query.
            date_max (str) : Greatest date for valid query.
            
        Returns:
            None

        Raises:
            None
        """
        info = {"query" : query,
            "exclude_negated" : exclude_negated,
            "hide_duplicates" : hide_duplicates,
            "skip_after_event" : skip_after_event,
            "tag_query" : tag_query,
            "date_min" : date_min,
            "date_max" : date_max}

        collection = self.database_connector["QUERY"]
        collection.insert_one(info)

        logging.info("Saved query : %s.", query)


    def upload_notes(self, documents):
        """
        This function is used to take a dataframe of patient records
        and save it to the mongodb database.
        
        Args:
            documents (pandas dataframe) : Dataframe with all the records of a paticular patient.

        Returns:
            None

        Raises:
            None
        """
        notes_collection = self.database_connector["NOTES"]
        patient_ids = set()
        for i in range(len(documents)):
            note_info = documents.iloc[i].to_dict()

            date_format = '%Y-%m-%d'
            datetime_obj = datetime.strptime(note_info["text_date"], date_format)
            note_info["text_date"] = datetime_obj

            notes_collection.insert_one(note_info)

            patient_ids.add(note_info["patient_id"])

        patients_collection = self.database_connector["PATIENTS"]
        for p_id in patient_ids:
            patient_info = {"patient_id": p_id,
                            "reviewed": False,
                            "locked": False,
                            "updated": False,
                            "admin_locked": False}

            patients_collection.insert_one(patient_info)


    def get_annotation(self, annotation_id):
        """
        Retrives annotation from mongodb.

        Args:
            annotation_id (str) : Unique ID for the annotation.

        Returns:
            annotation (dict) : Dictionary for an annotation from mongodb.
                The keys are the attribute names.
                The values are the values of the attribute in that record.

        Raises:
            None
        """
        annotation = self.database_connector["ANNOTATIONS"].find_one({ "_id" : annotation_id })

        return annotation

    def get_annotaion_note(self, annotation_id):
        """
        Retrives note linked to a paticular annotation.

        Args:
            annotation_id (str) : Unique ID for the annotation.

        Returns:
            note (dict) : Dictionary for a note from mongodb.
                The keys are the attribute names.
                The values are the values of the attribute in that record.

        Raises:
            None
        """
        logging.debug("Retriving annotation #%s from database.", annotation_id)
        annotation = self.database_connector["ANNOTATIONS"].find_one({ "_id" : annotation_id })
        note = self.database_connector["NOTES"].find_one({ "_id" : annotation["note_id"] })

        return note


    def get_patient(self):
        """
        Retrives a single patient ID who has not yet been reviewed.
        The chosen patient is simply the first one in the database that has not yet been reviewed.

        Args:
            None

        Returns:
            patient_id (int) : Unique ID for a patient.

        Raises:
            None
        """

        patient = self.database_connector["PATIENTS"].find_one({"reviewed" : False})

        if patient is not None and "patient_id" in patient.keys():
            logging.debug("Retriving patient #%s from database.", patient['patient_id'])
            return patient["patient_id"]

        logging.debug("Failed to retrive any further un-reviewed patients from the database.")
        return None

    def get_patient_annotation_ids(self, p_id):
        """
        Retrives all annotation IDs for annotations linked to a patient.

        Args:
            p_id (int) : Unique ID for a patient.

        Returns:
            annotations (list) : A list of all annotation IDs linked to that patient.

        Raises:
            None
        """
        logging.debug("Retriving annotations for patient #%s from database.", str(p_id))
        annotation_ids = self.database_connector["ANNOTATIONS"].find({ "patient_id": p_id,
                                                                      "reviewed" : False, "isNegated" : False})

        return [id["_id"] for id in annotation_ids]

    def mark_annotation_reviewed(self, annotation_id):
        """
        Updates the annotation in the database to mark it as reviewed.

        Args:
            annotation_id (str) : Unique ID for the annotation.

        Returns:
            None

        Raises:
            None
        """
        logging.debug("Marking annotation #%s as reviewed.", annotation_id)
        self.database_connector["ANNOTATIONS"].update_one({"_id" : annotation_id},
                                                          { "$set": { "reviewed": True } })

    def update_annotation_date(self, annotation_id, new_date):
        """
        Enters a new event date for an annotation.

        Args:
            annotation_id (str) : Unique ID for the annotation.
            new_date (str) : The new value to update the event date of an annotation with.
                Must be in the format YYYY-MM-DD .

        Returns:
            None

        Raises:
            None
        """
        logging.debug("Updating date on annotation #%s to %s.", annotation_id, new_date)
        date_format = '%Y-%m-%d'
        datetime_obj = datetime.strptime(new_date, date_format)
        self.database_connector["ANNOTATIONS"].update_one({"_id" : annotation_id},
                                                        { "$set": { "event_date" : datetime_obj } })

    def delete_annotation_date(self, annotation_id):
        """
        Deletes the event date for an annotation.

        Args:
            annotation_id (str) : Unique ID for the annotation.

        Returns:
            None

        Raises:
            None
        """
        logging.debug("Deleting date on annotation #%s.", annotation_id)
        self.database_connector["ANNOTATIONS"].update_one({"_id" : annotation_id},
                                                          { "$set": { "event_date" : None } })



    def mark_patient_reviewed(self, patient_id, isReviewed = True):
        """
        Updates the patient's status to reviewed in the database.

        Args:
            patient_id (int) : Unique ID for a patient.

        Returns:
            None

        Raises:
            None
        """
        logging.debug("Marking patient #%s as reviewed.", patient_id)
        self.database_connector["PATIENTS"].update_one({"patient_id" : patient_id},
                                                       { "$set": { "reviewed": isReviewed } })

    def add_annotation_comment(self, annotation_id, comment):
        """
        Stores a new comment for an annotation.

        Args:
            annotation_id (str) : Unique ID for the annotation.
            comment (str) : Text of the comment on this annotation.

        Returns:
            None

        Raises:
            None
        """
        logging.debug("Adding comment to annotation #%s.", annotation_id)
        annotation = self.database_connector["ANNOTATIONS"].find_one({ "_id" : annotation_id })
        comments = annotation["comments"]
        comments.append(comment)
        self.database_connector["ANNOTATIONS"].update_one({"_id" : annotation_id},
                                                          { "$set": { "comments" : comments } })

    def empty_annotations(self):
        logging.info("Deleting all data in annotations collection.")
        annotations = self.database_connector["ANNOTATIONS"]
        annotations.delete_many({})

    def get_reviewed_annotations(self):
        annotations = self.database_connector["ANNOTATIONS"].find({"reviewed" : True})

        return [anno for anno in annotations]
    
    def get_proj_name(self):
        proj_info = self.database_connector["INFO"].find_one()

        return proj_info["project"]
    
    def update_proj_name(self, new_name):
        logging.debug("Updating project name to #%s.", new_name)
        self.database_connector["INFO"].update_one({},
                                                   { "$set": { "project": new_name } })

    
    def get_curr_version(self):
        proj_info = self.database_connector["INFO"].find_one()

        return proj_info["CEDARS_version"]
    
    def add_project_user(self, username, password, isAdmin = False):
        password_hash = generate_password_hash(password)
        data = {"user" : username, "password" : password_hash, "admin" : isAdmin}
        self.database_connector["USERS"].insert_one(data.copy())

    def check_password(self, username, password):
        user = self.database_connector["USERS"].find_one({"user" : username})
        
        if "password" in user and check_password_hash(user["password"], password):
            return True
        else:
            return False
    

    def get_project_users(self):
        users = self.database_connector["USERS"].find({})

        return [user["user"] for user in users]
    
    def get_users(self):
        users = self.database_connector["USERS"].find()

        return [user["user"] for user in users]
    

    def get_curr_stats(self):
        stats = {}
        patients = self.database_connector["PATIENTS"].find()

        stats["number_of_patients"] = len([patient for patient in patients])

        annotations = self.database_connector["ANNOTATIONS"].find()
        unique_patients = set([annotation["patient_id"] for annotation in annotations])

        stats["number_of_annotated_patients"] = len(unique_patients)

        reviewed_annotations = self.database_connector["ANNOTATIONS"].find({"reviewed" : True})
        stats["number_of_reviewed"] = len([i for i in reviewed_annotations])

        return stats
    
    def get_all_patients(self):
        patients = self.database_connector["PATIENTS"].find()

        return [patient for patient in patients]
    
    def set_patient_lock_status(self, patient_id, status):
        patients_collection = self.database_connector["PATIENTS"]
        patients_collection.update_one({"patient_id" : patient_id}, { "$set": { "locked": status } })

    def get_patient_notes(self, patient_id):
        mongodb_search_query = { "patient_id": patient_id }

        notes = self.database_connector["NOTES"].find(mongodb_search_query)

        return notes
    
    def insert_one_annotation(self, annotation):
        annotations_collection = self.database_connector["ANNOTATIONS"]

        annotations_collection.insert_one(annotation)

        
    